%% Basic widgets -- onew with MVC in next chapter

This chapter covers some of the basic dialogs and widgets provided by
\Qt. Together with layouts, these form the basis for most user
interfaces. The next chapter will introduce the more complex widgets
that typically act as a view for a separate data model.

\SweaveInput{Dialogs}

%% MFL: Should probably use a similar organization to RGtk2. Except
%% for the layouts and containers.

%% JV: Similar, we should move dialogs earlier there, as you have suggested

%% MFL: Also, MVC is a software engineering concept. It might be
%% better to divide things on a conceptual axis that is more
%% interesting to statisticians. Like basic input controls and widgets
%% that primarily display data. Besides, at some level every
%% widget follows the MVC pattern.

%% JV: I can see that, but the division is basically by level of
%% complexity. Some widgets require an understanding of the backend
%% model, others don't. I was originally going to put the convenience
%% widgets for tables and trees in this chapter, but it got too long
%% so put them in the next one. I had originally thought dialogs
%% should go later, but you've convinced me to place them earlier, due
%% to their fundamental nature. Perhaps they could be a separate,
%% short, chapter and then some of the combobbox/listbox/table stuff
%% could slide in here.

\section{Labels}
\label{sec:labels}

%% QLabel maps to both GtkLabel and GtkImage

As seen in previous example, basic labels in \Qt{} are instances of
the \class{QLabel} class. Labels in \Qt{} are the primary means for
displaying static text and images. Textual labels are the most common,
and the constructor accepts a string for the text, which can be plain
text or, for rich text, HTML. Here we use HTML to display red text:
<<qt-widget-label>>=
l <- Qt$QLabel("<font color='red'>Red</font>")
@ 
<<echo=FALSE, results=hide>>=
## labels can use rich text
l$show(); l$raise()
@ 
% 
By default, \class{QLabel} guesses whether the string is rich or plain
text. In the above, the rich text format is identified from the
markup. The \property{textFormat}{QLabel} property overrides this.

The label text is stored in the \property{text}{QLabel} property.
Properties relevant to text layout include:
\property{alignment}{QLabel}, \property{indent}{QLabel} (in pixels),
\property{margin}{QLabel}, and \property{wordWrap}{QLabel}.

\section{Buttons}
\label{sec:buttons}

As we have seen, the ordinary button in \Qt{} is called
\class{QPushButton}, which inherits most of its functionality from
\class{QAbstractButton}, the common base class for buttons. We create
a simple button ``Ok'' button:
<<qt-widget-button>>=
button <- Qt$QPushButton("Ok")
@ 
%
<<echo=FALSE, results=hide>>=
b$show(); b$raise()
@ 
%

Like any other widget, a button may be disabled, so that the user
cannot press it:
<<qt-widget-button-disable>>=
button$enabled <- FALSE
@ 
%
This is useful for preventing the user from attempting to execute
commands that do not apply to the current state of the
application. \Qt{} changes the rendering widget, including that of the
icon, to indicate the disabled state.

A push button usually executes some command when clicked, i.e., when
the \signal{clicked} signal is emitted:
<<qt-widget-button-connect>>=
qconnect(button, "clicked", function() message("Ok clicked") )
@ 
%% EXAMPLE: connect to clicked signal

\subsection{Icons and pixmaps}
\label{ssec:icons}

%% FIXME: perhaps merge the icon discussion into this section? It is
%% not clear if we want to go into great detail about images in Qt. If
%% we did, it would probably belong in a different chapter.

%% JV: I moved this into the button discussion and out of the label
%% discussion and made it a subsection.


A button is often decorated with an icon, which serves as a visual
indicator of the purpose of the button. The \class{QIcon} class
represents an icon and may be loaded from a file or constructed
from an image stored in memory as \class{QPixmap} object.

Although one may, it is
not necessary to define icons for different sizes and display modes
(normal, disabled, active, selected), as \Qt{} can do so
automatically.

%% A QPixmap is a server-side image, which makes it faster to display
%% but slower to modify. QImage is client-side. QPixmap is to
%% GdkPixmap as QImage is to GdkPixbuf. QPicture is a vectorized
%% image, and QMovie represents animated images.

\class{QPixmap} stores its image data in manner that is efficient for
display on the screen \footnote{\class{QPixmap} is not to be confused
  with \class{QImage}, which is optimized for image manipulation, or
  the vector-based \class{QPicture}}. One can load a pixmap from a
file or create a blank image and draw on it using the \Qt{} painting
API (not discussed in this book). Also, using the \pkg{qtutils}
package, we can draw a pixmap using the R graphics engine. For
example, the following uses \pkg{ggplot2} to generate an icon
representing a histogram. First, we create the \Qt{} graphics device
and plot the icon with \pkg{grid}:
<<echo=FALSE, results=hide>>=
require(grid)
require(ggplot2)
@ 
<<results=hide>>=
device <- QT()
grid.newpage()
grid.draw(GeomHistogram$icon())
@ 
%
Next, we create the blank pixmap and render the device to a paint
context attached to the pixmap:
<<results=hide>>=
pixmap <- Qt$QPixmap(device$size$toSize())
pixmap$fill()
painter <- Qt$QPainter()
painter$begin(pixmap)
device$render(painter)
painter$end()
@ 
%
Finally, we use the icon in a button:
<<results=hide>>=
b <- Qt$QPushButton("Histogram")
b$setIcon(Qt$QIcon(pixmap))
@ 

<<echo=FALSE, results=hide>>=
b$show()
b$raise()
@ 


\section{Checkboxes}
\label{sec:checkboxes}

The \class{QCheckBox} class implements a checkbox. Like the
\class{QPushButton} class, \class{QCheckBox} extends
\class{QAbstractButton}. Thus, \class{QCheckBox} inherits the signals
\signal{clicked}, \signal{pressed}, and \signal{released}. We create a
check box for our demonstration:
<<qt-widget-checkbox>>=
checkBox <- Qt$QCheckBox("Option")
@ 

The \property{checked}{QCheckBox} property indicates whether the
button is checked:
<<qt-widget-checkbox-checked>>=
checkBox$checked
@ 
%
Sometimes, it is useful for a checkbox to have an indeterminate state
that is neither checked nor unchecked. To enable this, set the
\property{tristate}{QCheckBox} property to \qcode{TRUE}. In that case,
one needs to call the \method{checkState}{QCheckBox} method to
determine the state, as it is no longer boolean but from the
\qcode{Qt::CheckState} enumeration.

The \signal{stateChanged} signal is emitted whenever the checked state
of the button changes:
<<qt-widget-checkbox-state-changed>>=
qconnect(checkBox, "stateChanged", function(state) {
  if (state == Qt$Qt$Checked)
    message("checked")
})
@ 
%
The argument is from the \qcode{Qt::CheckState} enumeration; it is not
a logical vector.

\subsection{Groups of checkboxes}
\label{sec:groups-checkboxes}

Checkboxes and other types of buttons are often naturally grouped into
logical units. The frame widget, \class{QGroupBox}, is appropriate for
visually representing this grouping. However, \class{QGroupBox} holds
any type of widget, so it has no high-level notion of a group of
buttons. The \class{QButtonGroup} object, which is \emph{not} a
widget, fills this gap, by formalizing the grouping of buttons behind
the scenes.

To demonstrate, we will construct an interface for filtering a data
set by the levels of a factor. A common design is to have each factor
level correspond to a check button in a group. For our example, we
take the cylinders variable from the \code{Cars93} data set of the
\pkg{MASS} package.  First, we create our \class{QGroupBox} as the
container for our buttons:
<<results=hide>>=
w <- Qt$QGroupBox("Cylinders:")
lyt <- Qt$QVBoxLayout()
w$setLayout(lyt)
@ 

Next, we create the button group: 
<<results=hide>>=
bg <- Qt$QButtonGroup()
bg$exclusive <- FALSE
@ 
%
By default, the buttons are exclusive, like a radio button group. We
disable that by setting the \property{exclusive}{QButtonGroup}
property to \qcode{FALSE}.

We add a button for each level of the \qcode{Cylinders} variable to
both the button group and the layout of the group box widget:
<<results=hide>>=
data(Cars93, package="MASS")
cyls <- levels(Cars93$Cylinders)
sapply(seq_along(cyls), function(i) {
  button <- Qt$QCheckBox(sprintf("%s Cylinders", cyls[i]))
  lyt$addWidget(button)
  bg$addButton(button, i)
})
sapply(bg$buttons(), function(i) i$checked <- TRUE)
@ 
%
Every button is initially checked.

We can retrieve a list of the buttons in the group and query their
checked state:
<<results=hide>>=
checked <- sapply(bg$buttons(), function(i) i$checked)
if(any(checked)) {
  ind <- Cars93$Cylinders %in% cyls[checked]
  print(sprintf("You've selected %d cases", sum(ind)))
}
@ 
%

By attaching a callback to the \signal{buttonClicked} signal, we will
be informed when any of the buttons in the group are clicked:
<<results=hide>>=
qconnect(bg, "buttonClicked", function(button) {
  message(paste("Level '", button$text, "': ", button$checked, sep = ""))
})
@ 
<<echo=FALSE, results=hide>>=
w$show()
w$raise()
@ 

\section{Radio groups}
\label{sec:radio-groups}

Another type of checkable button is the radio button,
\class{QRadioButton}. Radio buttons always belong to a group, and only
one radio button in a group may be checked at once. Continuing our
filtering example, we create several radio buttons for choosing a
range for the \qcode{Weight} variable in the \qcode{Cars93} dataset:
<<RadioWithList,results=hide>>=
l <- list(Qt$QRadioButton("Weight < 3000", w),
          Qt$QRadioButton("3000 <= Weight < 4000", w),
          Qt$QRadioButton("4000 <= Weight", w))
@ 

The simplest way to group the radio boxes into place them into the
same layout:
<<qt-widget-radio-layout>>=
w <- Qt$QGroupBox("Weight:")
lyt <- Qt$QVBoxLayout()
w$setLayout(lyt)
sapply(l, function(i) lyt$addWidget(i))
l[[1]]$setChecked(TRUE)
@ 
%

As with any other derivative of \class{QAbstractButton}, the checked
state is stored in the \property{checked}{QAbstractButton}:
<<qt-widget-radio-checked>>=
l[[1]]$checked
@ 

The \signal{toggled} signal is emitted twice when a button is checked
or unchecked:
<<results=hide>>=
sapply(l, function(i) {
  qconnect(i, "toggled", function(checked) {
    if(checked) {
      message(sprintf("You checked %s.", i$text))
    }
  })
})
@ 

\class{QButtonGroup} is a useful utility for grouping radio buttons:
<<qt-widget-radio-group>>=
buttonGroup <- Qt$QButtonGroup()
lapply(l, buttonGroup$addButton)
@ 
%
Since our button group is exclusive, we can query for the currently
checked button:
<<qt-widget-radio-group-checked>>=
buttonGroup$checkedButton()
@ 

<<echo=FALSE,results=hide>>=
w$show()
w$raise()
@           

\section{Comboboxes}
\label{sec:comboboxes}

A combo box allows a single selection from a drop-down list of
options. In this section, we describe the basic usage of
\class{QComboBox}. This includes populating the menu with a list of
strings and optionally allowing arbitrary input through an associated
text entry. For the more complex approach of deriving the menu
from a separate data model, see Section~\ref{sec:qt-mvc-combo}.

This example shows how one combobox, listing regions in the U.S.,
updates another, which lists states in that region. First, we prepare
a \class{data.frame} with the name, region and population of each
state and split that \class{data.frame} by the regions:
<<>>=
df <- data.frame(name=state.name, region=state.region,
                 population=state.x77$population, stringsAsFactors=FALSE)
statesByRegion <- split(df, df$region)
@ 

We create our combo boxes, loading the \code{region} combobox with the
regions:
<<QComboBox, results=hide>>=
state <- Qt$QComboBox()
region <- Qt$QComboBox()
region$addItems(names(statesByRegion))
@ 
%
The \method{addItems}{QComboBox} accepts a character vector of options
and is the most convenient way to populate a combo box with a simple
list of strings. The \property{currentIndex}{QComboBox} property
indicates the index of the currently selected item:
<<qt-widget-combo-currentitem>>=
region$currentIndex
region$currentIndex <- -1
@
%
By setting it to $-1$, we make the selection to be empty.

To respond to a change in the current index, we connect to the
\signal{activated} signal:
<<>>=
qconnect(region, "activated", function(ind) {
  state$clear()
  state$addItems(statesByRegion[[ind+1]]$name)
})
@ 
%
Our handler resets the state combo box to correspond to the selected
region, indicated by \qcode{ind}.

Finally, we place the widgets in a form layout:
<<results=hide>>=
w <- Qt$QGroupBox("Two comboboxes")
lyt <- Qt$QFormLayout()
w$setLayout(lyt)
lyt$addRow("Region:", region)
lyt$addRow("State:", state)
@ 

<<eval=FALSE, echo=FALSE, results=hide>>=
w$show(); w$raise()
@ 

To allow a user to enter a value not in the menu, the property
\property{editable}{QComboBox} can be set to \code{TRUE}. This would
not be sensible for our example.

\section{Sliders and spin boxes}
\label{sec:sliders-spinboxes}

Sliders and spin boxes are similar widgets used for selecting from a
range of values. Sliders give the illusion of selecting from a
continuum, whereas spinboxes offer a discrete choice. However,
underlying each is an arithmetic sequence. Our example will include
both widgets and synchronize them for specifying a single range. The
slider allows for quick movement across the range, while the spin box
is best suited for fine adjustments.

\subsection{Sliders}
\label{sec:sliders}

Sliders are implemented by \class{QSlider}, a subclass of
\class{QAbstractSlider}. \class{QSlider} selects only from integer
values. We create an instance and specify the bounds of the range:
<<qt-widget-slider>>=
sl <- Qt$QSlider()
sl$minimum <- 0
sl$maximum <- 100
@
%
We can also customize the step size:
<<qt-widget-slider-step>>=
sl$singleStep <- 1
sl$pageStep <- 5
@ 
%
Single step refers to the effect of pressing one of the arrow keys,
while pressing \qcode{Page Up/Down} adjusts the slider by
\property{pageStep}{QAbstractSlider}. 

The current cursor position is give by the property
\property{value}{QSlider}; we set it to the middle of the range:
<<qt-widget-slider-value>>=
sl$value
sl$value <- 50
@ 

A slider has several aesthetic properties. We set our slider to be
oriented horizontally (vertical is the default), and place the tick
marks below the slider, with a mark every $10$ values:
<<qt-widget-slider-aesthetics>>=
sl$orientation <- Qt$Qt$Horizontal
sl$tickPosition <- Qt$QSlider$TicksBelow
sl$tickInterval <- 10
@

The \signal{valueChanged} signal is emitted whenever the
\property{value}{QAbstractSlider} property is modified. An example is
given below, after the introduction of the spin box.

\subsection{Spin boxes}
\label{sec:spin-boxes}

There are several spin box classes: \class{QSpinBox} (for integers),
\class{QDoubleSpinBox} and \class{QDateTimeEdit}. All of these derive
from a common base, \class{QAbstractSpinBox}. As our slider is
integer-valued, we will introduce \class{QSpinBox} here. Configuring a
\class{QSpinBox} proceeds much as it does for \class{QSlider}:
<<results=hide>>=
sp <- Qt$QSpinBox()
sp$minimum <- sl$minimum
sp$maximum <- sl$maximum
sp$singleStep <- sl$singleStep
@ 
%
There is no \qcode{pageStep} for a spin box.  Since we are
communicating a percentage, we specify "\%" as the suffix for the text
of the spin box:
<<qt-widget-spin-suffix>>=
sp$suffix <- "%"
@ 
%
It is also possible to set a prefix.

Both \class{QSlider} and \class{QSpinBox} emit the
\signal{valueChanged} signal whenever the value changes. We connect to
the signal on both widgets to keep them synchronized:
<<results=hide>>=
f <- function(value, obj) obj$value <- value
qconnect(sp, "valueChanged", f, user.data=sl)
qconnect(sl, "valueChanged", f, user.data=sp)
@
%
We pass the other widget as the user data, so that state changes in
one are forwarded to the other.

<<SliderSpinButton, echo=FALSE, results=hide>>=
w <- Qt$QWidget()
lyt <- Qt$QHBoxLayout()
w$setLayout(lyt)
@ 

<<echo=FALSE, results=hide>>=
## not shown
lyt$addWidget(sl)
lyt$addWidget(sp)

w$show()
w$raise()
@ 

\section{Single-line text}
\label{sec:single-line-text}

As seen in previous examples, a widget for entering or displaying a
single line of text is provided by the \class{QLineEdit} class:
<<qt-widget-lineedit>>=
le <- Qt$QLineEdit("Initial Contents")
@ 
%
The \property{text} property holds the current value:
<<qt-widget-lineedit-text>>=
le$text
@ 
%

We wish to select the text, so that the initial contents are
overwritten when the user begins typing:
<<qt-widget-lineedit-select>>=
le$setSelection(start = 0, length = nchar(le$text))
@ 
%
<<qt-widget-linedit-selectedText>>=
le$selectedText
@
%
If \property{dragEnabled}{QLineEdit} is \code{TRUE} the selected text
may be dragged and dropped on the appropriate targets. The
\signal{selectionChanged} signal reports selection changes.

By default, the line edit displays the typed characters. Other echo
modes are available, as specified by the
\property{echoMode}{QLineEdit} property. For example, the
\code{Qt\$QLineEdit\$Password} mode will behave as a password entry,
echoing only asterisks.

In \Qt{} versions 4.7 and above, one can specify place holder text
that fills the entry it is empty and unfocused. Typically, this text
indicates the expected contents of the entry:
<<qt-widget-lineedit-placeholder>>=
le$text <- ""
le$placeholderText <- "Enter some text"
@ 

The \signal{editingFinished} signal is emitted when the user has
committed the edit, typically by pressing the return key, and the
input has been validated:
<<qt-widget-lineedit-editingFinished>>=
qconnect(le, "editingFinished", function() {
  message("Entered text: '", le$text, "'")
})
@ 
%
To respond to any editing, without waiting for it to be committed,
connect to the \signal{textEdited} signal.

%% FIXME: belongs in the MVC chapter
%% JV: I see that, but it isn't too difficult to implement and fits in
%% right here quite naturally

\subsection{Completion}
\label{sec:completion}

Using \Qt's \class{QCompleter} framework, a list of possible words can be
presented for completion. 

\begin{example}{Using completion on the \code{Qt} object}{eg-qt-line-edit=completion}

  This example shows how completion can assist in exploring the
  classes and namespaces of the \code{Qt} library. A form layout
  arranges two line edit widgets -- one to gather a class name and one
  for method and property names.
<<CompleterExample, results=hide>>=
w <- Qt$QWidget()
lyt <- Qt$QFormLayout()
w$setLayout(lyt)

lyt$addRow("Class name", c_name <- Qt$QLineEdit())
lyt$addRow("Method name", m_name <- Qt$QLineEdit())
@ 

Next, we construct the completer for the class entry, listing the
components of the \qcode{Qt} environment with \function{ls}: 
<<results=hide>>=
c_comp <- Qt$QCompleter(ls(Qt))
c_name$setCompleter(c_comp)
@ 
%

The completion for the methods depends on the class. As such, we
update the completion when editing is finished for the class name:
<<results=hide>>=
qconnect(c_name, "editingFinished", function() {
  cl <- c_name$text
  val <- get(cl, envir=Qt)
  if(!is.null(val)) {
    m_comp <- Qt$QCompleter(ls(val()))
    m_name$setCompleter(m_comp)
  }
})
@ 


<<echo=FALSE, results=hide>>=
w$show()
w$raise()
@ 
\end{example}


\subsection{Masks and Validation}
\label{sec:masks-validation}

\class{QLineEdit} has various means to restrict and validate user
input. The \property{maxLength}{QLineEdit} property restricts the
number of allowed characters. Beyond that, there are two mechanisms
for validating input: masks and \class{QValidator}. An input mask is
convenient for restricting input to a simple pattern. We could, for
example, force the input to conform to the pattern of a U.S. Social
Security Number:
<<qt-widget-lineedit-mask>>=
le$inputMask <- "999-99-9999"
@ 
%
Please see the API documentation of \class{QLineEdit} for a full
description of the format of an input mask.

As illustrated in Example~\ref{sec:qt-introductory-example},
\class{QValidator} is a much more general validation mechanism, where
the value in the widget is checked by the validator before being
committed.

\section{Drag and drop}
\label{sec:drag-drop}


Some \Qt{} widgets, such as those for editing text, natively support
basic drag and drop activities.  For other situations, it is necessary
to program against the low-level drag and drop API, presented here.  A
drag and drop event consists of several stages: the user selects the
object that initiates the drag event, drags the object to a target,
and finally drops the object on the target. For our example, we will
enable the dragging of text from one label to another, following the
\Qt{} tutorial.

\subsection{Initiating a Drag} 
We begin by setting up a label to be a drag target:
<<DragConstructor, results=hide>>=
qsetClass("DragLabel", Qt$QLabel, function(text="", parent=NULL) {
  super(parent)
  setText(text)

  setAlignment(Qt$Qt$AlignCenter)
  setMinimumSize(200, 200)
})
@

When a drag and drop sequence is initiated, the source, i.e., the
widget receiving the mouse press event, needs to encode chosen
graphical object as mime data. This might be as an image, text or
other data type. This occurs in the
\method{mouseEventHandler}{QWidget} of the source:
<<drag-mouse-press-event>>=
qsetMethod("mousePressEvent", DragLabel, function(e) {
  md <- Qt$QMimeData()
  md$setText(text)

  drag <- Qt$QDrag(this)
  drag$setMimeData(md)

  drag$exec()
})
@  
%
We store the text in a \class{QMimeData} and pass it to the
\class{QDrag} object, which represents the drag operation. The
\qcode{drag} object is given \qcode{this} as its parent, so that
\qcode{drag} is not garbage collected when the handler
returns. Finally, calling the \method{exec}{QDrag} method is necessary
to initiate the drag. It is also possible to call
\method{setPixmap}{QDrag} to set a pixmap to represent the object as
it is being dragged to its target.


\subsection{Handling a Drop}

Implementing a label as a drop target is a bit more work, as we
customize its appearance. Our basic
constructor follows:
<<DropConstructor, results=hide>>=
qsetClass("DropLabel", Qt$QLabel, function(text="", parent=NULL) {
  super(parent)

  setText(text)
  this$acceptDrops <- TRUE

  this$bgrole <- backgroundRole()
  this$alignment <- Qt$Qt$AlignCenter
  setMinimumSize(200, 200)
  this$autoFillBackground <- TRUE
  clear()
})
@
%
The important step is to allow the widget to receive drops by setting
\property{acceptDrops}{QWidget} to \qcode{TRUE}. The other settings
ensure that the label fills a minimal amount of space and draws its
background. The background role is preserved so that we can restore it
later after applying highlighting.

First, we define a couple of utility methods:
<<qt-dnd-utility>>=
qsetMethod("clear", DropLabel, function() {
  setText(this$orig_text)
  setBackgroundRole(this$bgrole)
})
qsetMethod("setText", DropLabel, function(str) {
  this$orig_text <- str
  super("setText", str)                 # next method
})
@
The \meth{clear} method is used to restore the label to an initial
state. The background role is remembered in the constructor, and the
\meth{setText} override saves the original text. 

When the user drags an object over our target, we need to verify that
the data is of an acceptable type. This is implemented by the
\method{dragEnterEvent}{QWidget} handler:
<<results=hide>>=
qsetMethod("dragEnterEvent", DropLabel, function(e) {
  md <- e$mimeData()
  if (e$hasImage() || e$hasHtml() | e$hasText()) {
    super("setText", "<Drop Text Here>")
    setBackgroundRole(Qt$QPalette$Highlight)
    e$acceptProposedAction()
  }
})
@
% 
If the data type is acceptable, we accept the event. This changes the
mouse cursor, indicating that a drop is possible. A secondary role of
this handler is to indicate that the target is receptive to drops; we
highlight the background of the label and change the text. To undo the
highlighting, we override the \method{dragLeaveEvent}{QWidget} method:
<<results=hide>>=
qsetMethod("dragLeaveEvent", DropLabel, function(e) {
  clear()
})
@ 

Finally, we have the important drop event handler. The following
code implements this more generally than is needed for this
example, as we only have text in our mime data:
<<dropevent, results=hide>>=
qsetMethod("dropEvent", DropLabel, function(e) {
  md <- e$mimeData()
  
  if(md$hasImage()) {
    setPixmap(md$imageData())
  } else if(md$hasHtml()) {
    setText(md$html)
    setTextFormat(Qt$Qt$RichText)
  } else if(md$hasText()) {
    setText(md$text())
    setTextFormat(Qt$Qt$PlainText)
  } else {
    setText("No match")                 # replace...
  }

  setBackgroundRole(this$bgrole)
  e$acceptProposedAction()
})
@
%
We are passed a \class{QDropEvent} object, which contains the
\class{QMimeData} set on the \class{QDrag} by the source. The data is
extracted and translated to one or more properties of the target. The
final step is to accept the drop event, so that the DnD operation is
completed.

% moved into main text
% \begin{example}{Drag and drop}{eg:qt-dnd}
%   \SweaveInput{ex-qt-drag-and-drop}
% \end{example}

