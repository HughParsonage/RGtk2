<<echo=FALSE, results=hide>>=
## use QTreeView to make workspace browser
require(qtbase)
@ 

This example shows how to use the tree widget item to display a
snapshot of the current workspace. Each object in the workspace maps
to an item, where recursive objects with names will have their
components represented in a hierarchical manner. 

When representing objects in a workspace, we need to decide if an
object has been changed. To do this, we use the \function{digest}
function from the \pkg{digest} package to
compare a current object with a past one. To store this information,
we will use a custom \qcode{digest} role in the item model.
<<qt-mvc-tree-digest-role, results=hide>>=
library(digest)
.DIGEST_ROLE <- Qt$Qt$UserRole + 1L
@ 
%
Using a custom role in this manner is convenient but dangerous:
third-party code could attempt to store a differenet type of data
using the same role ID. It is thus important to document any reserved
roles.

The \function{addItem} function creates an item from a named component
of a parent object and adds the new item under the given parent index:
<<results=hide>>=
addItem <- function(varname, parentObj, parentItem) {
  obj <- parentObj[[varname]]
  
  item <- Qt$QStandardItem(varname)
  item$setData(digest(obj), .DIGEST_ROLE)
  classItem <- Qt$QStandardItem(paste(class(obj), collapse = ", "))
  print(class(item))
  print(class(classItem))
  
  parentItem$appendRow(list(item, classItem))
  
  nms <- NULL
  if (is.recursive(obj)) {
    if (is.environment(obj))
      nms <- ls(obj)
    else if (!is.null(names(obj)))
      nms <- names(obj)
  }
  
  sapply(nms, addItem, parentItem = item, parentObj = obj)
}
@ 

Our main function is one that checks the current workspace and updates
the values in the tree widget accordingly. This could be set on a
timer to be called periodically, or called in response to user
input. We consider three cases: items no longer in the
workspace to remove, new items to add, and finally items that may have
changed and need to be replaced.
<<updateTopLevelItems, results=hide>>=
updateTopLevelItems <- function(view, env = .GlobalEnv) {
  envNames <- ls(envir=env)

  model <- view$model()
  items <- lapply(seq_len(model$rowCount()), model$item, column = 0)
  curNames <- as.character(sapply(items, qinvoke, "text"))


  
  maybeSame <- curNames %in% envNames
  
  curDigests <- sapply(items[maybeSame], qinvoke, "data", .DIGEST_ROLE)
  envDigests <- sapply(mget(curNames[maybeSame], env), digest)
  same <- as.character(curDigests) == as.character(envDigests)

  
  view$updatesEnabled <- FALSE
  
  remove <- !maybeSame
  remove[maybeSame] <- !same
  sapply(sort(which(remove)-1L, decreasing=TRUE), model$removeRow)
  
  replaceNames <- curNames[maybeSame][!same]
  newNames <- setdiff(envNames, curNames)
  
  sapply(c(replaceNames, newNames), addItem, parentObj = env,
         parentItem = model$invisibleRootItem())
  
  model$sort(0, Qt$Qt$AscendingOrder)
  view$updatesEnabled <- TRUE
}
@
%
First, we obtain the names and digests for each top-level row. Then,
the digests are compared. Names that no longer exist in the
environment or have mismatching digests are removed. We need to sort
the indices in decreasing order so as not invalidate any
indices. The names for the changed objects are then readded, before we
add the new names. Finally, we sort the model. While the model is
being modified, we freeze the view.

Finally, we construct the model and view:
<<showTree, results=hide>>=
model <- Qt$QStandardItemModel(rows = 0, columns = 2)
model$setHorizontalHeaderLabels(c("Name", "Class"))
view <- Qt$QTreeView()
view$headerHidden <- FALSE
view$setModel(model)
@ 
%
This last call initializes the display:
<<eval=FALSE>>=
updateTopLevelItems(view)
@ 

<<echo=FALSE, results=hide>>=
view$show()
view$raise()
@ 
