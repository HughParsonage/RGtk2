This example shows how to create a custom model to edit a data
frame. Given that \class{DataFrameModel} supports editing, there is no
reason to actually use this model. The purpose is to illustrate the
steps in model implementation.  The performance is poor compared to
that of \class{DataFrameModel}, as the bulk of the operations are done
at the \R{} level. We speed things up a bit by placing column headers
into the first row of the table, instead of overriding the
\meth{headerData} method, which the \Qt{} views call far too often. 

\begin{figure}
  \centering
  \includegraphics[width=.9\textwidth]{fig-qt-user-defined-model}
  \caption{A view providing a means to edit a data frame's
    contents. The underlying model subclasses
    \class{QAbstractTableModel}, providing customizability for a lack
    of responsiveness.}
  \label{fig:qt-user-defined-model}
\end{figure}

<<echo=FALSE>>=
## Create a model for displaying a data frame -- like qdataFrameModel -- only
## with more Qt-like control over the display of columnms
## The key methods are data(), setData() and flags()
##
## For performance reasons -- which are considerable here and the main reason
## we discourage this approach -- 
## we avoid header Data and put variable names in first row!
library(qtbase)
@ 

Our basic constructor simply assigns to a \prop{dataframe} property the
data frame passed to it.
<<DfModel, results=hide>>=
qsetClass("DfModel", Qt$QAbstractTableModel, 
          function(df = data.frame(V1 = character(0)), 
                   parent = NULL) 
          {
            super(parent)
            this$df <- df
          })
@ 

Here we configure the \prop{dataframe} property, implementing a
\meth{write} method so that assigning to this property will call the
\meth{dataChanged} method to notify any views of a change:
<<results=hide>>=
qsetProperty("df", DfModel, write = function(df) {
  this$.df <- df
  dataChanged(index(0, 0), index(nrow(df), ncol(df)))
})
@ 

As mentioned, there are three virtual methods required by the interface:
\meth{rowCount}, \meth{columnCount} and \meth{data}. The first two
delegate down to \function{nrow} and \function{ncol}:
<<results=hide>>=
qsetMethod("rowCount", DfModel, 
           function(index) nrow(this$df) + 1)
qsetMethod("columnCount", DfModel, 
           function(index) ncol(this$df))
@ 

The \meth{data} method is then the main method to implement. Here we
wish to customize the data display based on the class of the variable
represented in a column, a natural use of S3 methods, which dispatch on
exactly that. Here is a method for defining the display role:
<<displayRoleMethod, results=hide>>=
displayRole <- function(x, row, ...) UseMethod("displayRole")
displayRole.default <- function(x, row) 
  sprintf("%s", x[row])
displayRole.numeric <- function(x, row) 
  sprintf("%.2f", x[row])
displayRole.integer <- function(x, row) 
  sprintf("%d", x[row])
@ 
%
We see that numeric values are formatted to have $2$ decimal
points. The data is still stored in its native form; a string is
returned only for display.  An alternative approach would be to
provide the raw data and rely on \class{RTextFormattingDelegate} to
display the numeric values according to the current R
configuration. However, the above approach generalizes basic numeric
formatting.


<<echo=FALSE, results=hide>>=
## Not shown
## text alignment to indicate to user different types of numeric values
textAlignmentRole <- function(x, row, context) UseMethod("textAlignmentRole")
textAlignmentRole.default <- function(x, row, context) Qt$Qt$AlignCenter
textAlignmentRole.integer <- function(x, row, context) Qt$Qt$AlignRight
textAlignmentRole.numeric <- function(x, row, context) Qt$Qt$AlignRight

## sets the background color
## returns a QBrush object
backgroundRole <- function(x, row, context) UseMethod("backgroundRole")
backgroundRole.default <- function(x, row, context) Qt$QBrush(Qt$QColor(0,0,0,0)) # transparent
backgroundRole.factor <- function(x, row, context) Qt$QBrush(Qt$QColor("yellow"))

##' Size hint role
##' XXX Doesn't get called
sizeHintRole <- function(x, row, context) UseMethod("sizeHintRole")
sizeHintRole.default <- function(x, row, context) {
  sz <- max(sapply(x, function(i) nchar(as.character(i))))
  avg <- Qt$QFontMetric(Qt$QFont())$averageCharWidth()
  Qt$QSize(sz*avg, sample(c(25L, 50L), 1))
}

## some text for a tooltip
toolTipRole <- function(x, row, context) UseMethod("toolTipRole")
toolTipRole.default <- function(x, row, context)
  sprintf("Value in vector with class %s", paste(class(x), collapse=","))
toolTipRole.factor <- function(x, row, context) {
  x <- levels(x)
  n <- length(x)
  p <- 6
  q <- n %/% p
  r <- n %% p
  l <- paste(paste(apply(matrix(x[1:(p*q)], byrow=T, ncol=6), 1, paste, collapse=","), collapse=",\n"),
        paste(x[(n-r+1):n], collapse=","), sep=",\n")
  sprintf("Factor with levels:\n%s", l)
}
toolTipRole.logical <- function(x, row, context) sprintf("Logical vector")

whatsThisRole <- toolTipRole
@ 

Our \meth{data} method has this basic structure (we avoid showing the
cases for all the different roles):
<<eval=FALSE>>=
qsetMethod("data", DfModel, function(index, role) {
  row <- index$row()
  col <- index$column() + 1

  if(role == Qt$Qt$DisplayRole) {
    if(row > 0)
      displayRole(df[,col], row)
    else
      names(df)[col]
  } else if(role == Qt$Qt$EditRole) {
    if(row > 0)
      as.character(df[row, col])
    else
      names(df)[col]
  } else {
    NULL
  }
})
@ 

<<data,echo=FALSE, results=hide>>=
## this is not shown in text, but is the definition of the data method
qsetMethod("data", DfModel, function(index, role) {
  row <- index$row()
  col <- index$column() + 1

  
  if(role == Qt$Qt$DisplayRole) {
    if(row > 0)
      displayRole(df[,col], row)
    else
      names(df)[col]
  } else if(role == Qt$Qt$EditRole) {
    if(row > 0)
      as.character(df[row, col])
    else
      names(df)[col]
  } else if(role == Qt$Qt$TextAlignmentRole) {
    if(row > 0)
      textAlignmentRole(df[, col], row)
    else
      Qt$Qt$AlignCenter | Qt$Qt$AlignTop
  } else if(role == Qt$Qt$BackgroundRole) {
    if(row > 0)
      backgroundRole(df[, col], row)
    else
      Qt$QBrush(Qt$QColor("gray"))
  } else if(role == Qt$Qt$ForegroundRole) {
    if(row == 0)
      Qt$QBrush(Qt$QColor("white"))
  } else if(role == Qt$Qt$ToolTipRole) {
    if(row > 0)
      toolTipRole(df[,col], row)
    else
      ""
  } else if(role == Qt$Qt$WhatsThisRole) {
    if(row > 0)
      whatsThisRole(df[,col], row)
    else
      ""
  } else if(role == Qt$Qt$SizeHintRole) {
    if(row > 0)
      sizeHintRole(df[,col], row)
    else
      NULL
  } else {
    NULL
  }
})
@ 

To allow the user to edit the values we need to override the \meth{flags}
method to return \code{ItemIsEditable} in the flag, so that any views
are aware of this ability:
<<results=hide>>=
qsetMethod("flags", DfModel, function(index) {
  if(!index$isValid()) {
    return(Qt$Qt$ItemIsEnabled)
  } else {
    current_flags <- super("flags", index)
    return(current_flags | Qt$Qt$ItemIsEditable)
  }
})
@ 


To edit cells we also need to implement a method to set the data once edited.
Since the \meth{data} method provides a string for the edit role,
\meth{setData} will be passed one, as well. We define some methods on
the S3 generic \function{fitIn}, which will coerce the string to the
original type. For example:
<<fitIn, results=hide>>=
fitIn <- function(x, value) UseMethod("fitIn")
fitIn.default <- function(x, value) value
fitIn.numeric <- function(x, value) as.numeric(value)
@ 
<<notShown, echo=FALSE, results=hide>>=
## more methods for fit in
fitIn.integer <- function(x, value) as.integer(value)
fitIn.logical <- function(x, value) {
  if(toupper(value) %in% c("T","F","TRUE","FALSE")) {
    as.logical(value)
  } else {
    as.logical(as.numeric(value))
  }
}
@ 

The \meth{setData} method is responsible for taking the value from the
delegate and assigning it into the model:
<<results=hide>>=
qsetMethod("setData", DfModel, function(index, value, role) {
  if(index$isValid() && role == Qt$Qt$EditRole) {
    df <- this$df
    row <- index$row()
    col <- index$column() + 1

    if(row > 0) {
      x <- df[, col]
      df[row, col] <- fitIn(x, value)
    } else {
      names(df)[col] <- value
    }
    this$df <- df
    dataChanged(index, index)

    return(TRUE)
  } else {
     super("setData", index, value, role)
  }
})
@ 

For a data frame editor, we may wish to extend the API for our table
of items to be \R{} specific. For example, this method allows one to replace a
column of values:
<<results=hide>>=
qsetMethod("setColumn", DfModel, function(col, value) {
  ## pad with NA if needed
  n <- nrow(this$df)
  if(length(value) < n)
    value <- c(value, rep(NA, n - length(value)))
  value <- value[1:n]
  df <- this$df
  df[,col] <- value
  this$df <- df         # only notify about this column
  dataChanged(index(0, col - 1), 
              index(rowCount() - 1, col - 1))
  return(TRUE)
})
@ 

We implement a method similar to the \meth{insertColumn} method, but
specific to our task. Since we may add a new column, we call the
"begin" and "end" methods to notify any views.
<<addColumn, results=hide>>=
qsetMethod("addColumn", DfModel, function(name, value) {
  df <- this$df
  if(name %in% names(df)) {
    return(setColumn(min(which(name == names(df))), value))
  }  
  beginInsertColumns(Qt$QModelIndex(),
                     columnCount(), columnCount())
  df[[name]] <- value
  this$df <- df
  endInsertColumns()
  return(TRUE)
})
@                

To demonstrate our model, we construct an instance and set it on a view:
<<results=hide>>=
model <- DfModel(mtcars)

view <- Qt$QTableView()
view$setModel(model)
@ 

Finally, we customize the view by defining the edit triggers and
hiding the row and column headers:
<<customizeView,results=hide>>=
trigger_flag <- Qt$QAbstractItemView$DoubleClicked | 
                Qt$QAbstractItemView$SelectedClicked |
                Qt$QAbstractItemView$EditKeyPressed
view$setEditTriggers(trigger_flag)
view$verticalHeader()$setHidden(TRUE)
view$horizontalHeader()$setHidden(TRUE)
@ 
<<echo=FALSE, results=hide>>=
#view$show()
#view$raise()
@ 
