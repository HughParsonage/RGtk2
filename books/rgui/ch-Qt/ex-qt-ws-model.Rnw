\Qt{} has the \class{QFileSystemWatcher} class for monitoring changes
to the underlying file system, here we want to create something
similar to monitor changes to the users global workspace.  With
\pkg{gWidgets} (cf.  Example~\ref{ex-gWidgets-ws-browser}), we
implemented the observer pattern to notify listeners for changes to
the workspace, with Qt, we can leverage the existing signal
framework. This example demonstrates only the watcher; implementing a
view is left to Example~\ref{eg:qt-workspace-browser}.
<<ws_model, echo=FALSE>>=
library(qtbase)
@ 
%

Our basic model subclasses \class{QObject}, not \class{QWidget}, as it
has no graphical representation -- a job left for its views:
<<results=hide>>=
qsetClass("WSWatcher", Qt$QObject, function(parent=NULL) {
  super(parent)
  updateVariables()
})
@ 

We have two main properties: a list of workspace objects and
a digest hash for each, which we use for comparison purposes. The
digest is generated by the \pkg{digest} package, which we load:
<<results=hide>>=
library(digest)
@ 
%
We store the digests in a property:
<<results=hide>>=
qsetProperty("digests", WSWatcher)
@ 
%
When a new object is added, an object is deleted, or an object is
changed, we wish to signal that occurrence to any views of the
model. For that purpose, we define a new signal below:
<<objects_changed_property, results=hide>>=
qsetSignal("objectsChanged", WSWatcher)
@ 
%
We then pass this signal name to the
\argument{notify}{qsetProperty} argument when defining the
\property{objects}{WSWatcher} property, so that assignment will emit the
signal:
<<results=hide>>=
qsetProperty("objects", WSWatcher, notify="objectsChanged")
@ 

To monitor changes, we keep track of the digest values and names of the old objects:
<<results=hide>>=
qsetProperty("old_digests", WSWatcher)
qsetProperty("old_objects", WSWatcher)
@

Our class has a few methods defined for it. We need one to call to
initiate the update of the variable list. This one simply compares the
digest of the current workspace objects with a cached list. If there
are differences, we update the objects, which in turn signals a
change.
<<update_variables, results=hide>>=
qsetMethod("updateVariables", WSWatcher, function() {
  x <- sort(ls(envir=.GlobalEnv))
  objs <- sapply(mget(x, .GlobalEnv), digest)

  if((length(objs) != length(digests)) ||
     length(digests) == 0 ||
     any(objs != digests)) {
    this$old_digests <- digests         # old
    this$old_objects <- objects
    this$digests <- objs                # update cache
    this$objects <- x                   # emits signal         
  }
  invisible()
})
@ 

For convenience to any user of ths class, we define two more methods: one to
indicate which objects were changed and one to indicate which objects
were added:
<<change_add>>=
qsetMethod("changedVariables", WSWatcher, function() {
  changed <- setdiff(old_digests, digests)
  old_objects[old_digests %in% changed]
})
##
qsetMethod("addedVariables", WSWatcher, function() {
  added <- setdiff(digests, old_digests)
  objects[digests %in% added]
})
@ 


Finally, we arrange to call the update function as needed. If the
workspace size is modest, using a \iprogram{task callback}task callback is a reasonable
strategy:
<<addTaskCallback, results=hide>>=
m <- WSWatcher()                          # an instance
addTaskCallback(function(expr, value, ok, visible) {
  m$updateVariables()
  TRUE
})
@ 
%%
Another alternative would be to use a \iprogram{timers}timer to call the
\meth{updateVariables} method periodically:
<<eval=FALSE>>=
timer <- Qt$QTimer()
timer$setSingleShot(FALSE)              # or TRUE for run once
qconnect(timer, "timeout", function() m$updateVariables())
timer$start(as.integer(3*1000))         # 3 seconds
@ 

To illustrate, we connect a handler to the \signal{objectsChanged}
signal and expect the handler to be invoked when we create a
\code{new\_object} in the workspace:
<<connectSignal, results=hide>>=
qconnect(m, "objectsChanged", function() 
         message("workspace objects were updated"))
new_object <- "The change should be announced"
@ 
\begin{Soutput}
workspace objects were updated
\end{Soutput}
