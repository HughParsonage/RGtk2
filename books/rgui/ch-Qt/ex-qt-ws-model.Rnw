In this example, we revisit creating a backend storage model for a
workspace browser (cf.  Example~\ref{ex-gWidgets-ws-browser}). With
\pkg{gWidgets}, we needed to define an Observable class for our
model. With Qt, we can leverage the existing signal framework to
notify views of changes to the model. This example demonstrates only
the model; implementing a view is left to the reader.
<<ws_model, echo=FALSE>>=
library(qtbase)
@ 
%

Our basic model subclasses \class{QObject}, not \class{QWidget}, as it
has no graphical representation -- a job left for its views:
<<>>=
qsetClass("WSModel", Qt$QObject, function(parent=NULL) {
  super(parent)
  update_variables()
})
@ 

We have two main properties: a list of workspace objects and
a digest hash for each, which we use for comparison purposes. The
digest is generated by the \pkg{digest} package, which we load:
<<>>=
library(digest)
@ 
%
We store the digest in a property:
<<>>=
qsetProperty("digest", WSModel)
@ 
%
When a new object is added, an object is deleted, or an object is
changed, we wish to signal that occurence to any views of the
model. For that purpose, we define a new signal below:
<<objects_changed_property>>=
qsetSignal("objectsChanged", WSModel)
@ 
%
We then specify this signal name to the
\argument{notify}{qsetProperty} argument when defining the
\property{objects}{WSModel} property, so that assignment will emit the
signal:
<<>>=
qsetProperty("objects", WSModel, notify="objectsChanged")
@ 

Our class has a method to update the variable list. This simply
compares the digest of the current workspace objects with a cached
list. If there are differences, we update the objects, which in turn
signals a change.
<<update_variables, results=hide>>=
qsetMethod("updateVariables", WSModel, function() {
  x <- sort(ls(envir=.GlobalEnv))
  objs <- sapply(x, function(i) 
               digest(get(i, envir=.GlobalEnv)))

  if((length(objs) != length(digest)) ||
     length(digest) == 0 ||
     any(objs != digest)) {
    this$digest <- objs       # update cache
    this$objects <- x         # emit signal         
  }
  invisible()
})
@ 

We assign a callback to notify us that objects were changed:
<<connectSignal, results=hide>>=
m <- WSModel()
qconnect(m, "objectsChanged", function() message("objects were updated"))
@ 

Finally, we arrange to call the update function as needed. If the
workspace size is modest, using a task callback is a reasonable
strategy:
<<addTaskCallback, results=hide>>=
addTaskCallback(function(expr, value, ok, visible) {
  m$update_variables()
  TRUE
})
@ 
