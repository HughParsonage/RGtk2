%% Layout managers

%% Overview
\Qt{} provides a set of classes to faciliate the layout of child
widgets of a component. These layout managers, derived from the
\class{QLayout} class, are tasked with determining the geometry of
child widgets, according to a specific layout algorithm. Layout
managers will generally update the layout whenever a parameter is
modified, a child widget is added or removed, or the size of the
parent changes. Unlike \GTK, where this management is tied to a
container object, \Qt{} decouples the layout from the widget.

This chapter will introduce the available layout managers, of which
there are three types: the box (\class{QBoxLayout}), grid
(\class{QGridLayout}) and form (\class{QFormLayout}). Widgets that
function primarily as containers, such as the frame and notebook, are
also described here.

\begin{example}{Synopsis of Layouts in \Qt{}}{eg:qt-layouts}
  \SweaveInput{ex-layout}
\end{example}

\section{Layout Basics}
\label{sec:qt-layout-basic}

\subsection{Adding and Manipulating Children}

We will demonstrate the basics of layout in \Qt\/ with a horizontal box
layout, \class{QHBoxLayout}:
<<qt-layout-basic-constructor>>=
layout <- Qt$QHBoxLayout()
@ 
%
Details specific to box layouts are presented in
Section~\ref{sec:qt-layout-box}. \class{QHBoxLayout}, like all other
layouts, is derived from the \class{QLayout} base class.

A layout is not a widget. Instead, a layout is set on a
widget, and the widget delegates the layout of its children to the
layout object:
<<qt-layout-basic-setLayout>>=
wid <- Qt$QWidget()
wid$setLayout(layout)
@ 

%% adding a widget
Child widgets are added to a container through the
\method{addWidget}{QLayout} method:
<<qt-layout-basic-add>>=
layout$addWidget(Qt$QPushButton("Push Me"))
@
%
In addition to adding child widgets, one can nest child layouts by
calling \method{addLayout}{QLayout}.

%% referring to child items
Internally, layouts store child components as items of class
\class{QLayoutItem}. The item at a given zero-based index is returned by
\method{itemAt}{QLayout}. We get the first item in our layout:
<<qt-layout-basic-item-at>>=
item <- layout$itemAt(0)
@ 
%
The actual child widget is retrieved by calling the \meth{widget}
method on the item:
<<qt-layout-basic-widget>>=
button <- item$widget()
@ 

%% removing a child
\Qt{} provides the methods \method{removeItem}{QLayout} and
\method{removeWidget}{QLayout} to remove an item or widget from a
layout:
<<qt-layout-basic-remove>>=
layout$removeWidget(button)
@ 
%
Although the widget is no longer managed by a layout, its parent
widget is unchanged. The widget will not be destroyed (removed from
memory) as long as it has a parent. Thus, to destroy a widget, one
should set the parent of the widget \code{NULL} using
\method{setParent}{QWidget}:
<<qt-layout-basic-setParent>>=
button$setParent(NULL)
@ 

\subsection{Size and Space Negotiation}

The allocation of space to child widgets depends on several
factors.

%% http://doc.qt.nokia.com/4.6/layout.html
The \Qt{} documentation for layouts spells out the
steps:~\footnote{\url{http://doc.qt.nokia.com/4.6/layout.html}}
\begin{enumerate}
\item All the widgets will initially be allocated an amount of space
  in accordance with their sizePolicy and sizeHint.

\item If any of the widgets have stretch factors set, with a value
  greater than zero, then they are allocated space in proportion to
  their stretch factor.

\item If any of the widgets have stretch factors set to zero they will
  only get more space if no other widgets want the space. Of these,
  space is allocated to widgets with an Expanding size policy first.

\item Any widgets that are allocated less space than their minimum
  size (or minimum size hint if no minimum size is specified) are
  allocated this minimum size they require. (Widgets don't have to
  have a minimum size or minimum size hint in which case the strech
  factor is their determining factor.)

\item Any widgets that are allocated more space than their maximum
  size are allocated the maximum size space they require. (Widgets do
  not have to have a maximum size in which case the strech factor is
  their determining factor.)
\end{enumerate}


Every widget returns a size hint to the layout from the
the \method{sizeHint}{QWidget} method/property. The interpretation of
the size hint depends on the \property{sizePolicy} property. The size
policy is an object of class \class{QSizePolicy}. It contains a
separate policy value, taken from the \qtenumeration{QSizePolicy}
enumeration, for the vertical and horizontal directions. The possible
size policies are listed in Table~\ref{tab:qt:size-policies}.

<<echo=FALSE, results=tex>>=
df <- rbind(
            c("Fixed","to require the size hint exactly"),
            c("Minimum", "to treat the size hint as the minimum, allowing expansion"),
            c("Maximum", "to treat the size hint as the maximum, allowing shrinkage"),
            c("Preferred", "to request the size hint, but allow for either expansion or shrinkage"),
            c("Expanding", "to treat like \\code{Preferred}, except the widget desires  as much space as possible"),
            c("MinimumExpanding", "to treat like \\code{Minimum}, except the widget desires  as much space as possible"),
            c("Ignored", "to ignore the size hint and request as much space as possible")
           )
colnames(df) <- c("Policy","Meaning")
            cat(booktabs(df,
                         colTypes=c("l","p{0.7\\textwidth}"),
                         caption="Possible size policies"),
                label="tab:qt:size-policies")
@ 

As an example, consider \class{QPushButton}. It is the convention that
a button will only allow horizontal, but not vertical, expansion. It
also requires enough space to display its entire
label. Thus a \class{QPushButton} instance returns a size hint
depending on the label dimensions and has the policies 
\code{Fixed} and \code{Minimum} as its vertical and horizontal policies
respectively. We could prevent a button from expanding at all:
<<results=hide>>=
b <- Qt$QPushButton("No expansion")
b$setSizePolicy(vertical=Qt$QSizePolicy$Fixed, 
                horizontal=Qt$QSizePolicy$Fixed)
@   

Thus, the sizing behavior is largely inherent to the widget, rather
than any layout parameters. This is a major difference from \GTK,
where a widget can only request a minimum size and all else depends on
the parent container widget. The \Qt{} approach seems better at
encouraging consistency in the layout behavior of widgets of a
particular type.

Most widgets attempt to fill the allocated space; however, this is not
always appropriate, as in the case of labels. In such cases, the
widget will not expand and needs to be aligned within its space. By
default, the widget is centered. We can control the alignment of a
widget via the \method{setAlignment}{QLayout} method. For example, we
align the label to the left side of the layout:
<<qt-layout-basic-alignment>>=
label <- Qt$QLabel("Label")
layout$addWidget(label)
layout$setAlignment(label, Qt$Qt$AlignLeft)
@ 
% 
Alignment is also possible to the top, bottom and right. The alignment
values are flags and so many be combined to specify both vertical and
horizontal alignment.

It is also possible to specify an amount of spacing between every cell
of the layout. Here, we request $5$ pixels of space:
<<qt-layout-basic-spacing>>=
layout$spacing <- 5
@ 

\section{Box Layouts}
\label{sec:qt-layout-box}

Box layouts arrange child widgets as if they were packed into a box in
either the horizontal or vertical orientation. The \class{QHBoxLayout}
class implements a horizontal layout whereas \class{QVBoxLayout}
provides a vertical one. Both of these classes extend the
\class{QBoxLayout} class, where most of the functionality is
documented.  We create a horizontal layout:
<<qt-layout-box>>=
hb <- Qt$QHBoxLayout()
@ 
 
Child widgets are added to a box container through the
\method{addWidget}{QLayout} method:
<<qt-layout-box-add>>=
sapply(1:3, function(i) g$addWidget(Qt$QPushButton(i)))
@
% 
The \method{direction}{QBoxLayout} property specifies the direction in
which the widgets are added to the layout. By default, this is left to
right (top to bottom for a vertical box).  

The \method{addWidget}{QBoxLayout} method for a box layout takes two
optional parameters: the stretch factor and the alignment.  Stretch
factors proportionally allocate space to widgets when they expand. For
those familiar with \GTK, the difference between a stretch factor of
$0$ and $1$ is roughly equivalent to the difference between
\qcode{FALSE} and \qcode{TRUE} for the value of the
\argument{expand}{gtkBoxPackStart} parameter to
\function{gtkBoxPackStart}. However, recall that the widget size
policy and hint can alter the effect of a stretch factor. After the
child has been added, the stretch factor may be modified with
\meth{setStretchFactor}:
<<qt-layout-box-stretch>>=
g$setStretchFactor(wid, 2.0) 
@ 

<<stretch_expand, echo=FALSE, results=hide>>=
## Not shown
## Example of various combinations of stretch, alignment, sizePolicy
## no stretch, no expand
w <- Qt$QWidget(); w$setWindowTitle("No stretch, no expand")
w$setLayout(g <- Qt$QHBoxLayout())
sapply(1:3, function(i) g$addWidget(Qt$QPushButton(i)))
w$setMinimumSize(400, 50)
w$show()

## no stretch, expand for first
w <- Qt$QWidget();  w$setWindowTitle("No stretch, no expand, size Policy")
w$setLayout(g <- Qt$QHBoxLayout())
sapply(1:3, function(i) g$addWidget(Qt$QPushButton(i)))
b <- g$itemAt(0L)$widget()
b$setSizePolicy(Qt$QSizePolicy$Expanding, Qt$QSizePolicy$Fixed) 
for(i in 1:2) {
  b <- g$itemAt(i)$widget()
  b$setSizePolicy(Qt$QSizePolicy$Fixed, Qt$QSizePolicy$Fixed) 
}
w$setMinimumSize(400, 50)
w$show()                

## stretch
w <- Qt$QWidget(); w$setWindowTitle("Using stretch factors")
w$setLayout(g <- Qt$QHBoxLayout())
sapply(1:3, function(i) g$addWidget(Qt$QPushButton(i), stretch=i))
w$setMinimumSize(400, 50)
w$show()                

## no stretch; alignment
w <- Qt$QWidget(); w$setWindowTitle("Using alignment")
w$setLayout(g <- Qt$QHBoxLayout())
g$addWidget(Qt$QPushButton("NW"), stretch=0, Qt$Qt$AlignLeft | Qt$Qt$AlignTop)
g$addWidget(Qt$QPushButton("Center"), stretch=0, Qt$Qt$AlignHCenter | Qt$Qt$AlignVCenter)
g$addWidget(Qt$QPushButton("SE"), stretch=0, Qt$Qt$AlignRight | Qt$Qt$AlignBottom)
w$setMinimumSize(400, 400)
w$show()
##
@ 





<<echo=FALSE, results=hide>>=
## Not shown
## example of inserting "A" at index=1. 0 1 2 3 -> 0 A 1 2 3
w <- Qt$QWidget()
w$setWindowTitle("Insert example")
w$setLayout(g <- Qt$QHBoxLayout())
for(i in 0:2) g$addWidget(Qt$QPushButton(i))
g$insertWidget(1L, Qt$QPushButton("inserted"))
w$show()
@ 

%% spacing
\paragraph{Spacing}

There are two types of spacing between two children: fixed and
expanding. Fixed spacing between any two children was already
described. To add a fixed amount of space between two specific
children, call the \meth{addSpacing} method while populating the
container. The following line is from Example~\ref{eg:qt-layouts}:
<<qt-layout-box-spacing>>=
buttonLayout$addSpacing(12L)
@ 

An expanding, spring-like spacer between two widgets is known as a
\textit{stretch}. We add a stretch with a factor of $2.0$ and
subsequently add a child button that will be pressed against the right
side of the box:
<<qt-layout-box-stretch>>=
g$addStretch(2)
g$addWidget(Qt$QPushButton("Help..."))
@ 
%
This is just a convenience for adding an invisible widget with some
stretch factor.

\paragraph{Struts}

It is sometimes desirable to restrict the size of a layout in the
perpendicular direction. For a horizontal box, this is the height. The
box layout provides the \textit{strut} for this purpose:
<<qt-layout-box-strut>>=
g$addStrut(10)
@ 
%
We have limited the height of the box to $10$ pixels.

\section{Grid Layouts}
\label{sec:grid-layouts}

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-qt-layout-example}
  \caption{A mocked up layout using the \class{QGridLayout} class.}
  \label{fig:qt-layout-example}
\end{figure}


The \class{QGridLayout} class provides a grid layout for aligning its
child widgets into rows and columns.  To illustrate grid layouts we
mock up a GUI centered around a text area widget
(FIgure~\ref{fig:qt-layout-example}). To begin, we create the window
with the grid layout:
<<results=hide>>=
w <- Qt$QWidget()
w$setWindowTitle("Layout example")
lyt <- Qt$QGridLayout()
w$setLayout(lyt)
@ 

When we add a child to the grid layout, we need to specify the
zero-based row and column indices:
<<results=hide>>=
lyt$addWidget(Qt$QLabel("Entry:"), 0, 0)
lyt$addWidget(Qt$QLineEdit(), 0, 1, rowspan=1, colspan=2)
@ 
%
In the second call to \meth{addWidget}, we pass values to the optional
arguments for the row and column span. These are the numbers of rows
and columns, respectively, that are spanned by the child. For our
second row, we add a labeled combo box:
<<results=hide>>=
lyt$addWidget(Qt$QLabel("Choice:"), 1, 0)
lyt$addWidget(Qt$QComboBox(), 1, 1)
@ 

The bottom three cells in the third column are managed
by a sublayout, in this case a vertical box layout. We use a label as
a stub and set a frame style to have it stand out:
<<results=hide>>=
lyt$addLayout(slyt <- Qt$QVBoxLayout(), 1, 2, rowspan=3, 1)
slyt$addWidget(l <- Qt$QLabel("Category\nSelector"))
l$setFrameStyle(Qt$QFrame$Box)
@ 

The text edit widget is added to the third row, second column:
<<results=hide>>=
lyt$addWidget(Qt$QLabel("Text:"), 2, 0, Qt$Qt$AlignTop)
lyt$addWidget(l <- Qt$QTextEdit(), 2, 1)
@ 
% 
Since this widget will expand, we align the label to the top of its
cell. Otherwise, it will be centered in the vertical direction.

Finally we add a space for information on the fourth row:
<<results=hide>>=
lyt$addWidget(l <- Qt$QLabel("More info:"), 3, 0, 
              rowspan=1, colspan=2)
l$setSizePolicy(Qt$QSizePolicy$Fixed, Qt$QSizePolicy$Preferred)
l$setFrameStyle(Qt$QFrame$Box)
@ 
% 
Again we draw a frame around the label. By default the box would
expand to fill the space of the two columns, but we prevent this
through a \qcode{Fixed} size policy.

%% sizing, spacing
There are a number of parameters controlling the sizing and spacing of
the rows and columns. The concepts apply equivalently to both rows and
columns, so we will limit our discussion to columns, without loss of
generality.  A minimum width is set through
\method{setColumnMinimumWidth}{QGridLayout}. The actual minimum width
will be increased, if necessary, to satisfy the minimal width
requirements of the widgets in the column. If more space is available
to a column than requested, the extra space is apportioned according
to the \code{stretch} factors. A column stretch factor is set by
calling the \method{setColumnStretch}{QGridLayout} method.

Since there are no stretch factors set in our example, the space
allocated to each row and column would be identical when resized. To
allocate extra space to the text area, we set a positive stretch
factor for the third row and second column:
<<results=hide>>=
lyt$setRowStretch(2, 1)
lyt$setColumnStretch(1,1)
@ 
% 
As it is the only item with a positive stretch factor, it will be the
only widget to expand when the parent widget is resized.

%% spacing
The spacing between widgets can be set in both directions via the
\property{spacing}{QLayout} property, or set for a particular
direction with \method{setHorizontalSpacing}{QGridLayout} or
\method{setVerticalSpacing}{QGridLayout}. The default values are
derived from the style.

%% indexing
The method \method{itemAtPosition}{QGridLayout} returns the
\class{QLayoutItem} instance corresponding to the specified row and
column:
<<qt-layout-grid-at>>=
lineEdit <- lyt$itemAtPosition(0, 1)$widget()
@
%
The item method \method{widget}{QLayoutItem} returns the corresponding
widget. Removing a widget is similar to a box layout, using
\method{removeItem}{QLayout} or \method{removeWidget}{QLayout}.  The
methods \method{rowCount}{QGridLayout} and
\method{columnCount}{QGridLayout} return the dimensions of the grid.

%% ML: merged into main text
% \begin{example}{Using a grid layout}{eg-qt-gridlayout}
%   \SweaveInput{ex-qt-grid-layout-form}
% \end{example}

%% Moved this example into tcltk chapter
% \begin{example}{Using the grid layout and a stacked widget to display
%     a calendar}{eg-qt-calendar}
%   \SweaveInput{ex-qt-grid-layout}
% \end{example}

\section{Form layouts}
\label{sec:form-layouts}

Forms can easily be arranged with the grid layout, but \Qt{} provides
an even more convenient form layout (\class{QFormLayout}) that has the
added benefit of conforming to platform-specific conventions. A form
consists of a number of rows, where each row has a label and
an input widget. We create a form and add some rows for gathering
parameters to the \function{dnorm} function:
<<FormLayoutExample, results=hide>>=
w <- Qt$QWidget()
w$setWindowTitle("Wrapper for 'dnorm' function")
w$setLayout(flyt <- Qt$QFormLayout())

flyt$addRow("quantile", Qt$QLineEdit())
flyt$addRow("mean", Qt$QLineEdit())
flyt$addRow("sd", Qt$QLineEdit())
flyt$addRow(Qt$QCheckButton("log"))
@
%
<<echo=FALSE>>=
w$show(); w$raise()
@ 
%
The first three calls to \function{addRow} take a string for the label
and a text entry for entering a numeric value. Any widget could serve
as the label. A field may be any widget or layout. The final call to
\function{addRow} places only a single widget in the row.  As with
other layouts, we could call \method{setSpacing}{QFormLayout}
to adjust the spacing between rows.

To retrieve a widget from the layout, call the
\method{itemAt}{QFormLayout} method, passing the zero-based row index
and the role of the desired widget. Here, we obtain the edit box for
the quantile parameter:
<<qt-layout-form-at>>=
quantileEdit <- flyt$itemAt(0, Qt$QFormLayout$FieldRole)
@ 

%%%%%%%%%%%%%%%%%%%%%%% FOR WIDGET CHAPTER %%%%%%%%%%%%%%%%%%%%%%%%

\section{Frames}
\label{sec:framed-layouts}

The frame widget, \class{QGroupBox}, groups conceptually related
widgets by drawing a border around them and displaying a title
reflecting the common theme. \class{QGroupBox} is often used to group
radio buttons, see Section~\ref{sec:radio-groups} for an example.  The
title, stored in the \property{title} property, may be aligned to
left, right or center, depending on the \property{alignment} property,
see Figure~\ref{fig:group-box-example}. If the \property{checkable}
property is \qcode{TRUE}, the frame contents can be enabled or
disabled by clicking a check button.

%% TODO: make this a figure
<<groupBoxExample, echo=FALSE, results=hide>>=
## Not shown, Group box example of title, alignment, flat, checkable
f <- Qt$QGroupBox("Example group box")
lyt <- Qt$QVBoxLayout(); f$setLayout(lyt)
lyt$addWidget(changeTitle <- Qt$QPushButton("Change title"))
lyt$addWidget(changeAlignment <- Qt$QPushButton("Change Alignment"))
lyt$addWidget(toggleFlat <- Qt$QPushButton("Toggle flat"))
lyt$addWidget(toggleCheckable <- Qt$QPushButton("Toggle checkable"))
f$show()

qconnect(changeTitle, "clicked", function(checked) {
  f$setTitle("New title")
})
qconnect(changeAlignment, "clicked", function(checked) {
  aligns <- c(Qt$Qt$AlignLeft, Qt$Qt$AlignHCenter, Qt$Qt$AlignRight)
  curAlign <- f$alignment
  ind <-   which(curAlign == aligns)
  f$setAlignment(aligns[c(2,3,1)[ind]])
})
qconnect(toggleFlat, "clicked", function(checked) {
  f$setFlat(!f$flat)
})
qconnect(toggleCheckable, "clicked", function(checked) {
  f$setCheckable(!f$checkable)
})
@ 

\section{Separators}
\label{sec:qt-widget-separator}

Like frames, a horizontal or vertical line is also useful for visually
separating widgets into conceptual groups. There is no explicit line
or separator widget in \Qt. Rather, one configures the more general
widget \class{QFrame}, which draws a frame around its
children. Somewhat against intuition, a frame can take the shape of a
line:
<<qt-widget-separator>>=
separator <- Qt$QFrame()
separator$frameShape <- Qt$QFrame$HLine
@ 
% 
This yields a horizontal separator. A frame shape of
\qcode{Qt\$QFrame\$VLine} would produce a vertical separator.

\section{Notebooks}
\label{sec:notebooks}

A notebook container is provided by the widget \class{QTabWidget}:
<<qt-layout-notebook>>=
nb <- Qt$QTabWidget()
@

To create a page, one needs to specify the label for the tab and the
widget to display when the page is active:
<<qt-layout-notebook-addtab>>=
nb$addTab(Qt$QPushButton("page 1"), "page 1")
icon <- Qt$QIcon("small-R-logo.jpg")
nb$addTab(Qt$QPushButton("page 2"), icon,  "page 2")
@ 
%
As shown in the second call to \method{addTab}{QTabWidget}, one can
provide an icon to display next to the tab label. We can also add a
tooltip for a specific tab, using zero-based indexing:
<<qt-layout-notebook-tooltip>>=
nb$setTabToolTip(0, "This is the first page")
@ 

The \property{currentIndex} property holds the zero-based index of the
active tab. We make the second tab active:
<<qt-layout-notebook-current>>=
nb$currentIndex <- 1
@ 

The tabs can be positioned on any of the four sides of the notebook;
this depends on the \property{tabPosition} property. By default, the
tabs are on top, or \qcode{North}. We move them to the bottom:
<<qt-layout-notebook-pos>>=
nb$tabPosition <- Qt$QTabWidget$South
@ 

Other features include close buttons, movable pages by drag and drop,
and scroll buttons for when the number of tabs exceeds the available
space. We enable all of these:
<<qt-layout-notebook-features>>=
nb$tabsClosable <- TRUE
qconnect(nb, "tabCloseRequested", function(index) {
  nb$removeTab(index)
})
nb$movable <- TRUE
nb$usesScrollButtons <- TRUE
@ 
%
We need to connect to the \signal{tabCloseRequested} signal to
actually close the tab when the close button is clicked.

\paragraph{General Widget Stacking}

It is sometimes useful to have a widget that only shows one of its
widgets at once, like a \class{QTabWidget}, except without the
tabs. There is no way to hide the tabs of \class{QTabWidget}. Instead,
one should use \class{QStackedWidget}, which stacks its children so
that only the widget on top of the stack is visible. There is no way
for the user to switch between children; it must be done
programmatically. The actual layout is managed by
\class{QStackedLayout}, which should be used directly if only a layout
is needed, e.g., as a sub-layout.

\section{Scroll Areas}
\label{sec:scrolling-layouts}

It may be desirable to constrain the size of a layout and allow the
user to pan through its children with scrollbars. \class{QScrollArea}
provides this functionality. It is only necessary to place the
container widget into scroll area. First, we create a large layout:
<<results=hide>>=
w <- Qt$QWidget()
w$setMinimumSize(400,400)
lyt <- Qt$QVBoxLayout()
w$setLayout(lyt)
for(i in rownames(state.x77)) {
  msg <- sprintf("%s had a population of %s thousand in 1977", 
  i, state.x77[i,"Population"])
  lyt$addWidget(Qt$QLabel(msg))
}
@ 
%
The final step is to create the scroll area and add \qcode{w}:
<<results=hide>>=
sa <- Qt$QScrollArea()
sa$setWidget(w)
@ 
<<echo=FALSE, results=hide>>=
sa$show()
sa$raise()
@
% 
To ensure that a given child widget is visible, we call the method
\method{ensureWidgetVisible}{QScrollArea}.  To ensure the value for New
York (row $32$ in the data set) is visible, we have:
<<results=hide>>=
widget <- lyt$itemAt(32 - 1)$widget()
sa$ensureWidgetVisible(widget)
@ 

We concede that the above could be achieved more elegantly with a list
box, which has native scrolling support. It is meant only to
demonstrate the general use of \class{QScrollArea}.

\section{Paned Windows}
\label{sec:paned-windows}

\class{QSplitter} is a split pane widget, a container that splits its
space between its children, with draggable separators that adjust the
balance of the space allocation.

Unlike \class{GtkPaned} in \GTK{}, there is no limit on the number of
child panes. We add three and change the orientation from horizontal
to vertical: 
<<splitter, results=hide>>=
sp <- Qt$QSplitter()
sp$addWidget(Qt$QLabel("One"))
sp$addWidget(Qt$QLabel("Two"))
sp$addWidget(Qt$QLabel("Three"))
sp$setOrientation(Qt$Qt$Vertical)
@ 
%
We can adjust the sizes programmatically:
<<qt-layout-splitter-set>>=
sp$setSizes(c(100L, 200L, 300L))
@ 

% MFL: it's a protected method, only seen by subclasses
%% \XXX{JV: This seems to be true!}
% The \method{moveSplitter}{QSplitter} method is not implemented, so
% programattically moving the a splitter handle is not possible.

<<echo=FALSE, results=hide>>=
sp$show()
sp$raise()
@ 
