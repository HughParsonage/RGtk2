<<echo=FALSE, results=hide>>=
library(qtbase)
#rm(list=ls())                           # clear out
@ 

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{fig-qt-table-dnd}
  \caption{A table widget to display contingency tables and a means to
    specify the variables through drag and drop.}
  \label{fig:eg:qt-table-widget-dnd}
\end{figure}

This example uses a table view to display the output from
\function{xtabs}. To specify the variables, the user drags variable
names from a list to one of two labels, representing terms in the formula.

\paragraph{A \class{VariableSelector} class}
First, we define the \class{VariableSelector} widget, which contains a
combo box for choosing a data frame and a list view for the variable
names. When a data frame is chosen in the combo box, its variables are
shown in the list:
<<qt-mvc-dnd-variable-selector, results=hide>>=
qsetClass("VariableSelector", Qt$QWidget, function(parent=NULL) {
  super(parent)
  ## widgets
  this$dfcb <- Qt$QComboBox()
  this$varList <- Qt$QListView()
  this$varList$setModel(qdataFrameModel(data.frame(), this))
  this$varList$dragEnabled <- TRUE

  ## layout
  lyt <- Qt$QVBoxLayout()
  lyt$addWidget(dfcb)
  lyt$addWidget(varList)
  varList$setSizePolicy(Qt$QSizePolicy$Expanding, 
                        Qt$QSizePolicy$Expanding)
  setLayout(lyt)
  
  updateDataSets()
  qconnect(dfcb, "activated(int)", function(ind) {
    this$dataFrame <- dfcb$currentText
  })
})
@ 
%

This utility populates the combo box with a list of data frames:
<<qt-mvc-dnd-update-datasets>>=
qsetMethod("updateDataSets", VariableSelector, function() {
  curVal <- dfcb$currentText
  dfcb$clear()
  dfs <- ProgGUIinR:::avail_dfs()
  if(length(dfs)) {
    this$dfcb$addItems(dfs)
    if(is.null(curVal) || !curVal %in% dfs) {
      this$dfcb$currentIndex <- -1
      this$dataFrame <- NULL
    } else {
      this$dfcb$currentIndex <- which(curVal == dfs)
      this$dataFrame <- curVal
    }
  }
})
@ 

The data frame is stored in the following call to
\function{qsetProperty}. We overwrite the underlying \meth{write}
method to also update our model for the variable list.
<<qt-mvc-dnd-dataset, results=hide, echo=FALSE>>=
## not shown, has spurious call to set attribute
qsetProperty("dataFrame", VariableSelector, 
             write = function(df) {
               if (is.null(df))
                 df <- data.frame()
               else if (is.character(df)) 
                 df <- get(df, .GlobalEnv)
               model <- varList$model()
               attr(model, "useRoles") <- FALSE      # Shouldn't need
               qdataFrame(model) <- data.frame(variable=names(df))
               this$.dataFrame <- df
               dataFrameChanged()
             })
@ 

<<eval=FALSE>>=
qsetProperty("dataFrame", VariableSelector, 
             write = function(df) {
               if (is.null(df))
                 df <- data.frame()
               else if (is.character(df)) 
                 df <- get(df, .GlobalEnv)
               ##
               model <- varList$model()
               qdataFrame(model) <- 
                 data.frame(variable=names(df))
               this$.dataFrame <- df
               dataFrameChanged()
             })
@ 
%
<<didntWork, echo=FALSE, eval=FALSE>>=
## XXXX The icon bit isn't working out for me.
## This isn't working for me right now...
## in VariableSelector
this$varList$setModel(qdataFrameModel(data.frame(), this, userRoles=TRUE))
## The \function{getIcon} helper function provides an icon from the class of a
## column:
require(grid)
getIcon <- function(x) {
  f <- tempfile()
  png(file=f, width=16, height=16)
  grid::grid.newpage()
  grid::grid.draw(ProgGUIinR::make_icon(x))
  dev.off()
  Qt$QIcon(f)
}
qdataFrame(model) <- data.frame(variable=names(df),
                                variable.decoration=I(lapply(df, getIcon)))

@ 
When the property is written the variable selector will emit this signal:
<<qt-mvc-dnd-datasetChanged, results=hide>>=
qsetSignal("dataFrameChanged", VariableSelector)
@ 

\paragraph{A \class{QLabel} subclass}
Next, a derivative of \class{QLabel} is defined that accepts drops
from the variable list and is capable of rotating text for displaying
the $y$-label component:
<<DropLabelRotation, results=hide>>=
qsetClass("VariableLabel", Qt$QLabel, function(parent=NULL) {
  super(parent)
  this$rotation <- 0L
  setAcceptDrops(TRUE)
  setAlignment(Qt$Qt$AlignHCenter | Qt$Qt$AlignVCenter)
})
@ 
%
We define two properties, one for the rotation and the other for the
variable name, which is not always the same as the label text:
<<qt-mvc-dnd-rotation, results=hide>>=
qsetProperty("rotation", VariableLabel)
qsetProperty("variableName", VariableLabel)
@ 
%
To enable client code to respond to a drop, we define a signal:
<<qt-mvc-dnd-drop, results=hide>>=
qsetSignal("variableNameDropped", VariableLabel)
@ 

This utility tries to extract a variable name from the MIME data,
which \class{DataFrameModel} should have serialized appropriately:
<<qt-mvc-dnd-get-variable-name>>=
variableNameFromMimeData <- function(md) {
  name <- NULL
  RDA_MIME_TYPE <- "application/x-rlang-transport"
  if(md$hasFormat(RDA_MIME_TYPE)) {
    list <- unserialize(md$data(RDA_MIME_TYPE))
    if (length(list) && is.character(list[[1]]))
      name <- list[[1]]
  }
  name
}
@ 

To handle the drag events we override the methods
\event{dragEnterEvent}, \event{dragLeaveEvent}, and
\event{dropEvent}. The first two simply change the background of the
label to indicate a valid drop: 
<<results=hide>>=
qsetMethod("dragEnterEvent", VariableLabel, function(e) {
  md <- e$mimeData()
  if(!is.null(variableNameFromMimeData(md))) {
    setForegroundRole(Qt$QPalette$Dark)
    e$acceptProposedAction()
  }
})
qsetMethod("dragLeaveEvent", VariableLabel, function(e) {
  setForegroundRole(Qt$QPalette$WindowText)
  e$accept()
})
@ 

To respond to a drop event, we get the variable name, set the text of the
label and emit the \signal{variableNameDropped}{VariableLabel} signal:
<<dropEvent, results=hide>>=
qsetMethod("dropEvent", VariableLabel, function(e) {
  setForegroundRole(Qt$QPalette$WindowText)  
  md <- e$mimeData()
  this$variableName <- variableNameFromMimeData(md)
  if(!is.null(variableName)) {
    this$text <- variableName
    variableNameDropped()
    setBackgroundRole(Qt$QPalette$Window)
    e$acceptProposedAction()
  }
})
@ 

To complete the \class{VariableLabel} class, we override the
\event{paintEvent} event to respect the
\prop{rotation} property. Drawing low-level graphics is
beyond our scope. In short, we translate the origin to the center
of the label rectangle, rotate the coordinate system by the angle,
then draw the text:
<<results=hide>>=
qsetMethod("paintEvent", VariableLabel, function(e) {
  p <- Qt$QPainter()
  p$begin(this)
  
  p$save()
  p$translate(width/2, height/2)
  p$rotate(-(rotation))
  rect <- p$boundingRect(0, 0, 0, 0, Qt$Qt$AlignCenter, text)
  p$drawText(rect, Qt$Qt$AlignCenter, text)
  p$restore()
  p$end()
})
@ 

\paragraph{An \class{XTabsWidget} class}
Our main widget consists of three child widgets: two drop labels for the
formula and a table widget to show the output. This could be
extended to include a third variable for three-way tables, but we leave
that exercise for the interested reader. The constructor simply calls
two methods:
<<XtabsWidget, results=hide>>=
qsetClass("XtabsWidget", Qt$QWidget, function(parent=NULL) {
  super(parent)
  initWidgets()
  initLayout()
})
@ 
%

We do not list the \method{initLayout}{XtabsWidget} method, as it
simply adds the widgets to a grid layout. The
\method{initWidgets}{XtabsWidget} method initializes three widgets:
<<initWidgets, results=hide>>=
qsetMethod("initWidgets", XtabsWidget, function() {
  this$xlabel <- VariableLabel()
  qconnect(xlabel, "variableNameDropped", invokeXtabs)

  this$ylabel <- VariableLabel()
  pt <- ylabel$font$pointSize()
  ylabel$minimumWidth <- 2*pt; ylabel$maximumWidth <- 2*pt
  ylabel$rotation <- 90L
  qconnect(ylabel, "variableNameDropped", invokeXtabs)
  
  this$tableView <- Qt$QTableView()
  tableView$setModel(qdataFrameModel(data.frame(), this))
  clearLabels()
})
@ 
%
The \code{xlabel} is straight-forward: we construct it, then connect to the
drop signal. For the \code{ylabel} we also adjust the rotation and
constrain the width based on the font size (otherwise the label width
reflects the length of the dropped text). The \meth{clearLabels}
method (not shown) just initializes the labels.

<<echo=FALSE, results=hide>>=
## Not shown
qsetMethod("clearLabels", XtabsWidget, function() {
  pt <- xlabel$font$pointSize()
  xlabel$text <- "Drop x factor here"
  xlabel$minimumHeight <- 2*pt
  
  ylabel$text <- "Drop y factor here"
  ylabel$minimumWidth <- 2*pt
})
@ 

<<echo=FALSE, results=hide>>=
## Not shown
qsetMethod("initLayout", XtabsWidget, function() {
  lyt <- Qt$QGridLayout()
  setLayout(lyt)
  lyt$addWidget(xlabel, 0, 1, 1, 3)
  lyt$addWidget(ylabel, 1, 0, 1, 1)
  lyt$addWidget(tableView, 1, 1, 1, 3)
  
  lyt$setColumnStretch(2, 1)
  lyt$setRowStretch(1, 1)
})
@ 

This function builds the formula, invokes \function{xtabs} and updates
the table view, we hide the conditional call to \function{xtabs}.
<<echo=FALSE>>=
## Hide call to xtabs
## Return NULL if not okay, otherwise a table object
call_xtabs <- function(dataFrame, xVar, yVar) {
  if(is.character(dataFrame))
    dataFrame <- get(dataFrame)
  if(is.null(xVar)) {
    out <- NULL
  } else if(is.null(yVar)) {
    f <- formula(sprintf("~ %s", xVar))
    out <- xtabs(f, data=dataFrame)
  } else { 
    f <- formula(sprintf("~ %s + %s", yVar, xVar))
    out <- xtabs(f, data=dataFrame)
  } 
  out
}
@ 
<<makeTable, results=hide>>=
qsetMethod("invokeXtabs", XtabsWidget, function() {
  if (is.null(dataFrame))
    return()
  xVar <- xlabel$variableName
  yVar <- ylabel$variableName
  
  if(!is.null(out <- call_xtabs(dataFrame, xVar, yVar)))
     updateTableView(out)
})
@ 

We define a method to update the table view:
<<updateTableWidget, results=hide, echo=FALSE>>=
## not shown, as we have spurious call to set attribute
qsetMethod("updateTableView", XtabsWidget, function(table) {
  model <- tableView$model()
  attr(model, "useRoles") <- FALSE      # shouldn't need
  if (length(dim(table)) == 1)
    qdataFrame(model) <- data.frame(count = unclass(table))
  else qdataFrame(model) <- data.frame(unclass(table))
})
@ 

<<eval=FALSE>>=
qsetMethod("updateTableView", XtabsWidget, function(table) {
  model <- tableView$model()
  if (length(dim(table)) == 1)
    qdataFrame(model) <- data.frame(count = unclass(table))
  else qdataFrame(model) <- data.frame(unclass(table))
})
@ 
%

Finally, we define a property for the data frame held in the
\class{XtabsWidget} class:
<<qt-mvc-dnd-dataframe-xtabs, results=hide>>=
qsetProperty("dataFrame", XtabsWidget, write = function(df) { 
  clearLabels()
  this$.dataFrame <- df
})
@ 

All that remains is to place the \class{VariableSelector} and
\class{XtabsWidget} together in a split pane and then connect a
handler that keeps the datasets synchronized:
<<echo=FALSE, results=hide>>=
## Not shown
require(MASS); data(Cars93); data(Aids2)
@ 
<<results=hide>>=
w <- Qt$QSplitter()
w$setWindowTitle("GUI for xtabs()")
w$addWidget(vs <- VariableSelector())
w$addWidget(tw <- XtabsWidget())
w$setStretchFactor(1, 1)
qconnect(vs, "dataFrameChanged", function() {
  tw$dataFrame <- vs$dataFrame
})
w$show()
@ 
%
Figure~\ref{fig:eg:qt-table-widget-dnd} shows the result, after the
user has dragged two variables onto the labels.
