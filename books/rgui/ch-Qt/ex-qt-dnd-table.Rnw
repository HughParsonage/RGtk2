<<echo=FALSE, results=hide>>=
library(qtbase)
#rm(list=ls())                           # clear out
@ 

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-qt-table-dnd}
  \caption{A table widget to display contingency tables and a means to
    specify the variables through drag and drop.}
  \label{fig:eg:qt-table-widget-dnd}
\end{figure}

This examples uses a table view to display the output from
\function{xtabs}. To specify the variables, the user drags variable
names from a list to one of two labels, representing terms in the formula.

First, we define the \class{VariableSelector} widget, which contains a
combo box for choosing a data frame and a list view for the variable
names. When a data frame is chosen in the combo box, its variables are
shown in the list:
<<qt-mvc-dnd-variable-selector, results=hide>>=
qsetClass("VariableSelector", Qt$QWidget, function(parent=NULL) {
  super(parent)
  ## widgets
  this$dfcb <- Qt$QComboBox()
  this$varList <- Qt$QListView()
  this$varList$setModel(qdataFrameModel(data.frame(), this))
  this$varList$dragEnabled <- TRUE

  ## layout
  lyt <- Qt$QVBoxLayout()
  lyt$addWidget(dfcb)
  lyt$addWidget(varList)
  varList$setSizePolicy(Qt$QSizePolicy$Expanding, Qt$QSizePolicy$Expanding)
  setLayout(lyt)
  
  updateDataSets()
  qconnect(dfcb, "activated(int)", function(ind) {
    this$dataFrame <- dfcb$currentText
  })
})
@ 
%

This utility populates the combo box with a list of data frames:
<<qt-mvc-dnd-update-datasets>>=
qsetMethod("updateDataSets", VariableSelector, function() {
  curVal <- this$dfcb$currentText
  this$dfcb$clear()
  dfs <- names(which(unlist(eapply(.GlobalEnv, is.data.frame))))
  if(length(dfs)) {
    this$dfcb$addItems(dfs)
    if(is.null(curVal) || !curVal %in% dfs) {
      this$dfcb$currentIndex <- -1
      this$dataFrame <- NULL
    } else {
      this$dfcb$currentIndex <- which(curVal == dfs)
      this$dataFrame <- curVal
    }
  }
})
@ 

The data frame is stored in the following property:
<<qt-mvc-dnd-dataset, results=hide>>=
qsetProperty("dataFrame", VariableSelector, write = function(df) {
  if (is.null(df))
    df <- data.frame()
  else if (is.character(df)) 
    df <- get(df, .GlobalEnv)
  model <- this$varList$model()
  qdataFrame(model) <- data.frame(variable = names(df), 
                                  variable.decoration = I(lapply(df, getIcon)))
  this$.dataFrame <- df
  dataFrameChanged()
})
@ 
%
When the property is written, the variable list is updated and it
emits this signal:
<<qt-mvc-dnd-datasetChanged, results=hide>>=
qsetSignal("dataFrameChanged", VariableSelector)
@ 
%
The \function{getIcon} generic resolves an icon from the class of a
column:
<<qt-mvc-dnd-getIcon>>=
getIcon <- function(x) UseMethod("getIcon")
getIcon.default <- function(x)
  Qt$QIcon(system.file("images/numeric.gif", package="gWidgets"))
getIcon.factor <- function(x)
  Qt$QIcon(system.file("images/factor.gif", package="gWidgets"))
getIcon.character <- function(x)
  Qt$QIcon(system.file("images/character.gif", package="gWidgets"))
@ 

Next, a derivative of \class{QLabel} is defined that accepts drops
from the variable list and is capable of rotating text for displaying
the $Y$ component:
<<DropLabelRotation, results=hide>>=
qsetClass("VariableLabel", Qt$QLabel, function(parent=NULL) {
  super(parent)
  this$rotation <- 0L
  setAcceptDrops(TRUE)
  setAlignment(Qt$Qt$AlignHCenter | Qt$Qt$AlignVCenter)
})
@ 
%
We define two properties, one for the rotation and the other for the
variable name, which is not always the same as the label text:
<<qt-mvc-dnd-rotation, results=hide>>=
qsetProperty("rotation", VariableLabel)
qsetProperty("variableName", VariableLabel)
@ 
%
To enable client code to respond to a drop, we define a signal:
<<qt-mvc-dnd-drop, results=hide>>=
qsetSignal("variableNameDropped", VariableLabel)
@ 

This utility tries to extract a variable name from the MIME data,
which \class{DataFrameModel} should have serialized appropriately:
<<qt-mvc-dnd-get-variable-name>>=
variableNameFromMimeData <- function(md) {
  name <- NULL
  RDA_MIME_TYPE <- "application/x-rlang-transport"
  if(md$hasFormat(RDA_MIME_TYPE)) {
    list <- unserialize(md$data(RDA_MIME_TYPE))
    if (length(list) && is.character(list[[1]]))
      name <- list[[1]]
  }
  name
}
@ 

To handle the drag events we override the methods
\event{dragEnterEvent}, \event{dragLeaveEvent}, and
\event{dropEvent}. The first two simply change the background of the
label to indicate a valid drop: 
<<results=hide>>=
qsetMethod("dragEnterEvent", VariableLabel, function(e) {
  md <- e$mimeData()
  if(!is.null(variableNameFromMimeData(md))) {
    setForegroundRole(Qt$QPalette$Dark)
    e$acceptProposedAction()
  }
})
qsetMethod("dragLeaveEvent", VariableLabel, function(e) {
  setForegroundRole(Qt$QPalette$WindowText)
  e$accept()
})
@ 

To handle the drop, we get the variable name, set the text of the
label and emit the \signal{variableNameDropped}{VariableLabel} signal:
<<dropEvent, results=hide>>=
qsetMethod("dropEvent", VariableLabel, function(e) {
  setForegroundRole(Qt$QPalette$WindowText)  
  md <- e$mimeData()
  if(!is.null(this$variableName <- variableNameFromMimeData(md))) {
    this$text <- variableName
    variableNameDropped()
    setBackgroundRole(Qt$QPalette$Window)
    e$acceptProposedAction()
  }
})
@ 

To complete the \class{VariableLabel} class, we override the
\event{paintEvent} event to respect the
\property{rotation}{VariableLabel} class. Drawing low-level graphics is
beyond our scope. In short we translate the origin to the center
of the label rectangle, rotate the coordinate system by the angle,
then draw the text:
<<results=hide>>=
qsetMethod("paintEvent", VariableLabel, function(e) {
  p <- Qt$QPainter()
  p$begin(this)
  w <- this$width; h <- this$height
  p$save()
  p$translate(w/2, h/2)
  p$rotate(-(this$rotation))
  rect <- p$boundingRect(0, 0, 0, 0, Qt$Qt$AlignCenter, this$text)
  p$drawText(rect, Qt$Qt$AlignCenter, this$text)
  p$restore()
  p$end()
})
@ 

Our main widget consists of three child widgets: two drop labels for the
formula and a table widget to show the output. This could be
extended to include a third variable for three-way tables, but we leave
that exercise for the interested reader. The constructor simply calls
two methods:
<<XtabsWidget, results=hide>>=
qsetClass("XtabsWidget", Qt$QWidget, function(parent=NULL) {
  super(parent)

  initWidgets()
  initLayout()
})
@ 
%

We do not list the \method{initLayout}{XtabsWidget} method, as it
simply adds the widgets to a grid layout. The
\method{initWidgets}{XtabsWidget} method initializes three widgets:
<<initWidgets, results=hide>>=
qsetMethod("initWidgets", XtabsWidget, function() {
  ## make Widgets
  this$xlabel <- VariableLabel()
  qconnect(xlabel, "variableNameDropped", invokeXtabs)

  this$ylabel <- VariableLabel()
  pt <- this$ylabel$font$pointSize()
  this$ylabel$minimumWidth <- 2*pt; this$ylabel$maximumWidth <- 2*pt
  this$ylabel$rotation <- 90L
  qconnect(ylabel, "variableNameDropped", invokeXtabs)
  
  this$tableView <- Qt$QTableView()
  this$tableView$setModel(qdataFrameModel(data.frame(), this))
  clearLabels()
})
@ 
%
The \code{xlabel} is straight-forward: we construct it connect to the
drop signal. For the \code{ylabel} we also adjust the rotation and
constrain the width based on the font size (otherwise the label width
reflects the length of the dropped text). The \meth{clearLabels}
method, not shown, just initializes the labels.

<<echo=FALSE, results=hide>>=
## Not shown
qsetMethod("clearLabels", XtabsWidget, function() {
  pt <- this$xlabel$font$pointSize()
  this$xlabel$text <- "Drop x factor here"
  this$xlabel$minimumHeight <- 2*pt
  
  this$ylabel$text <- "Drop y factor here"
  this$ylabel$minimumWidth <- 2*pt
})
@ 

<<echo=FALSE, results=hide>>=
## Not shown
qsetMethod("initLayout", XtabsWidget, function() {
  lyt <- Qt$QGridLayout()
  this$setLayout(lyt)
  lyt$addWidget(this$xlabel, 0, 1, 1, 3)
  lyt$addWidget(this$ylabel, 1, 0, 1, 1)
  lyt$addWidget(this$tableView, 1, 1, 1, 3)
  
  lyt$setColumnStretch(2, 1)
  lyt$setRowStretch(1, 1)
})
@ 

This function builds the formula, invokes \function{xtabs} and updates
the table view:
<<makeTable, results=hide>>=
qsetMethod("invokeXtabs", XtabsWidget, function() {
  if (is.null(dataFrame))
    return()
  if(is.character(dataFrame))
    dataFrame <- get(dataFrame)
  if(is.null(xVar <- this$xlabel$variableName)) {
    out <- NULL
  } else if(is.null(yVar <- this$ylabel$variableName)) {
    f <- formula(sprintf("~ %s", xVar))
    out <- xtabs(f, data=dataFrame)
  } else { 
    f <- formula(sprintf("~ %s + %s", yVar, xVar))
    out <- xtabs(f, data=dataFrame)
  } 
  if(!is.null(out))
    updateTableView(out)
})
@ 

We define a method to update the table view:
<<updateTableWidget, results=hide>>=
qsetMethod("updateTableView", XtabsWidget, function(table) {
  model <- this$tableView$model()
  if (length(dim(table)) == 1)
    qdataFrame(model) <- data.frame(count = unclass(table))
  else qdataFrame(model) <- data.frame(unclass(table))
})
@ 

Finally, we define a property for the data frame on
\class{XtabsWidget}:
<<qt-mvc-dnd-dataframe-xtabs, results=hide>>=
qsetProperty("dataFrame", XtabsWidget, write = function(df) { 
  clearLabels()
  this$.dataFrame <- df
})
@ 

All that remains is to place the \class{VariableSelector} and
\class{XtabsWidget} together in a split pane and then connect a
handler that keeps the datasets synchronized:
<<echo=FALSE, results=hide>>=
## Not shown
require(MASS); data(Cars93); data(Aids2)
@ 
<<results=hide>>=
w <- Qt$QSplitter()
w$setWindowTitle("GUI for xtabs()")
w$addWidget(vs <- VariableSelector())
w$addWidget(tw <- XtabsWidget())
w$setStretchFactor(1, 1)
qconnect(vs, "dataFrameChanged", function() {
  tw$dataFrame <- vs$dataFrame
})
w$show()
@ 
%
Figure~\ref{fig:eg:qt-table-widget-dnd} shows the result, after the
user has dragged two variables onto the labels.
