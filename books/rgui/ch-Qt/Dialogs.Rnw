%% Dialogs





\section{Dialogs}
\label{sec:built-dialogs}

\Qt{} implements the conventional high-level dialogs, including those
for printing, selecting files, selecting colors, and, most usefully,
sending simple messages and input requests to the user. We first
introduce message and input dialogs. This is followed by a discussion
of the infrastructure in \Qt{} for implementing custom
dialogs. Finally, we briefly introduce some of the remaining
high-level dialogs, such as the file selector.

\subsection{Message Dialogs}

All dialogs in \Qt{} are derived from \class{QDialog}. The message
dialog, \class{QMessageBox}, communicates a textual message to the
user. At the bottom of the dialog are a set of buttons, each
representing a possible response. Normally, the type of message is
indicated by an icon. If extra details are available, the dialog
provides the option for the user to view them.

\Qt{} provide two ways to create a message box. The simplest approach
is to call a static convenience method for issuing common types of
messages, including warnings and simple questions. The alternative,
described later, involves several steps and offers more control at a
cost of convenience. Here we take the simple path for presenting a
warning dialog:
<<qt-dialogs-static-warning, eval=FALSE>>=
response <- Qt$QMessageBox$warning(parent = NULL, title = "Warning!", 
                                   text = "Warning message...")
@
%
This blocks the flow of the program until the user responds and
returns the standard identifier for the button that was clicked. Each
type of button corresponds to a fixed type of response. The standard
button/response codes are listed in the
\qtenumeration{QMessageBox::StandardButton} enumeration. In this case,
there is only a single button, \qcode{QMessageBox\$Ok}.  The dialog is
\textit{modal}, meaning that the user cannot interact with the
\qcode{parent} window until responding. If the \qcode{parent} is
\qcode{NULL}, as in this case, input to all windows is blocked.  The
dialog is automatically positioned near its parent, and if the parent
is destroyed, the dialog is destroyed, as well. Additional arguments
specify the available buttons/responses and the default response. We
have relied on the default values for these.

For more control over the appearance and behavior of the dialog, we
will take a more gradual path. First, we construct an instance of
\class{QMessageBox}. It is possible to specify several properties at
construction. Here is how one might construct a warning dialog:
<<qt-dialogs-construct>>=
dlg <- Qt$QMessageBox(icon = Qt$QMessageBox$Warning,
                      title = "Warning!",
                      text = "Warning text...",
                      buttons = Qt$QMessageBox$Ok,
                      parent = NULL)
@ 
%
This call introduces the \prop{icon} property, which is a code
from the \qtenumeration{QMessageBox::Icon} enumeration and identifies
a standard, themeable icon. The icon also implies the message type,
just as a button implies a response type. We also need to specify
the possible responses with the \qcode{buttons} argument.

Our dialog is already sufficiently complete to be displayed. However,
we have the opportunity to specify further properties. Two of the most
useful are \property{informativeText}{QMessageBox} and
\property{detailedText}{QMessageBox}:
<<qt-dialogs-extra-text>>=
dlg$informativeText <- "Less important warning information"
dlg$detailedText <- "Extra details most do not care to see"
@ 
%
Both provide additional textual information
at an increasing level of detail. The \prop{informativeText}{QMessageBox} will
be rendered as secondary to the actual message text. To display the
\prop{detailedText}, the user will need to interact with a control
in the dialog. An example is a stack trace for the warning.

After specifying the desired properties, the dialog is shown. The
approach to showing the dialog depends on whether the dialog should be
modal. A modal dialog is displayed with the \method{exec}{QDialog}
method. 
<<qt-dialogs-exec>>=
dlg$exec()
@ 
As its name implies, \method{exec}{QDialog} executes a loop
that will block until the user responds. As with the static
convenience methods, the return value indicates the
button/response. 

To present a non-modal dialog, we first need to register a response
listener, as the response will arrive asynchronously. Then we show,
raise and activate the dialog:
<<qt-dialogs-show, results=hide>>=
qconnect(dlg, "finished", function(response) {
  ## handle response
  ## dlg$close() necessary?
})
dlg$show()
dlg$raise()
dlg$activateWindow()
@ 
%
There are several signals that indicate user response, including
\qcode{finished}, \qcode{accepted}, and \qcode{rejected}. The most
general is \qcode{finished}, which passes the button/response code as
its only argument.

Modal dialogs may be window modal (\code{Qt\$Qt\$WindowModal}), where
the dialog blocks all access to its ancestor windows, or application
modal (\code{Qt\$Qt\$ApplicationModal}) (the default) where all
windows are blocked. To specify the type of modality, call
\method{setWindowModality}{QMessageBox}.

To summarize, we present a general message box, supporting multiple responses:
<<QMEssageBoxAPI, results=hide>>=
dlg <- Qt$QMessageBox()
dlg$windowTitle <- "[This space for rent]"
dlg$text <- "This is the main text"
dlg$informativeText <- "This should give extra info"
dlg$detailedText <- "And this provides\neven more detail"

dlg$icon <- Qt$QMessageBox$Critical
dlg$standardButtons <- Qt$QMessageBox$Cancel | Qt$QMessageBox$Ok

## 'Cancel' instead of 'Ok' is the default
dlg$setDefaultButton(Qt$QMessageBox$Cancel)

if(dlg$exec() == Qt$QMessageBox$Ok) 
  print("A Ok")
@ 

\subsection{Input dialogs}
\label{sec:input-dialogs}

The \class{QInputDialog} class provides a convenient means to gather
information from the user and is in a sense the inverse of
\class{QMessageBox}. Possible input modes include selecting a value
from a list or entering text or numbers.  By default, input dialogs
consist of an input control, an icon, and two buttons: ``Ok'' and
``Cancel''.

Like \class{QMessageBox}, one can display a \class{QInputDialog}
either by calling a static convenience method or by constructing an
instance and configuring it before showing it. We demonstrate the
former approach for a dialog that requests textual input:
<<qt-dialogs-input-get-text>>=
text <- Qt$QInputDialog$getText(parent = NULL, 
                        title = "Gather text",
                        label = "Enter some text")
@
%
The return value is the entered string, or \qcode{NULL} if the user
cancelled the dialog. Additional parameters allow one to specify the
initial text and to override the input mode, e.g., for password-style
input.

We can also display a dialog for integer input. Here, we ask the user
for an even integer between 1 and 10:
<<qt-dialogs-input-get-range>>=
num <- Qt$QInputDialog$getInt(parent = NULL, title = "Gather integer",
                      label = "Enter an integer from 1 to 10",
                      value = 0, min = 2, max = 10, step = 2)
@ 
%
The number is chosen using a bounded spin box.  To request a real
value, call \function{Qt\$QInputDialog\$getDouble} instead.

The final type of input is selecting an option from a list of
choices:
<<qt-dialogs-input-get-item>>=
item <- Qt$QInputDialog$getItem(parent = NULL, title = "Select item",
                       label = "Select a letter",
                       items = LETTERS, current = 17)
@ 
%
The dialog contains a combo box filled with the capital letters. The
initial choice is $0$-based index 17, or the letter ``R''. The chosen
string is returned.

\class{QInputDialog} has a number of options that cannot be specified
via one of the static convenience methods. These option flags are
listed in the \qtenumeration{QInputDialog\$InputDialogOption}
enumeration and include hiding the ``Ok'' and ``Cancel'' buttons and
selecting an item with a list widget instead of a combo box. If such
control is necessary, we must explicitly construct a dialog instance,
configure it, execute it and retrieve the selected item.
<<qt-dialogs-input-explicit, results=hide>>=
dlg <- Qt$QInputDialog()
dlg$setWindowTitle("Select item")
dlg$setLabelText("Select a letter")
dlg$setComboBoxItems(LETTERS)
dlg$setOptions(Qt$QInputDialog$UseListViewForComboBoxItems)
@ 
<<>>=
if (dlg$exec())
  print(dlg$textValue())
@ 

\subsection{File and Directory Choosing Dialogs}
\label{sec:file-direct-choosing}


\class{QFileDialog} allows the user to select files and directories,
by default using the platform native file dialog.  As with other
dialogs there are static methods to create dialogs with standard
options.  These are \qcode{getOpenFileName}, \qcode{getOpenFileNames},
\qcode{getExistingDirectory}, and \qcode{getSaveFileName}.  To select
a file name to open we would have:
<<QFIleDialog, eval=FALSE>>=
fname <- Qt$QFileDialog$getOpenFileName(NULL, "Open a file...", getwd())
@ 
%
All take as intial arguments a parent, a caption and a
directory. Other arguments allow one to set a filter, say. For basic
use, these are nearly as easy to use as \R's \function{file.choose}.
If a file is selected, \code{fname} will contain the full path to the
file, otherwise it will be \code{NULL}.

To allow multiple selection, call the plural form of the method:
<<eval=FALSE>>=
fnames <- Qt$QFileDialog$getOpenFileNames(NULL, "Open file(s)...", getwd())
@ 

To select a file name for saving, we have
<<eval=FALSE>>=
fname <- Qt$QFileDialog$getSaveFileName(NULL, "Save as...", getwd())
@ 

And to choose a directory, 
<<eval=FALSE>>=
dname <- Qt$QFileDialog$getExistingDirectory(NULL, "Select directory", getwd())
@ 

To specify a filter by file extension, we use a name filter. A name
filter is of the form \code{Description (*.ext *.ext2)} (no comma) where this
would match files with extensions \code{ext} or \code{ext2}. Multiple
filters can be used by separating them with two semicolons. For
example, this would be a natural filter for \R{} users:
<<>>=
rfilter <- paste("R files (*.R .RData)",
                "Sweave files (*.Rnw)",
                "All files (*.*)", sep=";;")
fnames <- Qt$QFileDialog$getOpenFileNames(NULL, 
                        "Open file(s)...", getwd(), 
                        rfilter)
@ 

Although the static functions provide most of the functionality, to
fully configure a dialog, it may be necessary to explicitly construct
and manipulate a dialog instance. Examples of options not available
from the static methods are history (previously selected file names),
sidebar shortcut URLs, and filters based on low-level file attributes
like permissions.

\begin{example}{File dialogs}{ex:qt-r-files-dialog}
We construct a dialog for opening an R-related file, using the file
names selected above as the history:
<<QFileDialogAPI, results=hide>>=
dlg <- Qt$QFileDialog(NULL, "Choose an R file", getwd(), rfilter)
dlg$fileMode <- Qt$QFileDialog$ExistingFiles
dlg$setHistory(fnames)
@
%
The dialog is executed like any other. To get the specified files,
call \method{selectedFiles}{QFileDialog}:
<<eval=FALSE>>=
if(dlg$exec())
  print(dlg$selectedFiles())
@ 

\end{example}

\subsection{Other Choosers}
\label{sec:choosers}

\Qt/ provides several additional dialog types for choosing a
particular type of item. These include \class{QColorDialog} for
picking a color, and \class{QFontDialog} for selecting a font. These
special case dialogs will not be discussed further here.

%% MOVEME: to dialog part
\subsection{Button boxes}
\label{sec:button-boxes}

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-qt-dialog-button-box-Qt}\\
  \includegraphics[width=.6\textwidth]{fig-qt-dialog-button-box-linux}
  \caption{Dialog button boxes and their implementation under Mac OS X
    and Linux.}
  \label{fig:qt-dialg-button-box}
\end{figure}

Before discussing custom dialogs, we first introduce the
\class{QDialogButtonBox} utility for arranging dialog buttons in a
consistent and cross-platform manner. Dialogs often have a standard
button placement that varies among desktop
environments. \class{QDialogButtonBox} is a container of buttons that
arranges its children according to the convention of the platform.  We
place some standard buttons into a button box:
<<qt-widgets-buttonbox>>=
db <- Qt$QDialogButtonBox(Qt$QDialogButtonBox$Ok | 
                          Qt$QDialogButtonBox$Cancel | 
                          Qt$QDialogButtonBox$Help)
@ 
% 
%% EXAMPLE: create a button box, add some buttons
Figure~\ref{fig:qt-dialg-button-box} shows how the buttons are
displayed on two different operating systems.  To indicate the desired
buttons, we pass a combination of flags from the
\qtenumeration{QDialogButtonBox\$StandardButton} enumeration.  Each
standard button code implies a default label and role, taken from the
\qtenumeration{QDialogButtonBox\$ButtonRole} enumeration. In the above
example, we added a standard \code{OK} button, with the label ``OK''
(depending on the language) and the role \code{AcceptRole}. The
\code{Cancel} button has the appropriate label and \code{CancelRole}
as its role. Icons are also displayed, depending on the platform and
theme. The benefits of using standard buttons include convenience,
standardization, and automatic translation of labels.

The first button added with the \code{AcceptRole} role is made the
default. Overriding this requires adding the default button with
\method{addButton}{QDialogButtonBox} and setting the
\property{default} property on the returned button object.

To respond to user input, one can connect directly to the
\signal{clicked} signal on a given button. It is often more
convenient, however, to connect to one of the high-level button box
signals, which include: \signal{accepted}, which is emitted when a
button with the \code{AcceptRole} or \code{YesRole} is clicked;
\signal{rejected}, which is emitted when a button with the
\code{RejectRole} or \code{NoRole} is clicked; \code{helpRequested};
or \code{clicked} when any button is clicked. For this last signal,
the callback is passed the button object.
<<qt-widgets-buttonbox-signals>>=
qconnect(db, "accepted", function() print("accepted"))
qconnect(db, "rejected", function() print("rejected"))
qconnect(db, "helpRequested", function() print("help"))
@ 

<<echo=FALSE, results=hide>>=
db$show(); db$raise()
@ 

\subsection{Custom Dialogs}
\label{sec:qdialog}

Every dialog in \Qt{} inherits from \class{QDialog}, and we can
leverage it for our own custom dialogs. One approach is to construct
an instance of \class{QDialog} and add arbitrary widgets to its
layout. However, we suggest an alternative approach: extend
\class{QDialog} or one of its derivates and implement the custom
functionality in a subclass. This more formally encapsulates the state
and behavior of the custom dialog. We demonstrate the subclass
approach by constructing a dialog that requests a date from the
user. 

We begin by defining our class and its constructor:
<<extend-date-dialog>>=
qsetClass("DateDialog", Qt$QDialog, 
function(parent = NULL) {
  super(parent=parent)
  setWindowTitle("Choose a date")
  this$calendar <- Qt$QCalendarWidget()
  buttonBox <- Qt$QDialogButtonBox(Qt$QMessageBox$Cancel | Qt$QMessageBox$Ok)
  layout <- Qt$QVBoxLayout()
  layout$addWidget(calendar)
  layout$addWidget(buttonBox)
  setLayout(layout)
})
@ 
%
Our dialog consists of a calendar, implemented by the
\class{QCalendarWidget}, and a set of response buttons, organized by a
\class{QDialogButtonBox}. The calendar is stored as a dynamic field on
the instance, so that we can retrieve the selected date upon request.

We define a method that gets the currently selected date:
<<extend-date-get>>=
qsetMethod("selectedDate", DateDialog, function(x) calendar$selectedDate)
@ 

\class{DateDialog} can be executed like any other \class{QDialog}:
<<extend-date-exec>>=
dateDialog <- DateDialog()
if (dateDialog$exec())
  message(dateDialog$selectedDate())
@

\subsection{Wizards}
\label{sec:wizards}

%% \XXX{Wizards do not have a registerField method defined.}
%% MFL: They do, but it's protected (i.e., you have to subclass)

\class{QWizard} implements a wizard -- a multipage dialog that guides
the user through a sequential, possibly branching process. Wizards are
composed of pages, and each page has a consistent interface, usually
including buttons for moving backwards and forwards through the
pages. 

<<>>=
wizard <- Qt$QWizard()
wizard$setWindowTitle("A wizard")

getAgePage <- Qt$QWizardPage(wizard)
getAgePage$setTitle("What is your age?")
lyt <- Qt$QFormLayout()
getAgePage$setLayout(lyt)
lyt$addRow("Age", (age <- Qt$QLineEdit()))
wizard$addPage(getAgePage)

getToysPage <- Qt$QWizardPage(wizard)
getToysPage$setTitle("What toys do you like?")
lyt <- Qt$QFormLayout()
getToysPage$setLayout(lyt)
lyt$addRow("Toys", (toys <- Qt$QLineEdit()))
wizard$addPage(getToysPage)

getGamesPage <- Qt$QWizardPage(wizard)
getGamesPage$setTitle("What games do you like?")
lyt <- Qt$QFormLayout()
getGamesPage$setLayout(lyt)
lyt$addRow("Games", (games <- Qt$QLineEdit()))
wizard$addPage(getGamesPage)

ret <- wizard$exec()
@ 


% \subsection{Progress dialogs}
% \label{sec:progress-dialogs}

% The \class{QProgressBar} provides a widget for displaying progress,
% and the \class{QProgressDialog} wraps this into a dialog. Progress is
% measured in terms of steps which may be specified by the user. WHen
% the widget is constructed, the minimum and maximum steps are
% specified. During the process, the value is incremented until it gets
% to the maximum, or the dialog is dismissed.


% <<results=hide>>=
% dlg <- Qt$QProgressDialog()
% dlg$setLabelText("Process is going on")
% dlg$setMinimum(0)
% dlg$setMaximum(10)
% @ 

% To use this, call the \method{open}{QDialog} method and update the
% dialog through its \method{setValue}{QProgressDialog} method.
% <<results=hide>>=
% dlg$open()
% for(i in 1:10) {
%   Sys.sleep(0.2)                         # some step in process
%   dlg$setValue(i)
% }
% @ 

% \XXX{I'm not using this correctly}
