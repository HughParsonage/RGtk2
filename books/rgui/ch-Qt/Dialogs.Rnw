%% Dialogs





\section{Dialogs}
\label{sec:built-dialogs}

\Qt{} implements the conventional high-level dialogs, including those
for printing, selecting files, selecting colors, and, most usefully,
sending simple messages and input requests to the user. We first
introduce message and input dialogs. This is followed by a discussion
of the infrastructure in \Qt{} for implementing custom
dialogs. Finally, we briefly introduce some of the remaining
high-level dialogs, such as the file selector.

\subsection{Message Dialogs}

All dialogs in \Qt{} are derived from \class{QDialog}. The message
dialog, \class{QMessageBox}, communicates a textual message to the
user. At the bottom of the dialog are a set of buttons, each
representing a possible response. Normally, the type of message is
indicated by an icon. If extra details are available, the dialog
provides the option for the user to view them.

\Qt{} provide two ways to create a message box. The simplest approach
is to call a static convenience method for issuing common types of
messages, including warnings and simple questions. The alternative,
described later, involves several steps and offers more control at a
cost of convenience. Here we take the simple path for presenting a
warning dialog:
<<qt-dialogs-static-warning, eval=FALSE>>=
response <- Qt$QMessageBox$warning(parent = NULL, title = "Warning!", 
                                   text = "Warning message...")
@
%
This blocks the flow of the program until the user responds and
returns the standard identifier for the button that was clicked. Each
type of button corresponds to a fixed type of response. The standard
button/response codes are listed in the
\qtenumeration{QMessageBox\$StandardButton} enumeration. In this case,
there is only a single button, \qcode{QMessageBox\$Ok}.  The dialog is
\textit{modal}, meaning that the user cannot interact with the
\qcode{parent} window until responding. If the \qcode{parent} is
\qcode{NULL}, as in this case, input to all windows is blocked.  The
dialog is automatically positioned near its parent, and if the parent
is destroyed, the dialog is destroyed, as well. Additional arguments
specify the available buttons/responses and the default response. We
have relied on the default values for these.

For more control over the appearance and behavior of the dialog, we
will take a more gradual path. First, we construct an instance of
\class{QMessageBox}. It is possible to specify several properties at
construction. Here is how one might construct a warning dialog:
<<qt-dialogs-construct>>=
dlg <- Qt$QMessageBox(icon = Qt$QMessageBox$Warning,
                      title = "Warning!",
                      text = "Warning text...",
                      buttons = Qt$QMessageBox$Ok,
                      parent = NULL)
@ 
%
This call introduces the \property{icon} property, which is a code
from the \qtenumeration{QMessageBox\$Icon} enumeration and identifies
a standard, themeable icon. The icon also implies the message type,
just as a button implies a response type. We also need to specify
the possible responses with the \qcode{buttons} argument.

Our dialog is already sufficiently complete to be displayed. However,
we have the opportunity to specify further properties. Two of the most
useful are \property{informativeText} and
\property{detailedText}:
<<qt-dialogs-extra-text>>=
dlg$informativeText <- "Less important warning information"
dlg$detailedText <- "Extra details most do not care to see"
@ 
Both provide additional textual information
at an increasing level of detail. The \property{informativeText} will
be rendered as secondary to the actual message text. To display the
\property{detailedText}, the user will need to interact with a control
in the dialog. An example is a stack trace for the warning.

After specifying the desired properties, the dialog is shown. The
approach to showing the dialog depends on whether the dialog should be
modal. A modal dialog is displayed with the \method{exec}{QDialog}
method. 
<<qt-dialogs-exec>>=
dlg$exec()
@ 
As its name implies, \method{exec}{QDialog} executes a loop
that will block until the user responds. As with the static
convenience methods, the return value indicates the
button/response. 

To present a non-modal dialog, we first need to register a response
listener, as the response will arrive asynchronously. Then we show,
raise and activate the dialog:
<<qt-dialogs-show>>=
qconnect(dlg, "finished", function(response) {
  ## handle response
  ## dlg$close() necessary?
})
dlg$show()
dlg$raise()
dlg$activateWindow()
@ 
%
There are several signals that indicate user response, including
\qcode{finished}, \qcode{accepted}, and \qcode{rejected}. The most
general is \qcode{finished}, which passes the button/response code as
its only argument.

Modal dialogs may be window modal (\code{Qt\$Qt\$WindowModal}), where
the dialog blocks all access to its ancestor windows, or application
modal (\code{Qt\$Qt\$ApplicationModal}) (the default) where all
windows are blocked. To specify the type of modality, call
\method{setWindowModality}{QMessageBox}.

To summarize, we present a general message box, supporting multiple responses:
<<QMEssageBoxAPI, results=hide>>=
dlg <- Qt$QMessageBox()
dlg$windowTitle <- "[This space for rent]"
dlg$text <- "This is the main text"
dlg$informativeText <- "This should give extra info"
dlg$detailedText <- "And this provides\neven more detail"

dlg$icon <- Qt$QMessageBox$Critical
dlg$standardButtons <- Qt$QMessageBox$Cancel | Qt$QMessageBox$Ok

## 'Cancel' instead of 'Ok' is the default
dlg$setDefaultButton(Qt$QMessageBox$Cancel)

if(dlg$exec() == Qt$QMessageBox$Ok) 
  print("A Ok")
@ 

\subsection{Input dialogs}
\label{sec:input-dialogs}

The \class{QInputDialog} class provides a convenient means to gather
information from the user and is thus the inverse of
\class{QMessageBox}. Possible input modes include selecting a value
from a list and entering text and numbers.  By default, input dialogs
consist of an input control, an icon, and two buttons: ``Ok'' and
``Cancel''.

Like \class{QMessageBox}, one can display a \class{QInputDialog}
either by calling a static convenience method or by constructing an
instance and configuring it before showing it. We demonstrate the
former approach for a dialog that requests textual input:
<<qt-dialogs-input-get-text>>=
text <- Qt$QInputDialog$getText(parent = NULL, title = "Gather text",
                                label = "Enter some text")
@
%
The return value is the entered string, or \qcode{NULL} if the user
cancelled the dialog. Additional parameters allow one to specify the
initial text and to override the input mode, e.g., for password-style
input.

We can also display a dialog for integer input. Here, we ask the user
for an even integer between 1 and 10:
<<qt-dialogs-input-get-range>>=
num <- Qt$QInputDialog$getInt(parent = NULL, title = "Gather integer",
                              label = "Enter an integer from 1 to 10",
                              value = 0, min = 2, max = 10, step = 2)
@ 
%
The number is chosen using a bounded spin box.  To request a real
value, call \function{Qt\$QInputDialog\$getDouble} instead.

The final type of input is selecting an option from a list of
choices:
<<qt-dialogs-input-get-item>>=
item <- Qt$QInputDialog$getItem(parent = NULL, title = "Select item",
                                label = "Select a letter",
                                items = LETTERS, current = 17)
@ 
%
The dialog contains a combo box filled with the capital letters. The
initial choice is $0$-based index 17, or the letter ``R''. The chosen
string is returned.

\class{QInputDialog} has a number of options that cannot be specified
via one of the static convenience methods. These option flags are
listed in the \qtenumeration{QInputDialog\$InputDialogOption}
enumeration and include hiding the ``Ok'' and ``Cancel'' buttons and
selecting an item with a list widget instead of a combo box. If such
control is necessary, we must explicitly construct a dialog instance,
configure it, execute it and retrieve the selected item.
<<qt-dialogs-input-explicit>>=
dlg <- Qt$QInputDialog()
dlg$setWindowTitle("Select item")
dlg$setLabelText("Select a letter")
dlg$setComboBoxItems(LETTERS)
dlg$setOptions(Qt$QInputDialog$UseListViewForComboBoxItems)
if (dlg$exec())
  print(dlg$textValue())
@ 

\subsection{QDialog}
\label{sec:qdialog}

Every dialog in \Qt{} inherits from \class{QDialog}, and we can leverage
it for our own custom dialogs. 

%% MFL: Custom dialogs should be custom classes derived from QDialog.
%% We should either give a nice example of that, or forget about this.

What makes a dialog different is when it is modal. That is the
\method{exec}{QDialog} call is used. This state may be broken by
quitting the window through the window manager, or by calling the
\method{done}{QDialog} method with an integer specifying the return
value (say \code{Qt\$QDialog\$Accepted} or
\code{Qt\$QDialog\$Rejected}). This closes the window and returns
control. If the \code{Qt\$Qt\$WA\_DeleteOnClose} attribute is set, the
dialog will be deleted, othewise it may be reused.

A simple example follows. We assume some parent window is defined as \code{parent}
<<echo=FALSE, results=hide>>=
## Example of a dialog created with QDialog
## not shown
parent <- Qt$QLabel("Some parent")
parent$setMinimumSize(400, 400)
parent$show()
parent$raise()
@ 

Our dialog is defined and we adjust our window modality
accordingly. Under \OSX, this will appear as a drop down sheet of
the parent, not in a separate window.
<<ADialog, results=hide>>=
dlg <- Qt$QDialog(parent)
dlg$setWindowModality(Qt$Qt$WindowModal)
dlg$setWindowTitle("A simple dialog")
@ 

Our dialog here is just a basic mock up. We use a horizontal box for
the buttons, but in an real application would use the \class{QDialogButtonBox}
<<results=hide>>=
dlg$setLayout(lyt <- Qt$QVBoxLayout())
lyt$addWidget(Qt$QLabel("Layout dialog components here"))
blyt <- Qt$QHBoxLayout()                # for buttons
lyt$addLayout(blyt)
@

Our buttons have callbacks that call the \method{done} method. We use
\code{user.data} to pass in the dialog reference.
<<results=hide>>=
ok <- Qt$QPushButton("Ok")
cancel <- Qt$QPushButton("Cancel")
blyt$addWidget(ok)
blyt$addWidget(cancel)

qconnect(ok, "pressed", function(dlg) dlg$done(1), user.data=dlg)
qconnect(cancel, "pressed", function(dlg) dlg$done(0), user.data=dlg)
@

<<eval=FALSE>>=
if(dlg$exec())
  print("Yes")
@ 



% \subsection{Wizards}
% \label{sec:wizards}

%% \XXX{Wizards do not have a registerField method defined.}

% \Qt{} provides a framework for wizards -- multipage dialogs. The
% \class{QWizard} class implements this. Wizards are compose of pages,
% each containing a number of fields for the user to interact
% with. Wizards may also have different naviagational routes. 


% <<>>=
% wizard <- Qt$QWizard()
% wizard$setWindowTitle("A wizard")

% getAgePage <- Qt$QWizardPage(wizard)
% getAgePage$setTitle("What is your age?")
% lyt <- Qt$QFormLayout()
% getAgePage$setLayout(lyt)
% lyt$addRow("Age", (age <- Qt$QLineEdit()))
% getAgePage$registerField("age", age)
% wizard$addPage(getAgePage)

% getToysPage <- Qt$QWizardPage(wizard)
% getGenderpage$setTitle("What toys do you like?")
% lyt <- Qt$QFormLayout()
% getToysPage$setLayout(lyt)
% lyt$addRow("Toys", (toys <- Qt$QLineEdit()))
% getToysPage$registerField("toys", toys)
% wizard$addPage(getToysPage)


% getGamesPage <- Qt$QWizardPage(wizard)
% getGenderpage$setTitle("What games do you like?")
% lyt <- Qt$QFormLayout()
% getGamesPage$setLayout(lyt)
% lyt$addRow("Games", (games <- Qt$QLineEdit()))
% getGamesPage$registerField("games", games)
% wizard$addPage(getGamesPage)
          


% ret <- wizard$exec()

% @ 


\subsection{File and Directory chooing dialogs}
\label{sec:file-direct-choosing}


\class{QFileDialog} allows the user to select files and directories,
by default using the platform native file dialog.  As with other
dialogs there are static methods to create dialogs with standard
options.  These are \qcode{getOpenFileName}, \qcode{getOpenFileNames},
\qcode{getExistingDirectory}, and \qcode{getSaveFileName}.  To select
a file name to open we would have:
<<QFIleDialog, eval=FALSE>>=
fname <- Qt$QFileDialog$getOpenFileName(NULL, "Open a file...", getwd())
@ 
%
All take as intial arguments a parent, a caption and a
directory. Other arguments allow one to set a filter, say. For basic
use, these are nearly as easy to use as \R's \function{file.choose}.
If a file is selected, \code{fname} will contain the full path to the
file, otherwise it will be \code{NULL}.

To allow multiple selection, call the plural form of the method:
<<eval=FALSE>>=
fnames <- Qt$QFileDialog$getOpenFileNames(NULL, "Open file(s)...", getwd())
@ 

To select a file name for saving, we have
<<eval=FALSE>>=
fname <- Qt$QFileDialog$getSaveFileName(NULL, "Save as...", getwd())
@ 

And to choose a directory, 
<<eval=FALSE>>=
dname <- Qt$QFileDialog$getExistingDirectory(NULL, "Select directory", getwd())
@ 

To specify a filter by file extension, we use a name filter. A name
filter is of the form \code{Description (*.ext *.ext2)} (no comma) where this
would match files with extensions \code{ext} or \code{ext2}. Multiple
filters can be used by separating them with two semicolons. For
example, this would be a natural filter for \R{} users:
<<>>=
rfilter <- "R files (*.R .RData);; Sweave files (*.Rnw);; All files (*.*)"
fnames <- Qt$QFileDialog$getOpenFileNames(NULL, "Open file(s)...", getwd(), 
                                          rfilter)
@ 

\paragraph{Explicitly constructing a dialog}

Although the static functions provide most of the functionality, to
fully configure a dialog, it may be necessary to explicitly construct
and manipulate a dialog instance. Examples of options not available
from the static methods are history (previously selected file names),
sidebar shortcut URLs, and filters based on low-level file attributes
like permissions.

\begin{example}{File dialogs}{ex:qt-r-files-dialog}
We construct a dialog for opening an R-related file, using the file
names selected above as the history:
<<QFileDialogAPI, results=hide>>=
filter <- paste("R files (*.R .RData)",
                "Sweave files (*.Rnw)",
                "All files (*.*)", sep=";;")
dlg <- Qt$QFileDialog(NULL, "Choose an R file", getwd(), filter)
dlg$fileMode <- Qt$QFileDialog$ExistingFiles
dlg$setHistory(fnames)
@
%
The dialog is executed like any other. To get the specified files,
call \method{selectedFiles}{QFileDialog}:
<<eval=FALSE>>=
if(dlg$exec())
  print(dlg$selectedFiles())
@ 

\end{example}


% \subsection{Progress dialogs}
% \label{sec:progress-dialogs}

% The \class{QProgressBar} provides a widget for displaying progress,
% and the \class{QProgressDialog} wraps this into a dialog. Progress is
% measured in terms of steps which may be specified by the user. WHen
% the widget is constructed, the minimum and maximum steps are
% specified. During the process, the value is incremented until it gets
% to the maximum, or the dialog is dismissed.


% <<results=hide>>=
% dlg <- Qt$QProgressDialog()
% dlg$setLabelText("Process is going on")
% dlg$setMinimum(0)
% dlg$setMaximum(10)
% @ 

% To use this, call the \method{open}{QDialog} method and update the
% dialog through its \method{setValue}{QProgressDialog} method.
% <<results=hide>>=
% dlg$open()
% for(i in 1:10) {
%   Sys.sleep(0.2)                         # some step in process
%   dlg$setValue(i)
% }
% @ 

% \XXX{I'm not using this correctly}
