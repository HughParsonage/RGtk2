%% widgets using MVC framework
\section{Model View Controller implementation in Qt}
\label{sec:models}

%% overview
The model-view-controller architecture adds a complexity to widgets
that is paid in order to create more flexible and efficient use of
resources. Keeping the model separate from the view allows multiple
views for the same data. It also allows view to be efficient when
there are large data sets involved. The basic MVC architecture has a
controller to act as a go-between for a model and its views. In \Qt,
this an item in a model has a delegate that allows the user to see and
perhaps edit the item's data within a view. Although delagates can be
redefined, we are content to use those provided by \Qt. 

We discuss in the following various views: comboboxes, list views,
table views and tree views. These are all familiar. The primary
difficulty with using backend models is the specification and
interaction with the model.

Models in \Qt{} are derived from the \class{QAbstractItemModel} class,
although there are standard sub-classes for list, table and
heirarchical models (\class{QStringListModel},
\class{QAbstractListModel}, \class{QAbstractTableModel}, and
\class{QStandardItemModel}). The \pkg{qtbase} package provides the
\constructor{qdataFrameModel} constructor to provide an mapping from a
data frame to an item model. 

%% items, roles
A model is comprised of items, each having an associated index. Items
have associated data which may vary based on the role the item is
playing. For example, one role describes the data for display whereas
another role describes the data to be shown for a tooltip. Both
descriptions, and others, are stored in the item's data. For the
\constructor{qdataFrameModel} these roles are encoded as additional,
specially named columns in the data frame. For simple usages, \Qt{}
provides a set of convenience classes where the items and views are coupled.







\section{The item-view classes}
\label{sec:using-standard-item}

%% decoupled/coupled with model 
The use of a model separate from a view can be relatively complicated,
as such \Qt{} provides classes that couple a standard model and
view. Defining the model is much easier. In the case of a combobox and
a list view the model can be specified by a character vector.


\subsection{Comboboxes}
\label{sec:comboboxes}

The \class{QComboBox} class implements the combobox widget.  The
\class{QListWidget} class implements a basic list view. Both do
similar things -- allow selection from a list of possible vlaues,
although differently. As such, their underlying methods are mostly
similar although their implementations have a different class
inheritance.  We discuss here the basic usage for comboboxes. Both
widgets are views for an underlying model and we restrict ourselves,
for now, to the simplest choice of these models.

By basic usage we mean setting a set of values
for the user to choose from, and for comboboxes optionally allowing
them to type in a new value.  In the simplest use, we can define the
items in their model through a character vector through the method
\method{addItems}{QComboBox}. (The items must be character, so numeric
vectors must be coerced. This works through a convesion into a
\class{QStringList} object.)  One can remove items by index with
\method{removeItem}{QComboBox}.  To allow a user to
enter a value not in this list, the property
\property{editable}{QComboBox} can be set to \code{TRUE}.



Once values are entered the property
\property{currentIndex}{QComboBox} holds the 0-based index of the
selected value. This will be $-1$ when no selection is made, and may
be meaningless if the user can edit the values. Use
\method{setCurrentIndex}{QComboBox} to set the popup value by index
($-1$ to leave unselected). The \method{count}{QComboBox} method
returns the number of items available.

The property \property{currentText}{QComboBox} returns the current
text. This will be a blank string if there is no current index.  There
is no corresponding \meth{setCurrentText}, rather one can use the
\method{findText}{QComboBox} method to get the index of the specified
string. There is an option to adjust  how finding occurs through
the enumeration \qtenumeration{Qt::MatchFlags}.


The signal \signal{activated} is emitted when the user chooses an
item. The item index is passed to the callback. This signal responds
to activation by the finishing editing of the text by the return key.
The \signal{highlighted} signal is emitted when the popup is engaged
and the user mouses over an entry.  For editable comboboxes, the
signal \signal{editTextChanged} is emitted after each change to the
text.


\begin{example}{An example of one combobox updating another}{ex:qt-comboboxes}
This example shows how one combobox, to select a region in the U.S.,
is used to update another, which lists states in that region. We will
use the following data frame for our data., which we split into a list.

<<>>=
df <- data.frame(name=state.name, region=state.region,
                 highlight=state.x77[,1], stringsAsFactors=FALSE)
l <- split(df, df$region)
@ 



Our \code{region} combobox is loaded with the state regions. When one
is selected, the callback for \signal{activated} will first remove any
items in the \code{state} combobox, then add in the appropriate
states. The \code{ind} index is used to determine which region.
<<results=hide>>=
region <- Qt$QComboBox()
region$addItems(names(l))
region$setCurrentIndex(-1)              # no selection
qconnect(region, "activated", function(ind) {
  sapply(rev(seq_len(state$count)), function(i)
         state$removeItem(i-1))         # clear states
  state$addItems(l[[ind+1]]$name)       # add
})
@ 

The state combobox shows how the \signal{highlighted} signal can be
employed. In this case, information about the highlighted state is
placed in the window;s title. Not really a great choice, but
sufficient for this example.
<<results=hide>>=
state <- Qt$QComboBox()
qconnect(state, "highlighted", function(ind) {
  pop <- l[[region$currentText]][ind + 1, "highlight"]
  w$setWindowTitle(sprintf("Popuplation is %s", pop))
})
@ 
Finally, we use a form layout to organize the widgets.
<<results=hide>>=
w <- Qt$QGroupBox("Two comboboxes")
lyt <- Qt$QFormLayout()
w$setLayout(lyt)
lyt$addRow("Region:", region)
lyt$addRow("State:", state)
@ 

<<echo=FALSE, results=hide>>=
w$show(); w$raise()
@ 
\end{example}



\subsection{A list widget}
\label{sec:list-view}

The \class{QListWidget} provides an easy-to-use widget for displaying
a set of items for selection. It uses an item-based model for its
data. The \class{QListView} widget provides a more general framework
with different backend models.
As with comboboxes, we can populate the
items directly from a character vector through the
\method{addItems}{QListWidget} method. However, here we mostly focus
on interacting with the widget through the item model.

The items in a \class{QListWidget} instance are of the
\class{QListWidgetItem} class. New items can be constructed directly
through the constructor. The first argument is the text and the
optional second argument a parent \class{QListWidget}. If no parent is
specified, the the item may be added through the methods
\method{addItem}{QListWidget}, or \method{insertItem}{QListWidget}
where the row to insert is specified by index. The method
\method{takeItem}{QListWidget} is used to remove items by their index
and \method{clear}{QListWidget} will remove all of them.

\class{QListWidgetItems} can have their text specified at construction
or through the method \method{setText}{QListWidgetItem} and optionally
have an icon set through the \method{setIcons}{QListWidgetItem}. There
are also methods to set a status bar tip or a tooltip.

Once an item is added to list widget it can be referenced several
ways. The currently selected item is returned by
\method{currentItem}{QListWidget}, whereas
\method{currentRow}{QListWidget} returns the current row by index, and
\method{currentIndex}{QListWidget} returns a \class{QModelIndex}
instance (with method \meth{row} to get the index). As well, any item
may be referenced by row index through \method{item}{QListWidget} or
position (say within an event handler) by
\method{itemAt}{QListWidget}. One can search for the items with the
\method{findItems}{QListWidget} method, which returns a list of
items. An optional second argument uses the
\qtenumeration{Qt::MatchFlags} enumeration to adjust how matches are
made, for example \code{Qt\$Qt\$MatchRegExp} to match by regular expression.



\paragraph{Selection}
By default, single selection mode is enabled. This can be adjusted through
the \method{setSelectionMode}{QListWidget} argument by specifying a
value in \qtenumeration{QAbstractItemView::SelectionMode}, such as
\code{SingleSelection} or \code{ExtendedSelection}. The latter changes
selection when a new item is chosen, unless the \kbd{Control} or
\kbd{Shift} keys are pressed.

To retrieve the selected values, the method
\method{selectedItems}{QListWidget} will return the items in a list. 

Setting an item to be selected is done through
\method{setCurrentItem}. The first argument is the item, the optional
second one the \qtenumeration{QItemSelectionModel::SelectionFlag}
enumerations. If specified as \code{Qt\$QItemSelectionModel\$Select}
(the default) the item will be selected, but other choices are
possible such as \qcode{Deselect} or \qcode{Toggle}.

\paragraph{Checkable items}
The underlying items may be checkable. This is initiated by setting an
initial check state (\method{setCheckState}{QListWidgetItem}) with a value from \qcode{Checked}
(\code{Qt\$Qt\$Checked}), \qcode{Unchecked} or
\qcode{PartiallyChecked}. For example, we can populate a list widget
and set the values unchecked with.

<<Checkable,results=hide>>=
w <- Qt$QListWidget()
w$addItems(state.name)
sapply(1:w$count, function(i) w$item(i-1)$setCheckState(Qt$Qt$Unchecked))
@ 
<<echo=FALSE, results=hide>>=
w$show(); w$raise()
set.seed(1)
sapply(sample(1:w$count, 30), 
       function(i) w$item(i-1)$setCheckState(Qt$Qt$Checked))
@ 
Then, after checking a few we can get the state along the lines of:
<<>>=
sapply(1:8, function(i) as.logical(w$item(i-1)$checkState()))
@ 
This uses the fact that the enumeration for \qcode{Unchecked} is $0$
and \qcode{Checked} is $w$.


\paragraph{Signals}
There are several signals that are emitted by the widget. Chief among
them are \signal{itemActivated}, which is emitted when a user clicks
on an item or presses the activation key. The latter is what
distinguishes it from the \signal{itemClicked} signal. For capturing
double clicks there is \signal{itemDoubleClicked}. For these three,
the undelying item is passed to the callback. The
\signal{itemSelectionChanged} signal is emitted when the underlying
selection is changed.

\begin{example}{Filtering example}{ex-qt-listwidget-filter}
We illustrate the widget with a typical filtering example, where
a user types in values to narrow down the available choices. We begin
by setting up our widgets.
<<FilteringByListWidget, results=hide>>=
w <- Qt$QGroupBox("Filtering example")
lyt <- Qt$QFormLayout()
w$setLayout(lyt)

lyt$addRow("Filter:", f <- Qt$QLineEdit())
lyt$addRow("State:", lw <- Qt$QListWidget())
lyt$addRow("", b <- Qt$QPushButton("Click me"))
@ 

For convenience, we use a built-in data set for our choices. He
populate the list widget and add a tooltip indicating the area.
<<results=hide>>=
for(i in state.name) {
  item <- Qt$QListWidgetItem(i, lw)             # populate
  item$setToolTip(sprintf("%s has %s square miles", i, state.x77[i, "Area"]))
}
@ 
For this example, we allow multiple selection.
<<results=hide>>=
lw$setSelectionMode(Qt$QAbstractItemView$ExtendedSelection)
@ 

The following callback updates the displayed items so that only ones
matching the typed in string are displayed. Rather than compare each
items to the matched items, we simply hide them all then unhide those
that match.
<<results=hide>>=
qconnect(f, "textChanged", function(str) {
  matching <- lw$findItems(str, Qt$Qt$MatchStartsWith)
  sapply(seq_len(lw$count), function(i) lw$item(i-1)$setHidden(TRUE))
  sapply(matching, function(i) i$setHidden(FALSE))
})
@ 


<<echo=FALSE>>=
## Code to show how to set a selection
## find and set selection
## items <- lw$findItems("New", Qt$Qt$MatchStartsWith)
## sapply(items, function(i) {
##   lw$setCurrentItem(i, Qt$QItemSelectionModel$Select)
## })
@ 

The following shows how we can grab the selected values.
<<results=hide>>=
qconnect(b, "pressed", function() {
  vals <- sapply(lw$selectedItems(), function(i) i$text())
  print(vals)
})
@ 

<<echo=FALSE, results=hide>>=
w$show()
w$raise()


@ 
\end{example}


\begin{example}{Combining a combobox and list widget to select a
    variable name}{eg-qt-select-variable}
  This example shows how we can combine a combobox and a list widget
  to select a variable name from a data frame. Here we select a value
  by dragging it. A such we need to define a sub-class of
  \class{QListWidget} to implement the \code{mousePressEvent}.
  
<<VariableSelector, results=hide>>=
## A subclass of ListWidget so that we can drag values
qsetClass("DraggableListWidget", Qt$QListWidget, function(parent=NULL) {
  super(parent)
  this$df <- NULL
 })
@   
%
The property \code{df} holds the name of the dataframe that will be
selected through a combobox. Here is a method to set the value.
<<results=hide>>=
qsetMethod("setDf", DraggableListWidget, function(df) this$df <- df)
@ 
%
For drag and drop we show how to serialize an arbitrary \R{} object to
pass through to the drop target.  We pass in a list of the data frame
name and the selected variable name. The method
\method{setData}{QMimeData} takes a MIME type (which we arbitrarily
define) and a value. This value will be retrieved by the
\method{data}{QMimeData} method and we can then call
\function{unserialize}.
<<>>=
qsetMethod("mousePressEvent", DraggableListWidget, function(e) {
  item <- itemAt(e$pos())
  val <- list(df=this$df, var=item$text())

  md <- Qt$QMimeData()
  md$setData("R/serialized-data", serialize(val, NULL))

  drag <- Qt$QDrag(this)
  drag$setMimeData(md)

  drag$exec(Qt$Qt$CopyAction | Qt$Qt$MoveAction, Qt$Qt$CopyAction)
})
@ 


With this, we know create a widget to hold the combobox and the list
box. The constructor creates the widgets, lays them out, initializes
the data sets then sets a handler to update the variable list when the
dataframe selector does.
<<>>=
qsetClass("VariableSelector", Qt$QWidget, function(parent=NULL) {
  super(parent)

  this$dfcb <- Qt$QComboBox()
  this$varList <-  DraggableListWidget()

  lyt <- Qt$QVBoxLayout()
  lyt$addWidget(dfcb)
  lyt$addWidget(varList)
  varList$setSizePolicy(Qt$QSizePolicy$Expanding, Qt$QSizePolicy$Expanding)
  setLayout(lyt)

  updateDataSets()
  qconnect(dfcb, "activated", function(ind) {
    updateVarList(dfcb$currentText)
  })
})
@ 
%

Our method to update the data frame choice is a bit convoluted as we try to
keep the currently selected data frame, if possible.
<<>>=
qsetMethod("updateDataSets", VariableSelector, function() {
  curVal <- this$dfcb$currentText
  this$dfcb$clear()
  x <- ls(envir=.GlobalEnv)
  dfs <- x[sapply(x, function(i) is.data.frame(get(i, inherits=TRUE)))]
  if(length(dfs)) {
    this$dfcb$addItems(dfs)
    if(is.null(curVal) || !curVal %in% dfs) {
      this$dfcb$setCurrentIndex(-1)
      updateVarList(NULL)
    } else {
      this$dfcb$setCurrentIndex(which(curVal == dfs))
      updateVarList(curVal)               # curVal NULL, or a name
    }
  }
})
@ 

Finally, we need to update the list of variables to reflect the state
of the combo box selection. Here we define a helper method to display
an appropriate icon based on the class of the variable.
<<>>=
getIconFile <- function(x) UseMethod("getIconFile")
getIconFile.default <- function(x)
  Qt$QIcon(system.file("images/numeric.gif", package="gWidgets"))
getIconFile.factor <- function(x)
  Qt$QIcon(system.file("images/factor.gif", package="gWidgets"))
getIconFile.character <- function(x)
  Qt$QIcon(system.file("images/character.gif", package="gWidgets"))
@ 

This method populates the variable list to reflect the indicated data
frame. As items are automatically drag enabled, we do not need to add
anything more here, as we've implement the \code{mousePressEvent}.
<<results=hide>>=
qsetMethod("updateVarList", VariableSelector, function(df=NULL) {
  this$varList$setDf(df)
  this$varList$clear()
  if(!is.null(df)) {
    d <- get(df)
    sapply(names(d), function(i) {
      item <- Qt$QListWidgetItem(i, this$varList)
      item$setIcon(getIconFile(d[,i]))
    })
  }
})
@ 
\end{example}

\subsection{A table widget}
\label{sec:table-widget}

The \class{QTableWidget} class provides a widget for displaying
tabular data in an item-based approach, similar to
\class{QListWidget}. The \class{QTableView} widget is more flexible,
but also more demanding, as it has the ability to have different data
models (which can be much faster with large tables). As such, only if
your needs are not too complicated this widget will be a good choice.

The dimensions of the table must be set prior to adding items. The methods
\method{setRowCount}{QTableWidget} and
\method{setColumnCount}{QTableWidget} are used.



The \class{QTableWidget} class has a built in model that is built up
item by item. Items are of class \class{QTableWidgetItem} and are
created first, then inserted into the widget by row and column through
the method \method{setItem}. (These operations are not vectorized and
can be slow for large tables.)  Items can be removed by index with
\method{takeItem}{QTableWidget}. The item can be reinserted. The
\method{clear}{QTableWidget} will remove all items, even headers
items, whereas, \method{clearContents}{QTableWidget} will leave the
headers. Both keep the dimensions.

As with \class{QListWidget}, items have various properties that can be
adjusted. The text can be specified to the constructor, or set through
\method{setText}{QTableWidgetItem}. Text alignment is specified
through \method{setTextAlignment}{QTableWidgetItem}. The font may be
configured through \method{setFont}{QTableWidgetItem}. The methods
\method{setBackground}{QTableWidgetItem} and
\method{setForegroup}{QTableWidgetItem} are used to adjust the colors.


Items may also have icons (\method{setIcon}{QTableWidgetItem}),
tooltips (\method{setToolTip}{QTableWidgetItem}), and statusbar tips
(\method{setStatusTip}{QTableWidgetItem}.


Similar to \class{QListWidget}, \class{QTableWidgetItem} instances are
returned by the method \method{item}{QTableWidget}, with a
specification of row and column; and by \method{itemAt}{QTableWidget},
with a specification of a position. The \method
{findItems}{QTableWidget} will return a list of items matching a
string. Also, there is the method
\method{currentItem}{QTableWidget}. From an item, the current column
and row can be found with the methods \method{column}{QTableWidget}
and \method{row}{QTableWidget}

\paragraph{Item flags}
Items may have several different properties: are they editable,
draggable, ... To specify, one sets an items flags with values taken
from the \qtenumeration{Qt::ItemFlag} enumeration. The possible values
are: \qcode{NoItemFlags}, \qcode{ItemIsSelectable},
\qcode{ItemIsEditable}, \qcode{ItemIsDragEnabled},
\qcode{ItemIsDropEnabled}, \qcode{ItemIsUserCheckable},
\qcode{ItemIsEnabled}, and \qcode{ItemIsTriState} (has three check
states). To make an item checkable, one must first set the check
state. By default, the widget has all these sets (except no and tri
state). To remove a flag, one can specify all the ones they want, or
use integer arithmetic and subtract. E.g., to remove the editable
attribute one has this possibility:
<<results=hide>>=
item <- Qt$QTableWidgetItem("Not editable")
item$setFlags(item$flags() - Qt$Qt$ItemIsEditable)
@ 


\paragraph{Headers}
Columns may have headers. These are set all at once by specifying a character vector to
\method{setHorizontalHeaderLabels}{QTableWidget}, or can be set with
an item by \method{setHorizontalHeaderItem}{QTableWidget}. The header
is returned by \method{horizontalHeader}{QTableWidget} which has a
method \meth{setVisible} to toggle its visibility. Similarly, rows can
have (vertical) headers.

To specify the width of a column the method
\method{setColumnWidth}{QTableView} is available. One specifies the
column, then the width in pixels.  The method
\method{horizontalHeader}{QTableView} returns an instance of class
\class{QHeaderView}. To make the last column stretch to fill the
available space is specified through the method
\method{setStretchLastSection}{QHeaderView} with a value of
\code{TRUE}.

\paragraph{Sorting and Filtering}

This widget can have its rows sorted by the values of a column through
the method \method{sortItems}{QTableWidget}. One specifies the column
by index, and an order. The default is \qcode{AscendingOrder}, the
alternative is \code{Qt\$Qt\$DescendingOrder}. Sorting should be done
after the table is populated with items.



Rows and columns can be hidden through the methods
\method{setRowHidden}{QTableWidget} and
\method{setColumnHidden}{QTableWidget}. This can be used for filtering
purposes without redrawing the table.


\paragraph{Selection}
\XXX{Does \class{QTableWidgetSelectionRange} work to set the selection?}

For the table widget one can easily select rows, columns, blocks and
even combinations thereof.  An underlying selection model implements
selection, but the \class{QTableWidget} provides an interface. The
currently selected items are returned as a list through the method
\method{selectedItems}{QTableWidget}.

A given cell may be selected by index (row then column) through the
method \method{setCurrentCell}{QTableWidget}, or if the item instance
is known by \method{setCurrentItem}{QTableWidget}. In addition, an
option selection flag from the enumeration
\qtenumeration{QItemSelectionModel::SelectionFlag} can be specified
with values among \qcode{Select}, to add the item to the selection;
\qcode{Clear}, to clear all selection; \qcode{Toggle}, to toggle the
specified item; \qcode{Rows}, to extend the selection to the enclosing
row; and similarly for \qcode{Columns}.  For an item, the method
\method{setSelection}{QTableWidgetItem} takes a logical value to
indicate the selection state.


The current selection can be cleared with by selecting an item with
the \qcode{Clear} attribute, or by grabbing the underlying selection
model and calling its \meth{clearSelection} method. E.g, something like:
<<eval=FALSE>>=
tbl$selectionModel()$clearSelection()
@ 


\paragraph{Signals}

The \class{QTableWidget} class has a number of signals it emits. They
mostly come in pairs: ``cell'' ones passing in the row and column index and
``item'' ones passing in an item reference. For example,
\signal{cellClicked} and \signal{itemClicked}, both called when a cell
is clicked. Also there are \signal{cellDoubleClicked},
\signal{cellEntered}, \signal{cellPressed},
\signal{currentCellChanged} and \signal{cellChanged} (with similar
``item'' ones). Also of interest is the \signal{itemSelectionChanged}
which is called when the selection changes.


\begin{example}{Selection of variables}{eg:qt-selection-from-tablewidget}
  \SweaveInput{ex-qt-table-selection}
\end{example}


\begin{example}{A drag and drop interface to \function{xtabs}}{eg:qt-dnd-table}
  \SweaveInput{ex-qt-dnd-table}
\end{example}


\section{Item models and their views}
\label{sec:using-model-with}





\subsection{Using a data frame for a model}
\label{ssec:using-data-frame}

For tabular data a model can be made quite easily with the constructor
\constructor{qdataFrameModel}. This function maps a data frame to the
model. The data frame can contain role information. This is provided
by adding additional columns with a specific naming convention. A
column with name \code{a} can have its role information specified with
another column with name \code{.a.ROLE} where \code{ROLE} is one of
available roles, such as \code{"display"} (the default),
\code{"decoration"}, \code{"edit"}, \code{"toolTip"},
\code{"statusTip"}, or  \code{"textAlignment"}. 

The following illustrates a basic usage. We use a \class{QTableView}
instance for a view. The model is connected to the view through its
\method{setModel}{QTableView} method.           

<<results=hide>>=
df <- data.frame(a=1:3, 
                 b=1:3, .b.toolTip=state.name[1:3],
                 c=1:3, .c.textAlignment=rep(Qt$Qt$AlignRight, 3),
                 stringsAsFactors=FALSE)
rownames(df) <- state.name[1:3]

model <- qdataFrameModel(df)

view <- Qt$QTableView()
view$setModel(model)
@ 

<<echo=FALSE, results=hide>>=
view$show(); view$raise()
@ 




\subsection{Table models}
\label{ssec:table-models}

\ssection{Standard item models}
\label{ssec:standard-item-models}



\subsection{Table views}
\label{ssec:table-views}

\subsection{Tree views}
\label{ssec:tree-views}

