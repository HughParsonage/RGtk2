%% widgets using MVC framework

The model, view, controller (MVC) pattern is fundamental to the design
of widgets that display and manipulate data. Keeping the model
separate from the view allows multiple views for the same
data. Generally, the model is an abstract interface. Thus, the same
view and controller components are able to operate on any data source
(e.g., a database) for which a model implementation exists.

\Qt{} provides \class{QAbstractItemModel} as the base for all of its
data models. Like \class{GtkTreeModel}, \class{QAbstractItemModel}
represents tables, optionally with a hierarchy. The precise
implementation depends on the subclass. Widgets that view item models
extend \class{QAbstractItemView} and include tables, lists, trees and
combo boxes. This section will outline the available model
and view implementations in \Qt{} and \pkg{qtbase}.

\section{Display of tabular data}

As mentioned, \Qt{} expects data to be stored in a
\class{QAbstractItemModel}. In \R, the canonical structure for tabular
data is \class{data.frame}. The \class{DataFrameModel} class bridges
these structures by wrapping \class{data.frame} in an implementation
of \class{QAbstractItemModel}. This essentially allows a
\class{data.frame} object to be passed to any part of \Qt{} that
expects tabular data. It also offers significant performance benefits:
there is no need to copy the data frame into a C++ data structure,
which would be especially slow if the looping occurred in
\R. Displaying a simple table of data with \class{DataFrameModel} is
much simpler than with \GTK{} and \class{RGtkDataFrame}. Here we
show a \class{data.frame} in a table view:
<<qt-mvc-qdfm,print=false>>=
data(mtcars)
model <- qdataFrameModel(mtcars)
view <- Qt$QTableView()
view$setModel(model)
@ 
%
We could also pass our model to any other view expecting a
\class{QAbstractItemModel}. For example, the first column could be
displayed in a list or combo box.

The \class{DataFrameModel} object is a reference, so any changes are
reflected in all of its views. The \R{} data frame of a
\class{DataFrameModel} may be accessed using
\function{qdataFrame}:
<<qt-mvc-qdfm-access>>=
head(qdataFrame(model), 3)
qdataFrame(model)$hpToMpg <- with(qdataFrame(model), hp / mpg)
@ 
%
Our table view now contains a new column, holding the horsepower to
miles per gallon ratio. It is important to notice that the view has
been updated implicitly, through manipulation of the underlying model.

Let us now assume that a missing value (\code{NA}) has been introduced
into our dataset:
<<qt-mvc-qdf-na>>=
qdataFrame(model)$mpg[1] <- NA
@ 
%
The table view will display this as "nan" or "inf", which is
inconsitent with the notation of \R. The conversion of the numeric
data to text is carried out by an \textit{item delegate}. Similar to a
\GTK{} cell renderer, an item delegate is responsible for the
rendering and editing of items (cells) in a view. Every type of item
delegate is derived from the \class{QAbstractItemDelegate} class. By
default, views in \Qt{} will use an instance of
\class{QStyledItemDelegate}, which renders items according to the
current style. As \Qt{} is unaware of the notion and encoding of
missing values in \R, we need to give \Qt{} extra guidance. The
\pkg{qtbase} package provides the \class{RTextFormattingDelegate}
class for this purpose. To use it, one creates an instance and sets it
as the item delegate for the model:
<<qt-mvc-rtfd>>=
delegate <- qrTextFormattingDelegate()
model$setDelegate(delegate)
@ 
%
Delegates may also be assigned on a per column or per row
basis. \class{RTextFormattingDelegate} will handle missing values in
numeric vectors, as well as adhere to the numeric formatting settings
in \function{options()}, namely \qcode{digits} and \qcode{scipen}.

%% TODO: basic manipulation of QTableView 
%% TODO: memory management (keeping models alive with a parent)

\section{Displaying Lists}
\label{sec:displaying-lists}

%% It is debatable as to whether QListWidget would be more convenient
%% than a QListView backed by either QStringListModel or
%% DataFrameModel, especially since we have already explained the
%% latter. Getting data onto the screen takes about one more line with
%% the model interfaces. Interpreting user interaction (selection) is
%% about the same level of complexity. The View classes will yield
%% QModelIndex objects, the Widget classes yield WidgetItem
%% objects. QModelIndex only has to be described once, and offers some
%% advantages, like always yielding a row/column index, which is nice
%% for indexing into other data structures. While the Widgets offer
%% some high-level conveniences (like icons in a QListWidget),
%% for large lists it would be too slow to configure each widget
%% item. Much faster to just use roles in a DataFrameModel.


It is often desirable to display a list of items, usually as text. A
single column \class{QTableView} approximates this but also includes
row and column headers, by default. Also, the two dimensional API of
\class{QTableView} is more complicated than needed for a one
dimensional list. For these and other reasons, \Qt{} provides
\class{QListView} for displaying a single column from a
\class{QAbstractItemModel} as a list. We can use
\class{DataFrameModel} to quickly display the first column from a data
frame (or anything coercible into a data frame):
<<qt-mvc-lists-df, print=false>>=
model <- qdataFrameModel(rownames(mtcars))
view <- Qt$QListView()
view$setModel(model)
@
%
By default, \class{QListView} displays the first column from the
model, although the column index can be customized. 

Using a data model allows us to share data between multiple views. For
example, we could view a data frame as a table using a
\class{QTableView} and also display the row identifiers in a separate
list:
<<qt-mvc-lists-combo>>=
mtcars.id <- cbind(makeAndModel = rownames(mtcars), mtcars)
model <- qdataFrameModel(mtcars.id)
tableView <- Qt$QTableView()
tableView$setModel(model)
listView <- Qt$QListView()
listView$setModel(model)
@ 
%
Now, when we resort the model, both views will be updated:
<<qt-mvc-lists-sort>>=
df <- qdataFrame(model)
qdataFrame(model) <- df[order(df$mpg),]
@ 

When the list items are not associated with a data frame, they may be
conveniently represented as a character vector. In this case,
\class{DataFrameModel} is not very appropriate, as the character
vector will be coerced to a data frame. Instead, consider
\class{QStringListModel} from \Qt. In \pkg{qtbase},
\class{QStringList} refers to a character vector. We demonstrate
the use of \class{QStringListModel} to populate a list view from a
character vector:
<<qt-mvc-lists-qslm>>=
model <- Qt$QStringListModel(rownames(mtcars))
listView <- Qt$QListView()
listView$setModel(model)
@ 
%
Now we can retrieve the values as a character vector, rather than as a
data frame:
<<qt-mvc-lists-qslm-retrieve>>=
head(model$stringList)
@ 

\class{QListView} supports features beyond those of a simple list,
including features often found in file browsers and desktops. For
example, items may be wrapped into additional columns, and an icon
mode, supporting unrestricted layout and drag and drop, is also
available.

\section{Accessing Item Models}

We have shown how \class{DataFrameModel} and \class{QStringListModel}
allow the storage and retrieval of data in familiar data
structures. However, this is not true of all data models, including
most of those in \Qt. Alternative models are required, for example, in
the case of hierarchical data. In such cases, or when interpreting
user input, such as selection, it is necessary to interact with the
low-level, generic API of the item/view framework.

An item model refers to its rows, columns and cells with
\class{QModelIndex} objects, which are created by the model:
<<qt-mvc-model-index-create>>=
index <- model$index(0, 0)
index$row()
index$col()
@ 
% 
Our \qcode{index} refers to the first row of the
\class{QStringListModel}, using $0$-based indices.
The index points to a cell in the model, and we can retrieve the data
in the cell using only the index:
<<qt-mvc-model-index-data>>=
firstCar <- model$data()
@ 
%
This can be extended to retrieve all of the items in the list:
<<qt-mvc-model-populate>>=
sapply(seq(model$rowCount()), function(i) model$index(i, 0)$data())
@ 

Setting the data is also possible, yet requires calling
\method{setData}{QAbstractItemModel} on the model, not the index:
<<qt-mvc-model-index-data-set>>=
model$setData(index, toupper(firstCar))
@ 
%
We will leave the population of a model with the low-level API as an
exercise for the reader. Recall that \class{DataFrameModel} and
\class{QStringListModel} provide an interface that is much faster and
more convenient. When using such models, it is usually only necessary
to directly manipulate a \class{QModelIndex} when handling user input,
as we describe in the next section.

The \method{match}{QAbstractItemModel} method can be used to return
items in a column that match a specific string for a given role. The
column is specified by a model index and the role by one of the
\qtenumeration{Qt::ItemDataRole} enumeration. The optional third
argument is one of the \qtenumeration{Qt:::MatchFlag} enumeration,
specifying how the matching is to occur. Matches are returned as a
list of indices.

\section{Item Selection}
\label{sec:models}

Selection is likely the most common type of user interaction with
lists and tables. The selection
state is stored in its own data model,
\class{QItemSelectionModel}:
<<qt-mvc-selection-model>>=
selModel <- view$selectionModel()
@
%
This design allows views to synchronize
selection. It also supports views on the selection state, such as a
label indicating how many items are selected, independent of the
particular type of item view.

There are five selection modes for item views: single, extended,
contiguous, multi, and none. These values are defined by the
\qtenumeration{QAbstractItemView::SelectionMode}
enumeration. \qcode{SingleSelection} mode allows only a single item to
be selected at once. \qcode{ExtendedSelection} mode, the default,
supports canonical multiple selection, where a range of items is
selected by clicking the end points while holding the \kbd{Shift} key,
and clicking with the \kbd{Ctrl} key pressed adds arbitrary items to
the selection.  The \qcode{ContiguousSelection} mode disallows the
\kbd{Ctrl} key behavior. To allow selection on mouse-over, with range
selection by clicking and dragging, choose \qcode{MultiSelection}. We
configure our list view for single selection:
<<qt-mvc-selection-set-mode>>=
listView$selectionMode <- Qt$QAbstractItemView$SingleSelection
@ 
% 

<<qt-mvc-selection-set-initial, echo=FALSE>>=
selModel$select(model$index(2, 0), Qt$QItemSelectionModel$Select)
@

We can query the selection model for the selected items in our
list. Let us assume that we have selected the third row in our
list. We retrieve the data (label) in that row:
<<qt-mvc-selection-get-indices>>=
indices <- selModel$selectedIndices()
indices[[1]]$data()
@ 

<<qt-mvc-selection-multiple-set-initial, echo=FALSE>>=
sel <- Qt$QItemSelection()
sel$select(model$index(3, 0), model$index(5, 0))
sel$select(model$index(10, 0), model$index(16, 0))
sel$select(model$index(20, 0), model$index(24, 0))
selModel$select(sel, Qt$QItemSelectionModel$Select)
@

When multiple selection is allowed, we must take care to interpret the
selection efficiently, especially if a table has many rows. In the
above, we obtained the selected indices. A selection is more formally
represented by a \class{QItemSelection} object, which is a list of
\class{QItemSelectionRange} objects. Under the assumption that the
user has selected three separate ranges of items from the list view,
we retrieve the selection from the selection model:
<<qt-mvc-selection-get>>=
selection <- selModel$selection()
@ 
%
Next, we coerce the \class{QItemSelection} to an explicit list of
\class{QItemSelectionRange} objects and generate a vector of the
selected indices:
<<qt-mvc-selection-as-list>>=
indicesForSelection <- function(selection) {
  selRanges <- as.list(selection)
  unlist(lapply(selRanges, function(range) seq(range$top(), range$bottom())))
}
indicesForSelection(selection)
@ 
%
Coercion with \function{as.list} is possible for any class extending
\class{QList}; \class{QItemSelection} is the only such class the
reader is likely to encounter. Usually, the user selects a relatively
small number of ranges, although the ranges may be wide. Looping
over the ranges, but not the individual indices, will be
significantly more efficient for large selections.

It is also possible to programmatically change the selection.  For
example, we may wish to select the first list item:
<<qt-mvc-selection-set-current>>=
listView$setCurrent(model$index(0, 0))
@ 
%
This approach is simple but only supports selecting a single item.
The selection is most generally modified by calling the
\method{select}{QItemSelectionModel} method on the selection model:
<<qt-mvc-selection-select>>=
selModel$select(model$index(0, 0), Qt$QItemSelectionModel$Select)
@ 
% 
The second argument describes how the selection is to be changed with
regard to the index. It is a flag value and thus can specify several
options at once, all listed in
\qtenumeration{QItemSelectionModel::SelectionFlags}. In the above, we
issued the \qcode{Select} command. Other commands include
\qcode{Deselect} and \qcode{Toggle}. Thus, we could deselect the item
in similar fashion:
<<qt-mvc-selection-deselect>>=
selModel$select(model$index(0, 0), Qt$QItemSelectionModel$Deselect)
@ 
%
To efficiently select a range of items, we construct a
\class{QItemSelection} object and set it on the model:
<<qt-mvc-selection-multiple-set-initial, echo=FALSE>>=
sel <- Qt$QItemSelection(model$index(3, 0), model$index(10, 0))
selModel$select(sel, Qt$QItemSelectionModel$Select)
@
%
We have selected items $3$ to $10$. Multiple ranges may be added to
the \class{QItemSelection} object by calling its
\method{select}{QItemSelection} method.

For tabular views, selection may be row-wise, column-wise or item-wise
(\GTK{} supports only row-wise selection). By default, selection is by
item. While this is common in spreadsheets, one usually desires
row-wise selection in a table, so we will override the default:
<<qt-mvc-selection-set-behavior>>=
tableView$selectionBehavior <- Qt$QAbstractItemView$SelectRows
@ 
%
<<qt-mvc-selection-select-row, echo=FALSE>>=
tableView$selectRow(1)
tableView$selectRow(2)
@ 
% 
Querying a selection is essentially the same as for the list
view, except we can request indices representing entire rows or
columns. In this example, we are interested in the rows, where the
user has selected the second and third rows:
<<qt-mvc-selection-get-rows>>=
selModel <- tableView$selectionModel()
sapply(selModel$selectedRows(), qinvoke, "row")
@
%
We invoke the \method{row}{QModelIndex} method on each returned
\class{QModelIndex} object to get the row indices.
When setting the selection, there are conveniences for selecting
an entire row or column. We select the first row of the table:
<<qt-mvc-selection-select-row>>=
tableView$selectRow(0)
@ 
%
Selecting a range of rows is very similar to selecting a range of list
items, except we need to add the \qcode{Rows} selection flag:
<<qt-mvc-selection-select-rows>>=
selModel$select(sel, Qt$QItemSelectionModel$Select | 
                Qt$QItemSelectionModel$Rows)
@ 

To respond to a change in selection, connect to the
\signal{selectionChanged} signal on the selection model:
<<qt-mvc-selection-changed>>=
selectedIndices <- rep(FALSE, nrow(mtcars))
selectChangedHandler <- function(selected, deselected) {
  selectedIndices[indicesForSelection(selected)] <<- TRUE
  selectedIndices[indicesForSelection(deselected)] <<- FALSE
}
qconnect(selModel, "selectionChanged", selectionChangedHandler)
@ 
%
The change in selection is communicated as two 
\class{QItemSelection} objects: one for the selected items, the other
for the deselected items.  We update a vector of the selected
indices according to the change.

%% Does not seem to add very much
% \begin{example}{Selection of variables}{eg:qt-selection-from-tablewidget}
%   \SweaveInput{ex-qt-table-selection}
% \end{example}

\section{Sorting and Filtering}

One of the benefits of the MVC design is that models can serve as
proxies for other models. Two common applications of proxy models are
sorting and filtering. Decoupling the sorting and filtering from the
source model avoids modifying the original data. The filtering and
sorting is dynamic, in the sense that no data is actually stored in
the proxy. The proxy delegates to the child model, while mapping
indices between the filtered and unfiltered (or sorted and unsorted)
coordinate space. Thus, there is little cost in memory.

\Qt{} implements both sorting and filtering in a single class:
\class{QSortFilterProxyModel}. After constructing an instance and
specifying the child model, the proxy model may be handed to a view
like any other model:
<<qt-mvc-proxy>>=
proxy <- Qt$QSortFilterProxyModel()
proxy$setSourceModel(model)
tableView$setModel(proxy)
listView$setModel(proxy)
@ 
%
Our views will now draw data through the proxy, rather than from
the original model.

Both table and tree views provide an interface for the user to sort
the underlying model. The user clicks on a column header to sort by
the corresponding column.  Clicking multiple times toggles the sort
order. This behavior is enabled by setting the
\qtproperty{sortingEnabled} property:
<<qt-mvc-proxy-sort-enable>>=
tableView$sortingEnabled <- TRUE
@ 
%
Since the sort occurs in the model, both the table view and list view
display the sorted data. The sort has been applied to both the table
and list view. It is also possible to sort programmatically by calling
the \method{sort}{QAbstractItemModel} method, passing the index of the
sort column. We sort our data by the \qcode{mpg} variable:
<<qt-mvc-proxy-sort>>=
proxy$sort(1)
@ 
%
The built-in sorting logic understands basic data types like strings
and numbers. Customizing the sorting requires overriding the
\method{lessThan}{QSortFilterProxyModel} virtual method in a new
class.

\class{QSortFilterProxyModel} supports filtering by row. The column
indicated by the \qtproperty{filterKeyColumn} property is matched
against a string pattern. Only rows with a matching value in the key
column are allowed past the filter. The pattern is a \class{QRegExp},
which supports several different syntax forms, including: fixed
strings, wildcards (globs), and regular expressions. For example, we
can filter for cars made by Mercedes:
<<qt-mvc-proxy-filter>>=
proxy$filterKeyColumn <- 0
proxy$filterRegExp <- Qt$QRegExp("^Merc")
@ 
%
This approach should satisfy the majority of use cases. To achieve
more complex filtering, including filtering of columns, subclassing is
necessary. 

It is also possible to hide rows and columns at the view by calling
\method{setColumnHidden}{QTableView} or
\method{setRowHidden}{QTableView}. For example, we hide the
\qcode{Price} column:
<<qt-mvc-table-hidden>>=
tableView$setHidden(4, TRUE)
@ 
%
For row filtering, the proxy model approach is usually preferable to
hiding view rows, as the filtering will apply to all views of the
data.

\section{Decorating Items}

Thus far, we have only considered the display of plain text in item
views. To move beyond this, the model needs to communicate extra
rendering information to the view. With \GTK{}, this information is
stored in extra columns, which are mapped to visual properties. Unlike
\GTK{}, however, \Qt{} does not require every cell in a column to have
the same rendering strategy or even the same type of data. Thus, \Qt{}
stores rendering information at the item level. An item is actually
a collection of data elements, each with a unique \textit{role}
identifier. The mapping of roles to visual properties depends on the
\class{QItemDelegate} associated with the item. The default item
delegate, \class{QStyledItemDelegate}, understands most of the standard
roles listed in the \qtenumeration{Qt::ItemDataRole} enumeration.

For example, when we create a \class{DataFrameModel}, the default
behavior is to associate the data frame values with the
\qtenumeration{Qt\$DisplayRole}.  \class{QStyledItemDelegate} (and its
extension \class{RTextFormattingDelegate}) convert the value to a
string for display. Other roles control aspects like the background
and foreground colors, the font, and the decorative icon, if any.

\class{DataFrameModel} supports role-specific values for each item,
\qcode{useRoles = TRUE} is passed to the constructor. It is then up to
the programmer to indicate the mapping from a data frame column to a
column and role in the model. The mapping is encoded in the column
names. Each column name should have the syntax \qcode{[.NAME][.ROLE]},
where \qcode{NAME} indicates the column name in the model and
\qcode{ROLE} refers to a value in \qtenumeration{Qt::ItemDataRole},
without the \qcode{Role} suffix. If the column name does not contain a
period (i.e., there is no \qcode{ROLE}), the display role is assumed.
For example, we could shade the background of the first column, the
makes and models, in gray:
<<qt-mvc-role-background>>=
qdataFrame(model)$.makeAndModel.background <- list(qcolor("gray"))
@ 
%
In the above, we store a list of \class{QColor} instances in our data
frame. As a side note, if we had added that column in a call
to \qcode{data.frame} or \function{cbind}, it would have been
necessary to wrap the list with \qcode{I()} in order to prevent
coercion of the list to a data frame.

The set of supported data types for each role depends on the
delegate. For delegates derived from \class{QStyledItemDelegate}, see
\qcode{qhelp(QStyledItemDelegate)}.  Due to implicit conversion in the
internals of \Qt{}, the number of possible inputs is much greater than
those explicitly documented. For example, the \qcode{background} role
demonstrated above formally accepts a \class{QBrush} object, while
implicit conversion allows types such as \class{QColor} and
\class{QGradient}.

It is possible for a single data frame column to specify the values
for a particular role across multiple model columns. This is useful,
for example, when modifying the font uniformly across several columns
of interest. Here, we bold the \qcode{mpg} and \qcode{hp} columns:
<<qt-mvc-role-multi-font>>=
qdataFrame(model)$.mpg.hp.font <- list(qfont(weight = Qt$QFont$Bold))
@ 
%
As shown, periods separate the data frame column names in the
\qcode{NAME} component. To apply a column to all columns in the model,
omit the column name:
<<qt-mvc-role-all-font>>=
qdataFrame(model)$.font <- list(qfont(pointsize = 14))
@ 

For models other than \class{DataFrameModel}, one sets data for a
specific role by passing the optional \argument{role}{setData}
argument to \method{setData}{QAbstractItemModel}. The value of
\argument{role}{setData} defaults to \qcode{EditRole}, meaning that
the data is in an editable form. We create a list view and set the
background of the first item to yellow:
<<qt-mvc-role-set-data>>=
listModel <- Qt$QStringListModel(rownames(mtcars))
listModel$setData(listModel$index(0, 0), "yellow", Qt$Qt$BackgroundRole)
listView <- Qt$QListView()
listView$setModel(listModel)
@ 
%

<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\code{DisplayRole}", "How data is displayed (\\class{QString})"),
            c("\\code{EditRole}", "Data for editing (\\class{QString})"),
            c("\\code{ToolTipRole}", "Displayed in tooltip (\\class{QString})"),
            c("\\code{StatusTipRole}", "Displayed in status bar (\\class{QString})"),
            c("\\code{SizeHintRole}", "Size hint for views (\\class{QSize})"),
            c("\\code{DecorationRole}", " (\\class{QColor}, \\class{QIcon}, \\class{QPixmap})"),
            c("\\code{FontRole}", "Font for default delegate (\\class{QFont})"),
            c("\\code{TextAlignmentRole}", "Alignment for default delegate (\\qtenumeration{Qt::AlignmentFlag})"),
            c("\\code{BackgroundRole}", "Background for default delegate (\\class{QBrush})"),
            c("\\code{ForegroundRole}", "Foreground for default delegate (\\class{QBrush})"),
            c("\\code{CheckStateRole}", "Indicates checked state of item (\\qtenumeration{Qt::CheckState})")
            )
colnames(df) <- c("Constant","Description")
cat(booktabs(df,
             colTypes=c("l","p{0.7\\textwidth}"),
             caption="Partial list of roles that an item can hold data for and the class of the data.",
             label="tab:qt:enum:itemDataRole"))
@

\section{Displaying Hierarchical Data}

Hierarchical data often arises when splitting a tabular dataset by
some combination of factors. For our demonstration, we will display
in a tree the result of splitting the \code{Cars93} dataset by
manufacturer.

In \Qt{}, hierarchical data is generally stored in
\class{QStandardItemModel}, the primary implementation of
\class{QAbstractItemModel} built into \Qt. 

The first step of our demonstration is to create the model, with the
same number of rows as the \code{Cars93} dataset and a single column
for the car model name:
<<qt-mvc-standard-item-model>>=
treeModel <- Qt$QStandardItemModel(nrow(Cars93), 1)
@ 
%
We need to create an item for each manufacturer, and store the
corresponding records as its children:
<<qt-mvc-standard-item-set-item, result=FALSE>>=
by(Cars93, Cars93$Manufacturer, function(df) {
  manufacturer <- treeModel$index(treeModel$rowCount(), 0)
  treeModel$setData(manufacturer, df$Manufacturer[1])
  sapply(df$Model, function(modelName) {
    record <- treeModel$index(manufacturer$rowCount(), 0, manufacturer)
    treeModel$setData(record, modelName)
  })
})
@
%
As before, we need to create a \class{QModelIndex} object for accessing
each cell of the model. The parent index is passed as the third
argument of the \function{index} call when creating the child index,
\code{record}. This nested loop approach to populating a model is much
less efficient than converting a \class{data.frame} to a
\class{DataFrameModel}, but it is necessary to communicate the
hierarchical information.

In addition to implementing the \class{QAbstractItemModel} interface,
\class{QStandardItemModel} also represents an item as a
\class{QStandardItem} object. Many operations, including inserting,
removing and manipulating children, may be performed on a
\class{QStandardItem}, instead of directly on the model. This may be
convenient in some circumstances.
%% probably all I will say about that

The \Rclass{QTreeView} widget displays the data in a table, with the
conventional buttons on the left for expanding and collapsing
nodes. We create an instance and set the model: 
<<qt-mvc-tree-view>>=
treeView <- Qt$QTreeView()
treeView$setModel(treeModel)
@ 
%
The \qcode{treeView} object is now ready to display the data in a GUI.

%% FIXME: port to QTreeView
\begin{example}{A workspace browser}{eg:qt-workspace-browser}
  \SweaveInput{ex-qt-treewidget}
\end{example}

\section{Model-based combo boxes}
\label{sec:qt-mvc-combo}

Combo boxes were previously introduced as containers of string items
and accompanying icons. The high-level API is sufficient for most use
cases; however, it is beneficial to understand that a combo box
displays its popup menu with a \class{QListView}, which is based on a
\class{QStandardItemModel} by default. It is possible to provide a
custom data model for the list view. Explicitly leveraging the MVC
pattern with a combo box affords greater aesthetic control and
facilitates synchronizing the items with other views.

For example, we can create a combo box that lists the same cars that
are present in our table and list views:
<<qt-mvc-combo-box>>=
comboBox <- Qt$QComboBox()
comboBox$setModel(model)
@ 
By default, the first column from the model is displayed; this is
controlled by the \qtproperty{modelColumn} property.

\section{User Editing of Data Models}

Some data models, including \class{DataFrameModel},
\class{QStringListModel} and \class{QStandardItemModel} support
modification of their data. To determine whether an item may be
edited, call the \function{flags} method on the model, passing the
index of the item, and check for the \code{ItemIsEditable} flag:
<<qt-mvc-check-editable>>=
(treeModel$index(0, 0)$flags() & Qt$ItemIsEditable) > 0
@ 

To enable editing on a column in a \class{DataFrameModel}, it is
necessary to specify the \code{edit} role for the column. For example,
we might add a logical column named \code{Analyze} to the
\code{mtcars} data frame for indicating whether a record should be
included in an analysis. We prefix \code{edit} to the column name, so
that the user can change its value between \code{TRUE} and
\code{FALSE}:
<<qt-mvc-edit-analyze>>=
df <- mtcars 
df$Analyze.edit <- TRUE
model <- DataFrameModel(df)
@ 

For those models that are mutable, the view may allow the user to edit
the model. By default, derivatives of \class{QAbstractItemView} will
initiate editing of an editable column upon double mouse button click
or a key press. This is controlled by the \qtproperty{editTriggers}
property, which accepts a combination of
\qtenumeration{QAbstractItemView::EditTrigger} flags. For example, we
could disable editing through a view:
<<qt-mvc-edit-trigger>>=
view$editTriggers <- Qt$QAbstractItemView$NoEditTriggers
@ 

When editing is requested, the view will pass the request to the
delegate for the item. The standard item delegate,
\class{QStyledItemDelegate}, will present an editing widget created by
its instance of \class{QItemEditorFactory}. The default item editor
factory will create a combo box for logical data, a spin box for
numeric data, and a text edit box for character data. Other types of
data, like times and dates, are also supported. To specify a custom
editor widget for some data type, it is necessary to subclass
\class{QItemEditorCreatorBase} and register an instance with the
item editor factory.

\section{Drag and Drop in Item Views}
\label{sec:qt-mvc-dnd}

The item views have native support for drag and drop. All of the
built-in models, as well as \class{DataFrameModel}, communicate data
in a common format so that drag and drop works automatically between
views. \class{DataFrameModel} also provides its data in the R
serialization format, corresponding to the
\qcode{application/x-rlang-transport} MIME type. This facilitates
implementing custom drop targets for items in R. 

Dragging is enabled by setting the
\property{dragEnabled}{QAbstractItemView} property to \qcode{TRUE}:
<<qt-mvc-dnd-dragenabled>>=
view$dragEnabled <- TRUE
@ 
%
Enabling drops is the same as for any other widget, with one addition:
<<qt-mvc-dnd-acceptdrops>>=
view$acceptDrops <- TRUE
view$showDropIndicator <- TRUE
@
%
The second line tells the view to visually indicate where the item
will be dropped. The following enables
moving items within a view, i.e., reordering:
<<qt-mvc-dnd-internalmove>>=
view$dragDropMode <- Qt$QAbstractItemView$InternalMove
@ 
%
However, that will prevent receiving drops from other views, and
dragging to other views will always be a move, not a copy.

Although we have enabled drag and drop on the view, the level of
support actually depends on the model. The supported actions may be
queried with \method{supportedDragActions}{QAbstractItemModel} and
\method{supportedDropActions}{QAbstractItemModel}. The item flags
determine whether an individual item may be dragged or dropped upon.
Most of the built-in models will support both copy and move actions,
when dragging or dropping. \class{DataFrameModel} only supports copy
actions when dragging; dropping is not supported.

\begin{example}{A drag and drop interface to \function{xtabs}}{eg:qt-dnd-table}
  \SweaveInput{ex-qt-dnd-table}
\end{example}

%% MFL: Arguable as to whether we even need to discuss these in depth
\section{Widgets With Internal Models}

While separating the model from the view provides substantial
flexibility, in practice it is often sufficient and slightly more
convenient to manipulate a view with a built-in data model. \Qt{}
provides a set of view widgets with internal models:
\begin{description}
\item[\class{QListWidget}] for simple lists of items,
\item[\class{QTableWidget}] for a flat table and
\item[\class{QTreeWidget}] for a tree table.
\end{description}
In our experience, the convenience of these classes is not worth the
loss in flexibility and other advantages of the model/view design
pattern. \class{QTableWidget}, in particular, precludes the use of
\class{DataFrameModel}, so \class{QTableWidget} is usually not nearly
as convenient or performant as the model-based
\class{QTableView}. Thus, we are inclined to omit a detailed
description of these widgets. However, we will describe
\class{QListWidget}, out of an acknowledgement that displaying a short
simple list of items is a common task in a GUI.

\subsection{Displaying Short, Simple Lists}

\class{QListWidget} is an easy-to-use widget for displaying
a set of items for selection. As with combo boxes, we can populate the
items directly from a character vector through the
\method{addItems}{QListWidget} method:
<<qt-mvc-listwidget-additems>>=
listWidget <- Qt$QListWidget()
listWidget$addItems(state.name)
@ 
%
This saves one line of code compared to populating a \class{QListView}
via a \class{QStringListModel}. To clear a list of its items, call the
\method{clear}{QListWidget} method. Passing an item to
\method{takeItem}{QListWidget} will remove that specific item from the
widget.

The items in a \class{QListWidget} instance are of the
\class{QListWidgetItem} class. New items can be constructed directly
through the constructor:
<<qt-mvc-listwidget-item>>=
item <- Qt$QListWidgetItem("Puerto Rico", listWidget)
@
%
The first argument is the text and the
optional second argument a parent \class{QListWidget}. If no parent is
specified, the the item may be added through the methods
\method{addItem}{QListWidget}, or \method{insertItem}{QListWidget} for
inserting to a specific instance.

To retrieve an item given its index, we call the
\method{item}{QListWidget} method:
<<qt-mvc-listwidget-itemat>>=
first <- listWidget$item(0)
first$getText()
@ 

Many aspects of an item may be manipulated. These roughly correspond
to the built-in roles of items in \class{QAbstractItemModel}. One may
specify the text, font, icon, status and tool tips, and foreground and
background colors.

By default, \class{QListWidget} allows only a single item to be
selected simultaneously. As with other \class{QAbstractItemView}
derivatives, this may be adjusted to allow multiple selection through
the \property{selectionMode}{QAbtractItemView} property:
<<qt-mvc-listwidget-selectionmode>>=
listWidget$selectionMode <- Qt$QListWidget$ExtendedSelection
@ 

We can programmatically select the states that begin with "A":
<<qt-mvc-listwidget-select,results=hide>>=
sapply(grep("^A", state.name), 
       function(i) listWidget$item(i - 1)$setSelected(TRUE))
@
%
The method \method{selectedItems}{QListWidget} will return the
selected items in a list:
<<qt-mvc-listwidget-selected>>=
selected <- listWidget$selectedItems()
sapply(selected, qinvoke, "text")
@ 
%
To handle changes in the selection, connect to
\signal{itemSelectionChanged}:
<<qt-mvc-listwidget-selectionchanged>>=
qconnect(listWidget, "itemSelectionChanged", function() {
  selected <- listWidget$selectedItems()
  selectedText <- sapply(selected, qinvoke, "text")
  message("Selected: ", paste(selectedText, collapse = ", "))
})
@ 

It is often easier for the user to select multiple items by clicking a
check button next to the desired items. The check box is only shown if
we explicitly set the check state of item. The possible values are
\qcode{Checked}, \qcode{Unchecked} or \qcode{PartiallyChecked}. Here,
we set all of the items to unchecked to show the check buttons and
then check the selected items:
<<qt-mvc-listwidget-checked, results=hide>>=
items <- sapply(seq(listWidget$count), function(i) {
  listWidget$item(i - 1)$setCheckedState(Qt$Qt$Unchecked)
})
sapply(selected, function(x) x$setCheckedState(Qt$Qt$CheckedState))
@ 
%
For long lists, this looping will be time consuming. In such cases, it
is likely preferable use \class{QListView}, \class{DataFrameModel} and
the \qcode{CheckedStateRole}.

\begin{example}{Combining a combobox and list widget to select a
    variable name}{eg-qt-select-variable}
  \SweaveInput{ex-qt-select-variable}
\end{example}

\section{Implementing Custom Models}
\label{sec:using-model-with}

\paragraph{Required methods}
The basic implementation of a subclass must provide the methods 
\meth{rowCount}, \meth{columnCount}, and \meth{data}.  The first two
describe the size of the table for any views, the third describes to
the view how to display data for a given role. The signature for the
\meth{data} method is \code{(index, role)}. The \code{index} value, an
instance of \class{QModelIndex}, has methods \meth{row} and
\meth{column}, whereas \code{role} is one of the roles defined in the
\qtenumeration{Qt::ItemDataRole} enumeration. This method should
return the appropriate value for the given role. For example, if one
is displaying numeric data, the \code{display} role might format the
numeric values (showing a fixed number of digits say), yet the
\code{edit} role might display all the digits so accuracy is not
lost. If a role is not implemented, a value of \code{NULL} should be
returned, as this is mapped to a null instance of \class{QVariant}.

One may also implement the \meth{headerData} method to return the
appropriate data to display in the header for a given role. The main
one being \code{Qt\$Qt\$DisplayRole}.

\begin{example}{Using a custom model to edit a data frame}{eg:qt-editable-data}
  \SweaveInput{ex-qt-edit-data-frame}
\end{example}


\paragraph{Editable Models}
For editable models, one must implement the \meth{flags} method to
return a flag containing \code{ItemIsEditable} and the \meth{setData}
method. This has signature \code{(index, value, role)} where
\code{value} is a character string containing the edited value. When a
value is updated, one should call the \meth{dataChanged} method to
notify the views that a portion of the model is changed. This method
takes two indices, together specifying a rectangle in the table.


To provide for resizable tables, \code{Qt} requires one to call some
(of several such) functions so that any connected views can be
notified. For example, an implemented \meth{insertColumns} should call
\meth{beginInsertColumns} before adding the column to the model and
then \meth{endInsertColumns} just after. 

\section{Implemeting Custom Views}
\label{sec:custom-views}

One can write a custom view for a model. In the example, we show how
to connect a label's text to the values in a column of a model. The
base class for a view of an item model is
\class{QAbstractItemView}. This class has many methods -- that can be
overridden -- to cover keyboard, mouse, scrolling, selection etc. Here
we focus on just enough for our example.

\begin{example}{A label that updates as a model is updated}{eg:qt-custom-view}
  \SweaveInput{ex-qt-custom-view}
\end{example}

\section{Viewing and Editing Text Documents}
\label{sec:multi-line-text}

Multi-line text is displayed and edited by the \class{QTextEdit}
widget, which is the view and controller for the \class{QTextDocument}
model. \class{QTextEdit} supports both plain and rich text in HTML
format, including images, lists and tables. Although the text is
actually stored in a \class{QTextDocument}, it is usually sufficient
to interact with the \class{QTextEdit} directly:
<<QTextEdit, results=hide>>=
te <- Qt$QTextEdit()
te$setPlainText("The quick brown fox")
te$append("jumped over the lazy dog")
@ 
<<eval=FALSE, echo=FALSE, results=hide>>=
## not shown
te$show(); te$raise()
@ 
<<>>=
te$toPlainText()
@ 

The \signal{textChanged} signal is emitted when the text is changed. 

%% Worth mentioning this, given that we never manipulate the document?
% The \method{document}{QTextEdit} can
% be used to retrieve that document, and \method{setDocument}{QTextEdit}
% to replace it. 

\paragraph{The text cursor}

To manage selections, insert special objects like tables and images,
or apply the full range of formatting options, it is necessary to
interact with a text cursor object, of class \class{QTextCursor}. We
obtain the user-visible cursor and move it to the end of the document:
<<qt-mvc-textedit-cursor>>=
n <- nchar(te$toPlainText())
cursor <- te$textCursor()
cursor$setPosition(n)
te$setTextCursor(cursor)
@ 
%
Manipulating the \Robject{cursor} object does not actually modify the
location and parameters of the cursor on the screen. We need to
explicitly set the modified cursor object on the
\class{QTextEdit}. This behavior is often convenient, because it
allows us to modify arbitrary parts of the document, without affecting
the user cursor.  For example, we could insert an image at the beginning:
<<qt-mvc-textedit-image>>=
cursor$setPosition(0)
cursor$insertImage(system.file("images/ok.gif", package="gWidgets"))
@ 
%
To listen to changes in the cursor position, connect to the
\signal{cursorPositionChanged} signal on the \class{QTextEdit}.

\paragraph{Selections}

Selection is a component of the \class{QTextCursor} state. For plain
text, the selected text is returned by the
\method{selectedText}{QTextCursor} method:
<<qt-mvc-textedit-selection>>=
cursor$selectedText()
@ 
%
The empty string indicates that the user has not selected any text.
The selection spans from the cursor anchor to the cursor
position. Normally, the anchor and cursor are at the same position. To
make a selection, we move the cursor independently of its anchor.
To set the selection to include the first three words of the text, we have:
<<results=hide>>=
cursor <- Qt$QTextCursor(te$document()) ## te$textCursor()
cursor$movePosition(Qt$QTextCursor$Start)
cursor$movePosition(Qt$QTextCursor$WordRight, Qt$QTextCursor$KeepAnchor, 3)
te$setTextCursor(cursor)
@
<<qt-mvc-textedit-selection>>=
cursor$selectedText()
@ 
%
We move the cursor and anchor to the start of the document. Next, we
move the cursor, without the anchor, across the right end of three
words. Finally, we need to commit the modified cursor.

To listen to changes in the selection (according to the user visible
cursor), connect to \signal{selectionChanged}:
<<qt-mvc-textedit-selectionChanged>>=
qconnect(te, "selectionChanged", function() {
  message("Selected text: '", te$textCursor()$selectedText(), "'")
})
@ 
%
The \signal{copyAvailable} signal is largely equivalent, except it
passes a boolean argument indicating whether the selection is non-empty.

\paragraph{Formatting}
By default, the widget will wrap text as entered. For use as a code
editor, this is not desirable. The \property{lineWrapMode}{QTextEdit}
takes values from the enumeration
\qtenumeration{QTextEdit::LineWrapMode} to control this:
<<qt-mvc-textedit-wrap>>=
te$lineWrapMode <- Qt$QTextEdit$NoWrap
@
% 
The \method{setAlignment}{QTextEdit} method aligns the current
paragraph (the one with the cursor) with values from
\qtenumeration{Qt::Alignment}.

\paragraph{Searching}
The \method{find}{QTextEdit} method will search for a given string and
adjust the cursor to select the match. For example, we can search
through a standard typesetting string starting at the cursor point for
the common word ``qui'' as follows:

<<lorumIpsum, echo=FALSE>>=
LoremIpsum <- paste(
"Lorem ipsum dolor sit amet, consectetur adipisicing elit,",
"sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi",
"ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit",
"in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur",
"sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit",
"anim id est laborum.",
"\n",
"Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque",
"laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi",
"architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas",
"sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione",
"voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet,",
"consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et",
"dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum",
"exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi",
"consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam",
"nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?",
sep="\n")
@ 
<<findExample>>=
te <- Qt$QTextEdit(LoremIpsum)          # some text
te$find("qui", Qt$QTextDocument$FindWholeWords)
te$textCursor()$selection()$toPlainText()
@
%
The second parameter to \method{find}{QTextEdit} takes a combination
of flags from \qtenumeration{QTextDocument::FindFlag}, with values
\qcode{FindBackward}, \qcode{FindCaseSensitively} and
\qcode{FindWholeWords}.

%% FIXME: should we move this after the application window stuff?
\begin{example}{A tabbed text editor}{ex-qt-tabbed-text-edit}
  \SweaveInput{ex-qt-tabbed-editor.Rnw}
\end{example}

%% FIXME: should we move this after the application window stuff?
\paragraph{Context menus}
Like any other widget, one can enable a context menu based on the
actions associated with the widget. However, it is often necessary to
tailor the context menu, depending on the state of the widget. For our
demonstration, we aim to list candidate completions based on the
currently selected text. This requires a subclass that overrides the
\method{contextMenuEvent}{QWidget} method:
<<QTextEditWithMenu,results=hide>>=
qsetClass("QTextEditWithCompletions", Qt$QTextEdit)
#
qsetMethod("contextMenuEvent", QTextEditWithCompletions, function(e) {
  m <- this$createStandardContextMenu()
  if(this$textCursor()$hasSelection()) {
    selection <- this$textCursor()$selectedText()
    comps <- utils:::matchAvailableTopics(selection)
    comps <- setdiff(comps, selection)
    if(length(comps) > 0 && length(comps) < 10) {
      m$addSeparator()                  # add actions
      sapply(comps, function(i) {
        a <- Qt$QAction(i, this)
        qconnect(a, "triggered", function(checked) {
          insertPlainText(i)
        })
        m$addAction(a)
      })
    }
  }
  m$exec(e$globalPos())
})
te <- QTextEditWithCompletions()
@ 
%
The \method{createStandardContextMenu}{QTextEdit} method returns the
base context menu, including functions like copy and paste. We add an
action for every possible completion. Triggering an action will paste
the completion into the document.

<<raise, eval=FALSE, echo=FALSE, results=hide>>=
te$show()
te$raise()
@ 



<<eval=FALSE, echo=FALSE, results=hide>>=
## Not shown

##' start with command, return output in HTML
runCommand <- function(chunk) {
  require(R2HTML)
  f <- tempfile()
  chunkexps <- try(parse(text=chunk), silent=TRUE)
  if(inherits(chunkexps, "try-error")) 
  stop("Error")
  
  out <- ""
  for(i in seq_along(chunkexps)) {
    chunk <- chunkexps[[i]]
    out <- paste(out, "<h3>", paste(capture.output(chunk), collapse="<br>"), "</h3><br />",  sep="")
    HTML(eval(chunk), file=f, append=FALSE)
    out <- paste(out, paste(readLines(f, warn=FALSE), collapse="<br>"), sep="")
  }
  out
}




w <- Qt$QGroupBox("Simple CLI")
lyt <- Qt$QGridLayout()
w$setLayout(lyt)

cli <- Qt$QLineEdit()
out <- Qt$QTextEdit()


lyt$addWidget(Qt$QLabel("Command:"), 0, 0)
lyt$addWidget(cli, 0, 1)
lyt$addWidget(Qt$QLabel("Output:"), 1, 0, Qt$Qt$AlignTop)
lyt$addWidget(out, 1, 1)

lyt$setRowStretch(1,1)
lyt$setColumnStretch(1,1)

qconnect(cli, "editingFinished", function() {
  chunk <- cli$text
  htmlized <- runCommand(chunk)
  out$setHtml(htmlized)
  cli$setFocus(Qt$Qt$ActiveWindowFocusReason)
  cli$setSelection(0, nchar(cli$text))
})

w$setMinimumSize(800,400)
w$show()
w$raise()

@ 
