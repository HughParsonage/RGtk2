%%  widgets using MVC framework
<<echo=FALSE>>=
require(qtbase)
require(MASS)
@ 

The model, view, controller (MVC) pattern is fundamental to the design
of widgets that display and manipulate data. Keeping the model
separate from the view allows multiple views for the same
data. Generally, the model is an abstract interface. Thus, the same
view and controller components are able to operate on any data source
(e.g., a database) for which a model implementation exists.

\Qt{} provides \class{QAbstractItemModel} as the base for all of its
data models. Like \class{GtkTreeModel}, \class{QAbstractItemModel}
represents tables, optionally with a hierarchy. The precise
implementation depends on the subclass. Widgets that view item models
extend \class{QAbstractItemView} and include tables, lists, trees and
combo boxes. This section will outline the available model
and view implementations in \Qt{} and \pkg{qtbase}.

\section{Display of tabular data}

\subsection{Displaying an R data frame}
\label{sec:qt:mvc:table:basics}

As mentioned, \Qt{} expects data to be stored in a
\class{QAbstractItemModel}. In \R, the canonical structure for tabular
data is \class{data.frame}. The \class{DataFrameModel} class bridges
these structures by wrapping \class{data.frame} in an implementation
of \class{QAbstractItemModel}. This essentially allows a
\class{data.frame} object to be passed to any part of \Qt{} that
expects tabular data. It also offers significant performance benefits:
there is no need to copy the data frame into a C++ data structure,
which would be especially slow if the looping occurred in
\R. Displaying a simple table of data with \class{DataFrameModel} is
much simpler than with \GTK{} and \class{RGtkDataFrame}. Here we
show a \class{data.frame} in a table view:
<<qt-mvc-qdfm,print=false>>=
data(mtcars)
model <- qdataFrameModel(mtcars)
view <- Qt$QTableView()
view$setModel(model)
@ 
%
We could also pass our model to any other view expecting a
\class{QAbstractItemModel}. For example, the first column could be
displayed in a list or combo box.

The \class{DataFrameModel} object is a reference, so any changes are
reflected in all of its views. The \R{} data frame of a
\class{DataFrameModel} may be accessed using
\function{qdataFrame}:
<<qt-mvc-qdfm-access>>=
head(qdataFrame(model), 3)
qdataFrame(model)$hpToMpg <- with(qdataFrame(model), hp / mpg)
@ 
% 
Our table view now contains a new column, holding the horsepower to
miles per gallon ratio. It is important to notice that the view has
been updated implicitly, through manipulation of the underlying model.

A view has a horizontal and vertical header. The horizontal header
displays the column names, while the vertical header displays the row
names, if any. \class{QHeaderView} is the widget responsible for
displaying headers. It has a number of parameters, such as whether the
column may be moved (\method{setMovable}{QHeaderView}) and the
\property{defaultAlignment}{QHeaderView} of the labels, which, as we
will see later, can be overridden by the model for specific
columns. By default, the labels are centered. Here, we specify left
alignment for the column labels:
<<qt-mvc-table-header-align>>=
header <- view$horizontalHeader()
header$defaultAlignment <- Qt$AlignLeft
@ 

\class{QTableView} provides a number of aesthetic features. By
default, a grid is drawn that delineates the cells. One can set
\property{showGrid}{QTableView} to \qcode{FALSE} to disable this. If a
table has more than a few columns, it may be a good idea to fill the
row backgrounds with alternating colors:
<<qt-mvc-table-alternating>>=
view$alternatingRowColors <- TRUE
@ 

\subsection{Memory management}
\label{sec:qt:mvc:table:gc}

A view keeps a reference to its model, and the
\method{model}{QAbstractItemView} method returns the model
object. However, we offer a word of caution: since multiple views can
refer to a single model, a view does not own its model. This means
that if a model becomes inaccessible to R, i.e., it goes out of scope,
the model will be garbage collected, from lack of an owner. For
example, this does not work:
<<qt-mvc-table-gc,print=false>>=
brokenView <- Qt$QTableView()
brokenView$setModel(qdataFrameModel(mtcars))
gc()
@ 
<<qt-mvc-table-gc-result>>=
brokenView$model()
@ 
% 
To prevent this, one should either (1) maintain a reference to the
model in R, which we typically do in this text, or (2) explicitly give
the view ownership of the model by setting the view as the parent of
the model, like this:
<<qt-mvc-table-parent,print=false>>=
parentalView <- Qt$QTableView()
brokenView$setModel(qdataFrameModel(mtcars, parent = parentalView))
gc()
@ 
<<qt-mvc-table-parent-result>>=
brokenView$model()
@ 

\subsection{Formatting cells}
\label{sec:qt:mvc:table:formatting}

Let us now assume that a missing value (\code{NA}) has been introduced
into our dataset:
<<qt-mvc-qdf-na>>=
qdataFrame(model)$mpg[1] <- NA
@ 
%
The table view will display this as "nan" or "inf", which is
inconsitent with the notation of \R. The conversion of the numeric
data to text is carried out by an \textit{item delegate}. Similar to a
\GTK{} cell renderer, an item delegate is responsible for the
rendering and editing of items (cells) in a view. Every type of item
delegate is derived from the \class{QAbstractItemDelegate} class. By
default, views in \Qt{} will use an instance of
\class{QStyledItemDelegate}, which renders items according to the
current style. As \Qt{} is unaware of the notion and encoding of
missing values in \R, we need to give \Qt{} extra guidance. The
\pkg{qtbase} package provides the \class{RTextFormattingDelegate}
class for this purpose. To use it, one creates an instance and sets it
as the item delegate for the view:
<<qt-mvc-rtfd>>=
delegate <- qrTextFormattingDelegate()
view$setItemDelegate(delegate)
@ 
Delegates may also be assigned on a per column or per row
basis. \class{RTextFormattingDelegate} will handle missing values in
numeric vectors, as well as adhere to the numeric formatting settings
in \function{options()}, namely \qcode{digits} and \qcode{scipen}.

\subsection{Column sizing}
\label{sec:qt:mvc:table:headers}

Managing the column widths of a table view is a challenge. This
section will describe some of the strategies and suggest some best
practices. The appropriate strategy depends, in part, on whether the
table is expanding in its container.

When the table view is expanding, it will not necessarily fill its
available space. To demonstrate,
<<qt-mvc-table-embedded, results=hide>>=
model <- qdataFrameModel(mtcars[,1:5])
view <- Qt$QTableView()
view$setModel(model)
wid <- Qt$QWidget()
wid$resize(1000, 500)
vbox <- Qt$QVBoxLayout()
vbox$addWidget(view)
wid$setLayout(vbox)
@
%
There is a gap between the last column and the right side of the
window.  It is difficult to appropriately size the columns of an
expanding table.  The simplest solution is to expand the last column:
<<qt-mvc-table-stretchLast>>=
header <- view$horizontalHeader()
header$stretchLastSection <- TRUE
@
%
To avoid the last column from being too large, we can set pixel widths
on the other columns. The simplest approach is to set the
\property{defaultSectionSize}{QHeaderView} property, which gives all
of the columns the same initial size (except for the last):
<<qt-mvc-table-defaultSectionSize>>=
header$defaultSectionSize <- 150
header$stretchLastSection <- TRUE
@
%
This usually yields an appropriate initial sizing. To resize specific
columns, we could call \method{resizeSection}{QHeaderView}. Although
specifying exact pixel sizes is inherently inflexible, the user is
still free to adjust the column widths.

If, instead, one wishes to pack a table, so that it is not expanding,
it may be desirable to initialize the column widths so that the
columns optimally fit their contents:
<<qt-mvc-table-fit>>=
view$resizeColumnsToContents()
@ 
%
This will need to be called each time the contents change.

By default, the size is always under control of the user (and the
programmer). This depends on the resize mode. The
\property{resizeMode}{QHeaderView} property represents the default
resize mode for all columns, and it defaults to
\qcode{Interactive}. The other modes are \qcode{Fixed},
\qcode{Stretch} (expanding), and \qcode{ResizeToContents} (constrained
to width needed to fit contents). The \method{setResizeMode} method
changes the resize mode of a specific column.  Below, we make all of
our columns expand:
<<qt-mvc-table-stretch>>=
header$resizeMode(Qt$QHeaderView$Stretch)
@ 
%
The drawback to any of these modes is that the resizing is no longer
interactive; the user cannot tweak the column widths.

When the size of a column is reduced such that it can no longer
naturally display its contents, special logic is necessary. By
default, \class{QTableView} will wrap text at word boundaries. This is
controlled by the \property{wordWrap}{QTableView} property. When a
single word is too long, the text will be ellipsized, i.e., truncated
and appended with ``...''. This can be disabled with
<<qt-mvc-table-elide>>=
view$textElideMode <- Qt$Qt$ElideNone
@ 
%
When the user attempts to reduce the size of a column to the point
where ellipisizing would be necessary, it may be preferable to instead
reduce the widths of the other columns. This mode is enabled with
<<qt-mvc-table-cascade>>=
header$cascadingSectionResizes <- TRUE
@ 

\section{Displaying Lists}
\label{sec:displaying-lists}

%% It is debatable as to whether QListWidget would be more convenient
%% than a QListView backed by either QStringListModel or
%% DataFrameModel, especially since we have already explained the
%% latter. Getting data onto the screen takes about one more line with
%% the model interfaces. Interpreting user interaction (selection) is
%% about the same level of complexity. The View classes will yield
%% QModelIndex objects, the Widget classes yield WidgetItem
%% objects. QModelIndex only has to be described once, and offers some
%% advantages, like always yielding a row/column index, which is nice
%% for indexing into other data structures. While the Widgets offer
%% some high-level conveniences (like icons in a QListWidget),
%% for large lists it would be too slow to configure each widget
%% item. Much faster to just use roles in a DataFrameModel.


It is often desirable to display a list of items, usually as text. A
single column \class{QTableView} approximates this but also includes
row and column headers, by default. Also, the two dimensional API of
\class{QTableView} is more complicated than needed for a one
dimensional list. For these and other reasons, \Qt{} provides
\class{QListView} for displaying a single column from a
\class{QAbstractItemModel} as a list. We can use
\class{DataFrameModel} to quickly display the first column from a data
frame (or anything coercible into a data frame):
<<qt-mvc-lists-df, print=false>>=
model <- qdataFrameModel(rownames(mtcars))
view <- Qt$QListView()
view$setModel(model)
@
%
By default, \class{QListView} displays the first column from the
model, although the column index can be customized. 

Using a data model allows us to share data between multiple views. For
example, we could view a data frame as a table using a
\class{QTableView} and also display the row identifiers in a separate
list:
<<qt-mvc-lists-combo>>=
mtcars.id <- cbind(makeAndModel = rownames(mtcars), mtcars)
model <- qdataFrameModel(mtcars.id)
tableView <- Qt$QTableView()
tableView$setModel(model)
listView <- Qt$QListView()
listView$setModel(model)
@ 
%
Now, when we resort the model, both views will be updated:
<<qt-mvc-lists-sort>>=
df <- qdataFrame(model)
qdataFrame(model) <- df[order(df$mpg),]
@ 

When the list items are not associated with a data frame, they may be
conveniently represented as a character vector. In this case,
\class{DataFrameModel} is not very appropriate, as the character
vector will be coerced to a data frame. Instead, consider
\class{QStringListModel} from \Qt. In \pkg{qtbase},
\class{QStringList} refers to a character vector. We demonstrate
the use of \class{QStringListModel} to populate a list view from a
character vector:
<<qt-mvc-lists-qslm>>=
model <- Qt$QStringListModel(rownames(mtcars))
listView <- Qt$QListView()
listView$setModel(model)
@ 
%
Now we can retrieve the values as a character vector, rather than as a
data frame:
<<qt-mvc-lists-qslm-retrieve>>=
head(model$stringList)
@ 

\class{QListView} supports features beyond those of a simple list,
including features often found in file browsers and desktops. For
example, items may be wrapped into additional columns, and an icon
mode, supporting unrestricted layout and drag and drop, is also
available.

\section{Accessing Item Models}

We have shown how \class{DataFrameModel} and \class{QStringListModel}
allow the storage and retrieval of data in familiar data
structures. However, this is not true of all data models, including
most of those in \Qt. Alternative models are required, for example, in
the case of hierarchical data. In such cases, or when interpreting
user input, such as selection, it is necessary to interact with the
low-level, generic API of the item/view framework.

An item model refers to its rows, columns and cells with
\class{QModelIndex} objects, which are created by the model:
<<qt-mvc-model-index-create>>=
index <- model$index(0, 0)
index$row()
index$column()
@ 
% 
Our \qcode{index} refers to the first row of the
\class{QStringListModel}, using $0$-based indices.
The index points to a cell in the model, and we can retrieve the data
in the cell using only the index:
<<qt-mvc-model-index-data>>=
firstCar <- index$data()
@ 
%
This can be extended to retrieve all of the items in the list:
<<qt-mvc-model-populate>>=
sapply(seq(model$rowCount()), function(i) model$index(i - 1, 0)$data())
@ 

Setting the data is also possible, yet requires calling
\method{setData}{QAbstractItemModel} on the model, not the index:
<<qt-mvc-model-index-data-set>>=
model$setData(index, toupper(firstCar))
@ 
%
We will leave the population of a model with the low-level API as an
exercise for the reader. Recall that \class{DataFrameModel} and
\class{QStringListModel} provide an interface that is much faster and
more convenient. When using such models, it is usually only necessary
to directly manipulate a \class{QModelIndex} when handling user input,
as we describe in the next section.

%% ML: in my opinion, we can use R for searching data, as long as it
%% is in a native data model. We can put this somewhere, but it
%% doesn't really belong in the basic discussion of QModelIndex.
% The \method{match}{QAbstractItemModel} method returns items in a
% column that match a specific string for a given role. The column is
% specified by a model index and the role by one of the
% \qtenumeration{Qt::ItemDataRole} enumeration. The optional third
% argument is one of the \qtenumeration{Qt:::MatchFlag} enumeration,
% specifying how the matching is to occur. Matches are returned as a
% list of indices.

\section{Item Selection}
\label{sec:models}

Selection is likely the most common type of user interaction with
lists and tables. The selection state is stored in its own data model,
\class{QItemSelectionModel}:
<<qt-mvc-selection-model>>=
selModel <- listView$selectionModel()
@
%
This design allows views to synchronize selection. It also supports
views on the selection state, such as a label indicating how many
items are selected, independent of the particular type of item view.

There are five selection modes for item views: single, extended,
contiguous, multi, and none. These values are defined by the
\qtenumeration{QAbstractItemView::SelectionMode}
enumeration. \qcode{SingleSelection} mode allows only a single item to
be selected at once. \qcode{ExtendedSelection} mode, the default,
supports canonical multiple selection, where a range of items is
selected by clicking the end points while holding the \kbd{Shift} key,
and clicking with the \kbd{Ctrl} key pressed adds arbitrary items to
the selection.  The \qcode{ContiguousSelection} mode disallows the
\kbd{Ctrl} key behavior. To allow selection on mouse-over, with range
selection by clicking and dragging, choose \qcode{MultiSelection}. We
configure our list view for single selection:
<<qt-mvc-selection-set-mode, results=hide>>=
listView$selectionMode <- Qt$QAbstractItemView$SingleSelection
@ 
% 

<<qt-mvc-selection-set-initial, echo=FALSE>>=
selModel$select(model$index(2, 0), Qt$QItemSelectionModel$Select)
@

We can query the selection model for the selected items in our
list. Let us assume that we have selected the third row. We retrieve
the data (label) in that row:
<<qt-mvc-selection-get-indices>>=
indices <- selModel$selectedIndexes()
indices[[1]]$data()
@ 

<<qt-mvc-selection-multiple-set-initial, echo=FALSE, results=hide>>=
sel <- Qt$QItemSelection()
sel$select(model$index(3, 0), model$index(5, 0))
sel$select(model$index(10, 0), model$index(16, 0))
sel$select(model$index(20, 0), model$index(24, 0))
selModel$select(sel, Qt$QItemSelectionModel$Select)
@

When multiple selection is allowed, we must take care to interpret the
selection efficiently, especially if a table has many rows. In the
above, we obtained the selected indices. A selection is more formally
represented by a \class{QItemSelection} object, which is a list of
\class{QItemSelectionRange} objects. Under the assumption that the
user has selected three separate ranges of items from the list view,
we retrieve the selection from the selection model:
<<qt-mvc-selection-get>>=
selection <- selModel$selection()
@ 
%
Next, we coerce the \class{QItemSelection} to an explicit list of
\class{QItemSelectionRange} objects and generate a vector of the
selected indices:
<<qt-mvc-selection-as-list>>=
indicesForSelection <- function(selection) {
  selRanges <- as.list(selection)
  unlist(lapply(selRanges, function(range) seq(range$top(), range$bottom())))
}
indicesForSelection(selection)
@ 
%
Coercion with \function{as.list} is possible for any class extending
\class{QList}; \class{QItemSelection} is the only such class the
reader is likely to encounter. Usually, the user selects a relatively
small number of ranges, although the ranges may be wide. Looping
over the ranges, but not the individual indices, will be
significantly more efficient for large selections.

It is also possible to programmatically change the selection.  For
example, we may wish to select the first list item:
<<qt-mvc-selection-set-current>>=
listView$setCurrentIndex(model$index(0, 0))
@ 
%
This approach is simple but only supports selecting a single item.
The selection is most generally modified by calling the
\method{select}{QItemSelectionModel} method on the selection model:
<<qt-mvc-selection-select, results=hide>>=
selModel$select(model$index(0, 0), Qt$QItemSelectionModel$Select)
@ 
% 
The second argument describes how the selection is to be changed with
regard to the index. It is a flag value and thus can specify several
options at once, all listed in
\qtenumeration{QItemSelectionModel::SelectionFlags}. In the above, we
issued the \qcode{Select} command. Other commands include
\qcode{Deselect} and \qcode{Toggle}. Thus, we could deselect the item
in similar fashion:
<<qt-mvc-selection-deselect, results=hide>>=
selModel$select(model$index(0, 0), Qt$QItemSelectionModel$Deselect)
@ 
%
To efficiently select a range of items, we construct a
\class{QItemSelection} object and set it on the model:
<<qt-mvc-selection-multiple-set-initial, echo=FALSE, results=hide>>=
sel <- Qt$QItemSelection(model$index(3, 0), model$index(10, 0))
selModel$select(sel, Qt$QItemSelectionModel$Select)
@
%
We have selected items $3$ to $10$. Multiple ranges may be added to
the \class{QItemSelection} object by calling its
\method{select}{QItemSelection} method.

For tabular views, selection may be row-wise, column-wise or item-wise
(\GTK{} supports only row-wise selection). By default, selection is by
item. While this is common in spreadsheets, one usually desires
row-wise selection in a table, so we will override the default:
<<qt-mvc-selection-set-behavior>>=
tableView$selectionBehavior <- Qt$QAbstractItemView$SelectRows
@ 
%
<<qt-mvc-selection-select-row, echo=FALSE, results=hide>>=
tableView$selectRow(1)
tableView$selectRow(2)
@ 
% 
Querying a selection is essentially the same as for the list
view, except we can request indices representing entire rows or
columns. In this example, we are interested in the rows, where the
user has selected the third row (2):
<<qt-mvc-selection-get-rows>>=
selModel <- tableView$selectionModel()
sapply(selModel$selectedRows(), qinvoke, "row")
@
%
We invoke the \method{row}{QModelIndex} method on each returned
\class{QModelIndex} object to get the row indices.
When setting the selection, there are conveniences for selecting
an entire row or column. We select the first row of the table:
<<qt-mvc-selection-select-row, results=hide>>=
tableView$selectRow(0)
@ 
%
Selecting a range of rows is very similar to selecting a range of list
items, except we need to add the \qcode{Rows} selection flag:
<<qt-mvc-selection-select-rows, results=hide, eval=FALSE>>=
selModel$select(sel, Qt$QItemSelectionModel$Select | 
                Qt$QItemSelectionModel$Rows)
@ 

To respond to a change in selection, connect to the
\signal{selectionChanged} signal on the selection model:
<<qt-mvc-selection-changed, results=hide>>=
selectedIndices <- rep(FALSE, nrow(mtcars))
selectionChangedHandler <- function(selected, deselected) {
  selectedIndices[indicesForSelection(selected)] <<- TRUE
  selectedIndices[indicesForSelection(deselected)] <<- FALSE
}
qconnect(selModel, "selectionChanged", selectionChangedHandler)
@ 
%
The change in selection is communicated as two 
\class{QItemSelection} objects: one for the selected items, the other
for the deselected items.  We update a vector of the selected
indices according to the change.

%% Does not seem to add very much
% \begin{example}{Selection of variables}{eg:qt-selection-from-tablewidget}
%   \SweaveInput{ex-qt-table-selection}
% \end{example}

\section{Sorting and Filtering}

One of the benefits of the MVC design is that models can serve as
proxies for other models. Two common applications of proxy models are
sorting and filtering. Decoupling the sorting and filtering from the
source model avoids modifying the original data. The filtering and
sorting is dynamic, in the sense that no data is actually stored in
the proxy. The proxy delegates to the child model, while mapping
indices between the filtered and unfiltered (or sorted and unsorted)
coordinate space. Thus, there is little cost in memory.

\Qt{} implements both sorting and filtering in a single class:
\class{QSortFilterProxyModel}. After constructing an instance and
specifying the child model, the proxy model may be handed to a view
like any other model:
<<qt-mvc-proxy, results=hide>>=
proxy <- Qt$QSortFilterProxyModel()
proxy$setSourceModel(model)
tableView$setModel(proxy)
listView$setModel(proxy)
@ 
%
Our views will now draw data through the proxy, rather than from
the original model.

Both table and tree views provide an interface for the user to sort
the underlying model. The user clicks on a column header to sort by
the corresponding column.  Clicking multiple times toggles the sort
order. This behavior is enabled by setting the
\qtproperty{sortingEnabled} property:
<<qt-mvc-proxy-sort-enable>>=
tableView$sortingEnabled <- TRUE
@ 
%
Since the sort occurs in the model, both the table view and list view
display the sorted data. The sort has been applied to both the table
and list view. It is also possible to sort programmatically by calling
the \method{sort}{QAbstractItemModel} method, passing the index of the
sort column. We sort our data by the \qcode{mpg} variable:
<<qt-mvc-proxy-sort, results=hide>>=
proxy$sort(1)
@ 
%
The built-in sorting logic understands basic data types like strings
and numbers. Customizing the sorting requires overriding the
\method{lessThan}{QSortFilterProxyModel} virtual method in a new
class.

\class{QSortFilterProxyModel} supports filtering by row. The column
indicated by the \qtproperty{filterKeyColumn} property is matched
against a string pattern. Only rows with a matching value in the key
column are allowed past the filter. The pattern is a \class{QRegExp},
which supports several different syntax forms, including: fixed
strings, wildcards (globs), and regular expressions. For example, we
can filter for cars made by Mercedes:
<<qt-mvc-proxy-filter>>=
proxy$filterKeyColumn <- 0
proxy$filterRegExp <- Qt$QRegExp("^Merc")
@ 
%
This approach should satisfy the majority of use cases. To achieve
more complex filtering, including filtering of columns, subclassing is
necessary. 

It is also possible to hide rows and columns at the view by calling
\method{setColumnHidden}{QTableView} or
\method{setRowHidden}{QTableView}. For example, we hide the
\qcode{Price} column:
<<qt-mvc-table-hidden, results=hide>>=
tableView$setColumnHidden(4, TRUE)
@ 
%
It is common for different views to display different types of
information, which translates to different sets of columns. For row
filtering, the proxy model approach is usually preferable to hiding
view rows, as the filtering will apply to all views of the data.

\section{Decorating Items}

Thus far, we have only considered the display of plain text in item
views. To move beyond this, the model needs to communicate extra
rendering information to the view. With \GTK{}, this information is
stored in extra columns, which are mapped to visual properties. Unlike
\GTK{}, however, \Qt{} does not require every cell in a column to have
the same rendering strategy or even the same type of data. Thus, \Qt{}
stores rendering information at the item level. An item is actually
a collection of data elements, each with a unique \textit{role}
identifier. The mapping of roles to visual properties depends on the
\class{QItemDelegate} associated with the item. The default item
delegate, \class{QStyledItemDelegate}, understands most of the standard
roles listed in the \qtenumeration{Qt::ItemDataRole} enumeration.

For example, when we create a \class{DataFrameModel}, the default
behavior is to associate the data frame values with the
\qtenumeration{Qt\$DisplayRole}.  \class{QStyledItemDelegate} (and its
extension \class{RTextFormattingDelegate}) convert the value to a
string for display. Other roles control aspects like the background
and foreground colors, the font, and the decorative icon, if any.

\class{DataFrameModel} supports role-specific values for each item,
\qcode{useRoles = TRUE} is passed to the constructor. It is then up to
the programmer to indicate the mapping from a data frame column to a
column and role in the model. The mapping is encoded in the column
names. Each column name should have the syntax \qcode{[.NAME][.ROLE]},
where \qcode{NAME} indicates the column name in the model and
\qcode{ROLE} refers to a value in \qtenumeration{Qt::ItemDataRole},
without the \qcode{Role} suffix. If the column name does not contain a
period (i.e., there is no \qcode{ROLE}), the display role is assumed.
For example, we could shade the background of the first column, the
makes and models, in gray:
<<qt-mvc-role-background>>=
mtcars.id <- cbind(makeAndModel = rownames(mtcars), mtcars)
model <- qdataFrameModel(mtcars.id)
qdataFrame(model)$.makeAndModel.background <- list(qcolor("gray"))
@ 
%
In the above, we store a list of \class{QColor} instances in our data
frame. As a side note, if we had added that column in a call
to \qcode{data.frame} or \function{cbind}, it would have been
necessary to wrap the list with \qcode{I()} in order to prevent
coercion of the list to a data frame.

The set of supported data types for each role depends on the
delegate. For delegates derived from \class{QStyledItemDelegate}, see
\qcode{qhelp(QStyledItemDelegate)}.  Due to implicit conversion in the
internals of \Qt{}, the number of possible inputs is much greater than
those explicitly documented. For example, the \qcode{background} role
demonstrated above formally accepts a \class{QBrush} object, while
implicit conversion allows types such as \class{QColor} and
\class{QGradient}.

It is possible for a single data frame column to specify the values
for a particular role across multiple model columns. This is useful,
for example, when modifying the font uniformly across several columns
of interest. Here, we bold the \qcode{mpg} and \qcode{hp} columns:
<<qt-mvc-role-multi-font>>=
qdataFrame(model)$.mpg.hp.font <- list(qfont(weight = Qt$QFont$Bold))
@ 
%
As shown, periods separate the data frame column names in the
\qcode{NAME} component. To apply a column to all columns in the model,
omit the column name:
<<qt-mvc-role-all-font>>=
qdataFrame(model)$.font <- list(qfont(pointsize = 14))
@ 

For models other than \class{DataFrameModel}, one sets data for a
specific role by passing the optional \argument{role}{setData}
argument to \method{setData}{QAbstractItemModel}. The value of
\argument{role}{setData} defaults to \qcode{EditRole}, meaning that
the data is in an editable form. We create a list view and set the
background of the first item to yellow:
<<qt-mvc-role-set-data, results=hide>>=
listModel <- Qt$QStringListModel(rownames(mtcars))
listModel$setData(listModel$index(0, 0), "yellow", Qt$Qt$BackgroundRole)
listView <- Qt$QListView()
listView$setModel(listModel)
@ 
%

<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\code{DisplayRole}", "How data is displayed (\\class{QString})"),
            c("\\code{EditRole}", "Data for editing (\\class{QString})"),
            c("\\code{ToolTipRole}", "Displayed in tooltip (\\class{QString})"),
            c("\\code{StatusTipRole}", "Displayed in status bar (\\class{QString})"),
            c("\\code{SizeHintRole}", "Size hint for views (\\class{QSize})"),
            c("\\code{DecorationRole}", " (\\class{QColor}, \\class{QIcon}, \\class{QPixmap})"),
            c("\\code{FontRole}", "Font for default delegate (\\class{QFont})"),
            c("\\code{TextAlignmentRole}", "Alignment for default delegate (\\qtenumeration{Qt::AlignmentFlag})"),
            c("\\code{BackgroundRole}", "Background for default delegate (\\class{QBrush})"),
            c("\\code{ForegroundRole}", "Foreground for default delegate (\\class{QBrush})"),
            c("\\code{CheckStateRole}", "Indicates checked state of item (\\qtenumeration{Qt::CheckState})")
            )
colnames(df) <- c("Constant","Description")
cat(booktabs(df,
             colTypes=c("l","p{0.7\\textwidth}"),
             caption="Partial list of roles that an item can hold data for and the class of the data.",
             label="tab:qt:enum:itemDataRole"))
@

\section{Displaying Hierarchical Data}

Hierarchical data is generally stored in \class{QStandardItemModel},
the primary implementation of \class{QAbstractItemModel} built into
\Qt.  Hierarchical data often arises when splitting a tabular dataset
by some combination of factors. For our demonstration, we will display
in a tree the result of splitting the \code{Cars93} dataset by
manufacturer. The first step of our demonstration is to create the
model, with a single column:
<<qt-mvc-standard-item-model>>=
treeModel <- Qt$QStandardItemModel(rows = 0, columns = 1)
@ 
%
We need to create an item for each manufacturer, and store the
corresponding records as its children:
<<qt-mvc-standard-item-set-item, results=hide, eval=FALSE>>=
by(Cars93, Cars93$Manufacturer, function(df) {
  treeModel$insertRow(treeModel$rowCount())
  manufacturer <- treeModel$index(treeModel$rowCount()-1L, 0)
  treeModel$setData(manufacturer, df$Manufacturer[1])
  treeModel$insertRows(0, nrow(df), manufacturer)
  treeModel$insertColumn(0, manufacturer)
  for (i in seq_along(df$Model)) {
    record <- treeModel$index(i-1L, 0, manufacturer)
    treeModel$setData(record, df$Model[i])
  }
})
@
%
As before, we need to create a \class{QModelIndex} object for
accessing each cell of the model. We need to add rows and columns to
each manufacturer node before creating its children. This nested loop
approach to populating a model is much less efficient than converting
a \class{data.frame} to a \class{DataFrameModel}, but it is necessary
to communicate the hierarchical information.

In addition to implementing the \class{QAbstractItemModel} interface,
\class{QStandardItemModel} also represents an item as a
\class{QStandardItem} object. Many operations, including inserting,
removing and manipulating children, may be performed on a
\class{QStandardItem}, instead of directly on the model. This may be
convenient in some circumstances. For example, the code listed above
for populating the model becomes:
<<echo=FALSE>>=
treeModel <- Qt$QStandardItemModel(rows = 0, columns = 1)
@ 
<<qt-mvc-standard-item-rewrite, results=hide>>=
by(Cars93, Cars93$Manufacturer, function(df) {
  manufacturer <- Qt$QStandardItem(as.character(df$Manufacturer[1]))
  treeModel$appendRow(manufacturer)
  children <- lapply(as.character(df$Model), Qt$QStandardItem)
  lapply(children, manufacturer$appendRow)
})
@ 
%% probably all I will say about that

The \Rclass{QTreeView} widget displays the data in a table, with the
conventional buttons on the left for expanding and collapsing
nodes. We create an instance and set the model: 
<<qt-mvc-tree-view, results=hide>>=
treeView <- Qt$QTreeView()
treeView$setModel(treeModel)
@ 
%
Often, as in our case, a tree view only has a single column. It may be
desirable to hide that column header with
<<qt-mvc-tree-view-header-hidden>>=
treeView$headerHidden <- TRUE
@ 
%
Columns in a \class{QStandardItemModel} may be named by calling
\method{setHorizontalHeaderNames}{QStandardItemModel}, as shown in the
next example.

\begin{example}{A workspace browser}{eg:qt-workspace-browser}
  \SweaveInput{ex-qt-treewidget}
\end{example}

\section{Model-based combo boxes}
\label{sec:qt-mvc-combo}

Combo boxes were previously introduced as containers of string items
and accompanying icons. The high-level API is sufficient for most use
cases; however, it is beneficial to understand that a combo box
displays its popup menu with a \class{QListView}, which is based on a
\class{QStandardItemModel} by default. It is possible to provide a
custom data model for the list view. Explicitly leveraging the MVC
pattern with a combo box affords greater aesthetic control and
facilitates synchronizing the items with other views.

For example, we can create a combo box that lists the same cars that
are present in our table and list views:
<<qt-mvc-combo-box>>=
comboBox <- Qt$QComboBox()
comboBox$setModel(model)
@ 
By default, the first column from the model is displayed; this is
controlled by the \qtproperty{modelColumn} property.

\section{User Editing of Data Models}

Some data models, including \class{DataFrameModel},
\class{QStringListModel} and \class{QStandardItemModel} support
modification of their data. To determine whether an item may be
edited, call the \function{flags} method on the model, passing the
index of the item, and check for the \code{ItemIsEditable} flag:
<<qt-mvc-check-editable>>=
(treeModel$index(0, 0)$flags() & Qt$Qt$ItemIsEditable) > 0
@ 

To enable editing on a column in a \class{DataFrameModel}, it is
necessary to specify the \code{edit} role for the column. For example,
we might add a logical column named \code{Analyze} to the
\code{mtcars} data frame for indicating whether a record should be
included in an analysis. We prefix \code{edit} to the column name, so
that the user can change its value between \code{TRUE} and
\code{FALSE}:
<<qt-mvc-edit-analyze>>=
df <- mtcars 
df$Analyze.edit <- TRUE
model <- qdataFrameModel(df)
@ 

If a view is assigned an editable model, it will enter its editing mode
upon a certain trigger.  By default, derivatives of
\class{QAbstractItemView} will initiate editing of an editable column
upon double mouse button click or a key press. This is controlled by
the \qtproperty{editTriggers} property, which accepts a combination of
\qtenumeration{QAbstractItemView::EditTrigger} flags. For example, we
could disable editing through a view:
<<qt-mvc-edit-trigger>>=
view$editTriggers <- Qt$QAbstractItemView$NoEditTriggers
@ 

When editing is requested, the view will pass the request to the
delegate for the item. The standard item delegate,
\class{QStyledItemDelegate}, will present an editing widget created by
its instance of \class{QItemEditorFactory}. The default item editor
factory will create a combo box for logical data, a spin box for
numeric data, and a text edit box for character data. Other types of
data, like times and dates, are also supported. To specify a custom
editor widget for some data type, it is necessary to subclass
\class{QItemEditorCreatorBase} and register an instance with the
item editor factory.

\section{Drag and Drop in Item Views}
\label{sec:qt-mvc-dnd}

The item views have native support for drag and drop. All of the
built-in models, as well as \class{DataFrameModel}, communicate data
in a common format so that drag and drop works automatically between
views. \class{DataFrameModel} also provides its data in the R
serialization format, corresponding to the
\qcode{application/x-rlang-transport} MIME type. This facilitates
implementing custom drop targets for items in R. 

Dragging is enabled by setting the
\property{dragEnabled}{QAbstractItemView} property to \qcode{TRUE}:
<<qt-mvc-dnd-dragenabled>>=
view$dragEnabled <- TRUE
@ 
%
Enabling drops is the same as for any other widget, with one addition:
<<qt-mvc-dnd-acceptdrops>>=
view$acceptDrops <- TRUE
view$showDropIndicator <- TRUE
@
%
The second line tells the view to visually indicate where the item
will be dropped. The following enables
moving items within a view, i.e., reordering:
<<qt-mvc-dnd-internalmove>>=
view$dragDropMode <- Qt$QAbstractItemView$InternalMove
@ 
%
However, that will prevent receiving drops from other views, and
dragging to other views will always be a move, not a copy.

Although we have enabled drag and drop on the view, the level of
support actually depends on the model. The supported actions may be
queried with \method{supportedDragActions}{QAbstractItemModel} and
\method{supportedDropActions}{QAbstractItemModel}. The item flags
determine whether an individual item may be dragged or dropped upon.
Most of the built-in models will support both copy and move actions,
when dragging or dropping. \class{DataFrameModel} only supports copy
actions when dragging; dropping is not supported.

\begin{example}{A drag and drop interface to \function{xtabs}}{eg:qt-dnd-table}
  \SweaveInput{ex-qt-dnd-table}
\end{example}

%% MFL: Arguable as to whether we even need to discuss these in depth
\section{Widgets With Internal Models}

While separating the model from the view provides substantial
flexibility, in practice it is often sufficient and slightly more
convenient to manipulate a view with a built-in data model. \Qt{}
provides a set of view widgets with internal models:
\\

\begin{description}
\item[\class{QListWidget}] for simple lists of items,
\item[\class{QTableWidget}] for a flat table and
\item[\class{QTreeWidget}] for a tree table.
\end{description}


In our experience, the convenience of these classes is not worth the
loss in flexibility and other advantages of the model/view design
pattern. \class{QTableWidget}, in particular, precludes the use of
\class{DataFrameModel}, so \class{QTableWidget} is usually not nearly
as convenient or performant as the model-based
\class{QTableView}. Thus, we are inclined to omit a detailed
description of these widgets. However, we will describe
\class{QListWidget}, out of an acknowledgement that displaying a short
simple list of items is a common task in a GUI.

\subsection{Displaying Short, Simple Lists}

\class{QListWidget} is an easy-to-use widget for displaying
a set of items for selection. As with combo boxes, we can populate the
items directly from a character vector through the
\method{addItems}{QListWidget} method:
<<qt-mvc-listwidget-additems, results=hide>>=
listWidget <- Qt$QListWidget()
listWidget$addItems(state.name)
@ 
%
This saves one line of code compared to populating a \class{QListView}
via a \class{QStringListModel}. To clear a list of its items, call the
\method{clear}{QListWidget} method. Passing an item to
\method{takeItem}{QListWidget} will remove that specific item from the
widget.

The items in a \class{QListWidget} instance are of the
\class{QListWidgetItem} class. New items can be constructed directly
through the constructor:
<<qt-mvc-listwidget-item>>=
item <- Qt$QListWidgetItem("Puerto Rico", listWidget)
@
%
The first argument is the text and the
optional second argument a parent \class{QListWidget}. If no parent is
specified, the the item may be added through the methods
\method{addItem}{QListWidget}, or \method{insertItem}{QListWidget} for
inserting to a specific instance.

To retrieve an item given its index, we call the
\method{item}{QListWidget} method:
<<qt-mvc-listwidget-itemat>>=
first <- listWidget$item(0)
first$text()
@ 

Many aspects of an item may be manipulated. These roughly correspond
to the built-in roles of items in \class{QAbstractItemModel}. One may
specify the text, font, icon, status and tool tips, and foreground and
background colors.

By default, \class{QListWidget} allows only a single item to be
selected simultaneously. As with other \class{QAbstractItemView}
derivatives, this may be adjusted to allow multiple selection through
the \property{selectionMode}{QAbtractItemView} property:
<<qt-mvc-listwidget-selectionmode>>=
listWidget$selectionMode <- Qt$QListWidget$ExtendedSelection
@ 

We can programmatically select the states that begin with "A":
<<qt-mvc-listwidget-select,results=hide>>=
sapply(grep("^A", state.name), 
       function(i) listWidget$item(i - 1)$setSelected(TRUE))
@
%
The method \method{selectedItems}{QListWidget} will return the
selected items in a list:
<<qt-mvc-listwidget-selected>>=
selected <- listWidget$selectedItems()
sapply(selected, qinvoke, "text")
@ 
%
To handle changes in the selection, connect to
\signal{itemSelectionChanged}:
<<qt-mvc-listwidget-selectionchanged>>=
qconnect(listWidget, "itemSelectionChanged", function() {
  selected <- listWidget$selectedItems()
  selectedText <- sapply(selected, qinvoke, "text")
  message("Selected: ", paste(selectedText, collapse = ", "))
})
@ 

It is often easier for the user to select multiple items by clicking a
check button next to the desired items. The check box is only shown if
we explicitly set the check state of item. The possible values are
\qcode{Checked}, \qcode{Unchecked} or \qcode{PartiallyChecked}. Here,
we set all of the items to unchecked to show the check buttons and
then check the selected items:
<<qt-mvc-listwidget-checked, results=hide>>=
items <- sapply(seq(listWidget$count), function(i) {
  listWidget$item(i - 1)$setCheckState(Qt$Qt$Unchecked)
})
sapply(selected, function(x) x$setCheckState(Qt$Qt$CheckedState))
@ 
%
For long lists, this looping will be time consuming. In such cases, it
is likely preferable use \class{QListView}, \class{DataFrameModel} and
the \qcode{CheckedStateRole}.

%% JV this seems to cover the same ground as the dnd example
% \begin{example}{Combining a combobox and list widget to select a
%     variable name}{eg-qt-select-variable}
%   \SweaveInput{ex-qt-select-variable}
% \end{example}

\section{Implementing Custom Models}
\label{sec:using-model-with}

Normally, the \class{DataFrameModel} and the models in \Qt{} are
sufficient. One can imagine other cases, however. For example, one
might need to view an instance of a formal reference class that
conforms to a tabular or hierarchical structure. In such case, it may
be appropriate to implement a custom model in R. We warn the reader
that this is a significant undertaking and, unfortunately, custom
models do not scale well, due to frequent callbacks into R.

\paragraph{Required methods}

The basic implementation of a model must provide the methods
\meth{rowCount}, \meth{columnCount}, and \meth{data}.  The first two
describe the size of the table for any views, and the third describes
provides data to the view for a particular cell and role. We have
already demonstrated the use of the \meth{data} method in the previous
sections. For example, if one is displaying numeric data, the
\code{DisplayRole} might format the numeric values (showing a fixed
number of digits say), yet the \code{EditRole} role might display all
the digits so accuracy is not lost. If a role is not implemented, a
value of \code{NULL} should be returned. One may also implement the
\meth{headerData} method to populate the view headers.

\paragraph{Editable Models}

For editable models, one must implement the \meth{flags} method to
return a flag containing \code{ItemIsEditable} and the \meth{setData}
method. When a value is updated, one should call the
\meth{dataChanged} method to notify the views that a portion of the
model is changed. This method takes two indices, together specifying a
rectangle in the table.

To provide for resizable tables, \code{Qt} requires one to notify the
views about dimension changes.  For example, an implemented
\meth{insertColumns} should call \meth{beginInsertColumns} before
adding the column to the model and then \meth{endInsertColumns} just
after.

\begin{example}{Using a custom model to edit a data
    frame}{eg:qt-editable-data}
  \SweaveInput{ex-qt-edit-data-frame}
\end{example}


\section{Alternative Views of Data Models}
\label{sec:custom-views}

Thus far, we have discussed the application of
\class{QAbstractItemView} for viewing items in a
\class{QAbstractItemModel}. This is the canonical model/view approach
in \Qt. The role of a \class{QAbstractItemView} is to display each
item in a model, more or less simultaneously. Sometimes it is useful
to view an individual item from a model in a simple widget like a
label or even an editing widget, such as a line edit or spin box.
For example, a GUI for entering records into a database might want to
associate each of its widgets with a column in the model, one row at a
time.

The \class{QDataWidgetMapper} class facilitates this by associating a
column (or row) in a model with a property on a widget. By default,
the \textit{user} property is selected. The user property is marked as
the primary user-facing property of a widget; there is only one per
class. An example is the \property{text}{QLabel} property on a
\class{QLineEdit}.

\begin{example}{Mapping selected model items to a text entry}{ex-qt-mapping-model}
 We will demonstrate \class{QDataWidgetMapper} by displaying a table
  view of the \qcode{Cars93} dataset, along with a label. When a row
  is selected, the model name of the record will be displayed in the
  label. First, we establish the mapping:
<<qt-mvc-mapper-map, results=hide>>=
data(Cars93, package="MASS")
model <- qdataFrameModel(Cars93, editable=TRUE)
mapper <- Qt$QDataWidgetMapper()
mapper$setModel(model)
label <- Qt$QLabel()
mapper$addMapping(label, 1)
@ 
%
  The \method{addMapping}{QDataWidgetMapper} establishes a mapping
  between the view widget and the $0$-based column index in the
  model. 
  
  Next, we construct a table view and establish a handler that
  changes the current row of the data mapper upon selection:
<<qt-mvc-mapper-select, results=hide>>=
tableView <- Qt$QTableView()
tableView$setModel(model)
qconnect(tableView$selectionModel(), "currentRowChanged", 
         mapper$setCurrentIndex)
@ 

  Finally, we layout our GUI:
<<qt-mvc-mapper-layout, results=hide>>=
w <- Qt$QWidget()
lyt <- Qt$QVBoxLayout()
w$setLayout(lyt)
lyt$addWidget(tableView)
lyt$addWidget(label)
@ 

\end{example}

Let us consider a different problem: summarizing or aggregating
multiple model items, such as an entire column, and displaying the
result in a widget. For example, a label might show the mean of a
column, and the label would be updated as the model changed.  The
\class{QDataWidgetMapper} is not appropriate for this class, as it is
limited to a one-to-one mapping between a model item and a widget, at
any given time. The next example proposes an ad-hoc solution to this.

\begin{example}{A label that updates as a model is updated}{eg:qt-custom-view}
  \SweaveInput{ex-qt-custom-view}
\end{example}

\section{Viewing and Editing Text Documents}
\label{sec:multi-line-text}

Multi-line text is displayed and edited by the \class{QTextEdit}
widget, which is the view and controller for the \class{QTextDocument}
model. \class{QTextEdit} supports both plain and rich text in HTML
format, including images, lists and tables. Applications that display
only plain text may be better served by \class{QPlainTextEdit}, which
is faster due to a simpler layout algorithm. \class{QPlainTextEdit} is
otherwise equivalent to \class{QTextEdit} in terms of API and
functionality, so we will focus our discussion on \class{QTextEdit},
with little loss of generality. 

Here, we create a \class{QTextEdit} and populate it with some
text. Although the text is actually stored in a \class{QTextDocument},
it is usually sufficient to interact with the \class{QTextEdit}
directly:
<<QTextEdit, results=hide>>=
te <- Qt$QTextEdit()
te$setPlainText("The quick brown fox")
te$append("jumped over the lazy dog")
@ 
<<eval=FALSE, echo=FALSE, results=hide>>=
## not shown
te$show(); te$raise()
@ 
<<>>=
te$toPlainText()
@ 
%
The \signal{textChanged} signal is emitted when the text is changed. 

%% Worth mentioning this, given that we never manipulate the document?
% The \method{document}{QTextEdit} can
% be used to retrieve that document, and \method{setDocument}{QTextEdit}
% to replace it. 

\paragraph{The text cursor}

To manage selections, insert special objects like tables and images,
or apply the full range of formatting options, it is necessary to
interact with a text cursor object, of class \class{QTextCursor}. We
obtain the user-visible cursor and move it to the end of the document:
<<qt-mvc-textedit-cursor, results=hide>>=
n <- nchar(te$toPlainText())
cursor <- te$textCursor()
cursor$setPosition(n)
te$setTextCursor(cursor)
@ 
%
Manipulating the \Robject{cursor} object does not actually modify the
location and parameters of the cursor on the screen. We need to
explicitly set the modified cursor object on the
\class{QTextEdit}. This behavior is often convenient, because it
allows us to modify arbitrary parts of the document, without affecting
the user cursor.  For example, we could insert an image at the beginning:
<<qt-mvc-textedit-image, results=hide>>=
cursor$setPosition(0)
cursor$insertImage(system.file("images/ok.gif", package="gWidgets"))
@ 
%
To listen to changes in the cursor position, connect to the
\signal{cursorPositionChanged} signal on the \class{QTextEdit}.

\paragraph{Selections}

Selection is a component of the \class{QTextCursor} state. For plain
text, the selected text is returned by the
\method{selectedText}{QTextCursor} method:
<<qt-mvc-textedit-selection>>=
te$textCursor()$selectedText()
@ 
%
The \code{NULL} value indicates that the user has not selected any text.
The selection spans from the cursor anchor to the cursor
position. Normally, the anchor and cursor are at the same position. To
make a selection, we move the cursor independently of its anchor.
To set the selection to include the first three words of the text, we have:
<<results=hide>>=
cursor <- Qt$QTextCursor(te$document()) 
cursor$movePosition(Qt$QTextCursor$Start)
cursor$movePosition(Qt$QTextCursor$WordRight, Qt$QTextCursor$KeepAnchor, 3)
te$setTextCursor(cursor)
@
<<qt-mvc-textedit-selection>>=
cursor$selectedText()
@ 
%
We move the cursor and anchor to the start of the document. Next, we
move the cursor, without the anchor, across the right end of three
words. Finally, we need to commit the modified cursor.

To listen to changes in the selection (according to the user visible
cursor), connect to \signal{selectionChanged}:
<<qt-mvc-textedit-selectionChanged, results=hide>>=
qconnect(te, "selectionChanged", function() {
  message("Selected text: '", te$textCursor()$selectedText(), "'")
})
@ 
%
The \signal{copyAvailable} signal is largely equivalent, except it
passes a boolean argument indicating whether the selection is non-empty.

\paragraph{Formatting}
By default, the widget will wrap text as entered. For use as a code
editor, this is not desirable. The \property{lineWrapMode}{QTextEdit}
takes values from the enumeration
\qtenumeration{QTextEdit::LineWrapMode} to control this:
<<qt-mvc-textedit-wrap>>=
te$lineWrapMode <- Qt$QTextEdit$NoWrap
@
% 
The \method{setAlignment}{QTextEdit} method aligns the current
paragraph (the one with the cursor) with values from
\qtenumeration{Qt::Alignment}.

\paragraph{Searching}
The \method{find}{QTextEdit} method will search for a given string and
adjust the cursor to select the match. For example, we can search
through a standard typesetting string starting at the cursor point for
the common word ``qui'' as follows:

<<LoremIpsum, echo=FALSE>>=
## in misc.R
LoremIpsum <- paste(
"Lorem ipsum dolor sit amet, consectetur adipisicing elit,",
"sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi",
"ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit",
"in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur",
"sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit",
"anim id est laborum.",
"\n",
"Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque",
"laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi",
"architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas",
"sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione",
"voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet,",
"consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et",
"dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum",
"exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi",
"consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam",
"nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?",
sep="\n")
@ 
<<findExample>>=
te <- Qt$QTextEdit(LoremIpsum)          # some text
te$find("qui", Qt$QTextDocument$FindWholeWords)
te$textCursor()$selection()$toPlainText()
@
%
The second parameter to \method{find}{QTextEdit} takes a combination
of flags from \qtenumeration{QTextDocument::FindFlag}, with values
\qcode{FindBackward}, \qcode{FindCaseSensitively} and
\qcode{FindWholeWords}.

\paragraph{Context menus}

As we introduce Section~\ref{sec:qt:app:context-menus}, one can enable
a dynamic context menu on a widget by overriding the
\meth{contextMenuEvent} virtual.  For our demonstration, we aim to
list candidate completions based on the currently selected text:
<<QTextEditWithMenu,results=hide>>=
qsetClass("QTextEditWithCompletions", Qt$QTextEdit)
#
qsetMethod("contextMenuEvent", QTextEditWithCompletions, function(e) {
  m <- this$createStandardContextMenu()
  if(this$textCursor()$hasSelection()) {
    selection <- this$textCursor()$selectedText()
    comps <- utils:::matchAvailableTopics(selection)
    comps <- setdiff(comps, selection)
    if(length(comps) > 0 && length(comps) < 10) {
      m$addSeparator()                  # add actions
      sapply(comps, function(i) {
        a <- Qt$QAction(i, this)
        qconnect(a, "triggered", function(checked) {
          insertPlainText(i)
        })
        m$addAction(a)
      })
    }
  }
  m$exec(e$globalPos())
})
te <- QTextEditWithCompletions()
@ 
%
The \method{createStandardContextMenu}{QTextEdit} method returns the
base context menu, including functions like copy and paste. We add an
action for every possible completion. Triggering an action will paste
the completion into the document.

<<raise, eval=FALSE, echo=FALSE, results=hide>>=
te$show()
te$raise()
@ 

\begin{example}{A tabbed text editor}{ex-qt-tabbed-text-edit}
  \SweaveInput{ex-qt-tabbed-editor.Rnw}
\end{example}

\paragraph{Syntax highlighting}

The text edit widget supports syntax highlighting through the
\class{QSyntaxHighlighter} class. To implement a specific highlighting
rule, one must subclass \class{QSyntaxHighlighter} and override the
\meth{highlightBlock} method to apply highlighting. This is of
somewhat special interest, so we will not give an example. For a
syntax highlighting R code viewer and editor, see \function{qeditor}
in the \pkg{qtutils} package.

<<eval=FALSE, echo=FALSE, results=hide>>=
## Not shown

##' start with command, return output in HTML
runCommand <- function(chunk) {
  require(R2HTML)
  f <- tempfile()
  chunkexps <- try(parse(text=chunk), silent=TRUE)
  if(inherits(chunkexps, "try-error")) 
  stop("Error")
  
  out <- ""
  for(i in seq_along(chunkexps)) {
    chunk <- chunkexps[[i]]
    out <- paste(out, "<h3>", paste(capture.output(chunk), collapse="<br>"), "</h3><br />",  sep="")
    HTML(eval(chunk), file=f, append=FALSE)
    out <- paste(out, paste(readLines(f, warn=FALSE), collapse="<br>"), sep="")
  }
  out
}




w <- Qt$QGroupBox("Simple CLI")
lyt <- Qt$QGridLayout()
w$setLayout(lyt)

cli <- Qt$QLineEdit()
out <- Qt$QTextEdit()


lyt$addWidget(Qt$QLabel("Command:"), 0, 0)
lyt$addWidget(cli, 0, 1)
lyt$addWidget(Qt$QLabel("Output:"), 1, 0, Qt$Qt$AlignTop)
lyt$addWidget(out, 1, 1)

lyt$setRowStretch(1,1)
lyt$setColumnStretch(1,1)

qconnect(cli, "editingFinished", function() {
  chunk <- cli$text
  htmlized <- runCommand(chunk)
  out$setHtml(htmlized)
  cli$setFocus(Qt$Qt$ActiveWindowFocusReason)
  cli$setSelection(0, nchar(cli$text))
})

w$setMinimumSize(800,400)
w$show()
w$raise()

@ 
