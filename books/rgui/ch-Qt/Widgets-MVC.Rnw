%% widgets using MVC framework

The model, view, controller (MVC) pattern is fundamental to the design
of widgets that display and manipulate data. Keeping the model
separate from the view allows multiple views for the same
data. Generally, the model is an abstract interface. Thus, the same
view and controller components are able to operate on any data source
(e.g., a database) for which a model implementation exists.

\Qt{} provides \class{QAbstractItemModel} as the base for all of its
data models. Like \class{GtkTreeModel}, \class{QAbstractItemModel}
represents tables, optionally with a hierarchy. The precise
implementation depends on the subclass. Widgets that view item models
extend \class{QAbstractItemView} and include tables, lists, trees and
combo boxes. This section will outline the available model
and view implementations in \Qt{} and \pkg{qtbase}.

\section{Display of tabular data}

As mentioned, \Qt{} expects data to be stored in a
\class{QAbstractItemModel}. In \R, the canonical structure for tabular
data is \class{data.frame}. The \class{DataFrameModel} class bridges
these structures by wrapping \class{data.frame} in an implementation
of \class{QAbstractItemModel}. This essentially allows a
\class{data.frame} object to be passed to any part of \Qt{} that
expects tabular data. It also offers significant performance benefits:
there is no need to copy the data frame into a C++ data structure,
which would be especially slow if the looping occurred in
\R. Displaying a simple table of data with \class{DataFrameModel} is
much simpler than with \GTK{} and \class{RGtkDataFrame}. Here we
show a \class{data.frame} in a table view:
<<qt-mvc-qdfm,print=false>>=
data(mtcars)
model <- qdataFrameModel(mtcars)
view <- Qt$QTableView()
view$setModel(model)
@ 
%
We could also pass our model to any other view expecting a
\class{QAbstractItemModel}. For example, the first column could be
displayed in a list or combo box.

The \class{DataFrameModel} object is a reference, so any changes are
reflected in all of its views. The \R{} data frame of a
\class{DataFrameModel} may be accessed using
\function{qdataFrame}:
<<qt-mvc-qdfm-access>>=
head(qdataFrame(model), 3)
qdataFrame(model)$hpToMpg <- with(qdataFrame(model), hp / mpg)
@ 
%
Our table view now contains a new column, holding the horsepower to
miles per gallon ratio. It is important to notice that the view has
been updated implicitly, through manipulation of the underlying model.

Let us now assume that a missing value (\code{NA}) has been introduced
into our dataset:
<<qt-mvc-qdf-na>>=
qdataFrame(model)$mpg[1] <- NA
@ 
%
The table view will display this as "nan" or "inf", which is
inconsitent with the notation of \R. The conversion of the numeric
data to text is carried out by an \textit{item delegate}. Similar to a
\GTK{} cell renderer, an item delegate is responsible for the
rendering and editing of items (cells) in a view. Every type of item
delegate is derived from the \class{QAbstractItemDelegate} class. By
default, views in \Qt{} will use an instance of
\class{QStyledItemDelegate}, which renders items according to the
current style. As \Qt{} is unaware of the notion and encoding of
missing values in \R, we need to give \Qt{} extra guidance. The
\pkg{qtbase} package provides the \class{RTextFormattingDelegate}
class for this purpose. To use it, one creates an instance and sets it
as the item delegate for the model:
<<qt-mvc-rtfd>>=
delegate <- qrTextFormattingDelegate()
model$setDelegate(delegate)
@ 
%
Delegates may also be assigned on a per column or per row
basis. \class{RTextFormattingDelegate} will handle missing values in
numeric vectors, as well as adhere to the numeric formatting settings
in \function{options()}, namely \qcode{digits} and \qcode{scipen}.

%% TODO: basic manipulation of QTableView 

\section{Displaying Lists}
\label{sec:displaying-lists}

%% It is debatable as to whether QListWidget would be more convenient
%% than a QListView backed by either QStringListModel or
%% DataFrameModel, especially since we have already explained the
%% latter. Getting data onto the screen takes about one more line with
%% the model interfaces. Interpreting user interaction (selection) is
%% about the same level of complexity. The View classes will yield
%% QModelIndex objects, the Widget classes yield WidgetItem
%% objects. QModelIndex only has to be described once, and offers some
%% advantages, like always yielding a row/column index, which is nice
%% for indexing into other data structures. While the Widgets offer
%% some high-level conveniences (like icons in a QListWidget),
%% for large lists it would be too slow to configure each widget
%% item. Much faster to just use roles in a DataFrameModel.


It is often desirable to display a list of items, usually as text. A
single column \class{QTableView} approximates this but also includes
row and column headers, by default. Also, the two dimensional API of
\class{QTableView} is more complicated than needed for a one
dimensional list. For these and other reasons, \Qt{} provides
\class{QListView} for displaying a single column from a
\class{QAbstractItemModel} as a list. We can use
\class{DataFrameModel} to quickly display the first column from a data
frame (or anything coercible into a data frame):
<<qt-mvc-lists-df, print=false>>=
model <- qdataFrameModel(rownames(mtcars))
view <- Qt$QListView()
view$setModel(model)
@
%
By default, \class{QListView} displays the first column from the
model, although the column index can be customized. 

Using a data model allows us to share data between multiple views. For
example, we could view a data frame as a table using a
\class{QTableView} and also display the row identifiers in a separate
list:
<<qt-mvc-lists-combo>>=
mtcars.id <- cbind(makeAndModel = rownames(mtcars), mtcars)
model <- qdataFrameModel(mtcars.id)
tableView <- Qt$QTableView()
tableView$setModel(model)
listView <- Qt$QListView()
listView$setModel(model)
@ 
%
Now, when we resort the model, both views will be updated:
<<qt-mvc-lists-sort>>=
df <- qdataFrame(model)
qdataFrame(model) <- df[order(df$mpg),]
@ 

When the list items are not associated with a data frame, they may be
conveniently represented as a character vector. In this case,
\class{DataFrameModel} is not very appropriate, as the character
vector will be coerced to a data frame. Instead, consider
\class{QStringListModel} from \Qt. In \pkg{qtbase},
\class{QStringList} refers to a character vector. We demonstrate
the use of \class{QStringListModel} to populate a list view from a
character vector:
<<qt-mvc-lists-qslm>>=
model <- Qt$QStringListModel(rownames(mtcars))
listView <- Qt$QListView()
listView$setModel(model)
@ 
%
Now we can retrieve the values as a character vector, rather than as a
data frame:
<<qt-mvc-lists-qslm-retrieve>>=
head(model$stringList)
@ 

\class{QListView} supports features beyond those of a simple list,
including features often found in file browsers and desktops. For
example, items may be wrapped into additional columns, and an icon
mode, supporting unrestricted layout and drag and drop, is also
available.

\section{Accessing Item Models}

We have shown how \class{DataFrameModel} and \class{QStringListModel}
allow the storage and retrieval of data in familiar data
structures. However, this is not true of all data models, including
most of those in \Qt. Alternative models are required, for example, in
the case of hierarchical data. In such cases, or when interpreting
user input, such as selection, it is necessary to interact with the
low-level, generic API of the item/view framework.

An item model refers to its rows, columns and cells with
\class{QModelIndex} objects, which are created by the model:
<<qt-mvc-model-index-create>>=
index <- model$index(0, 0)
index$row()
index$col()
@ 
% 
Our \qcode{index} refers to the first row of the
\class{QStringListModel}, using $0$-based indices.
The index points to a cell in the model, and we can retrieve the data
in the cell using only the index:
<<qt-mvc-model-index-data>>=
firstCar <- model$data()
@ 
%
This can be extended to retrieve all of the items in the list:
<<qt-mvc-model-populate>>=
sapply(seq(model$rowCount()), function(i) model$index(i, 0)$data())
@ 

Setting the data is also possible, yet requires calling
\method{setData}{QAbstractItemModel} on the model, not the index:
<<qt-mvc-model-index-data-set>>=
model$setData(index, toupper(firstCar))
@ 
%
We will leave the population of a model with the low-level API as an
exercise for the reader. Recall that \class{DataFrameModel} and
\class{QStringListModel} provide an interface that is much faster and
more convenient. When using such models, it is usually only necessary
to directly manipulate a \class{QModelIndex} when handling user input,
as we describe in the next section.

The \method{match}{QAbstractItemModel} method can be used to return
items in a column that match a specific string for a given role. The
column is specified by a model index and the role by one of the
\qtenumeration{Qt::ItemDataRole} enumeration. The optional third
argument is one of the \qtenumeration{Qt:::MatchFlag} enumeration,
specifying how the matching is to occur. Matches are returned as a
list of indices.

\section{Item Selection}
\label{sec:models}

Selection is likely the most common type of user interaction with
lists and tables. The selection
state is stored in its own data model,
\class{QItemSelectionModel}:
<<qt-mvc-selection-model>>=
selModel <- view$selectionModel()
@
%
This design allows views to synchronize
selection. It also supports views on the selection state, such as a
label indicating how many items are selected, independent of the
particular type of item view.

There are five selection modes for item views: single, extended,
contiguous, multi, and none. These values are defined by the
\qtenumeration{QAbstractItemView::SelectionMode}
enumeration. \qcode{SingleSelection} mode allows only a single item to
be selected at once. \qcode{ExtendedSelection} mode, the default,
supports canonical multiple selection, where a range of items is
selected by clicking the end points while holding the \kbd{Shift} key,
and clicking with the \kbd{Ctrl} key pressed adds arbitrary items to
the selection.  The \qcode{ContiguousSelection} mode disallows the
\kbd{Ctrl} key behavior. To allow selection on mouse-over, with range
selection by clicking and dragging, choose \qcode{MultiSelection}. We
configure our list view for single selection:
<<qt-mvc-selection-set-mode>>=
listView$selectionMode <- Qt$QAbstractItemView$SingleSelection
@ 
% 

<<qt-mvc-selection-set-initial, echo=FALSE>>=
selModel$select(model$index(2, 0), Qt$QItemSelectionModel$Select)
@

We can query the selection model for the selected items in our
list. Let us assume that we have selected the third row in our
list. We retrieve the data (label) in that row:
<<qt-mvc-selection-get-indices>>=
indices <- selModel$selectedIndices()
indices[[1]]$data()
@ 

<<qt-mvc-selection-multiple-set-initial, echo=FALSE>>=
sel <- Qt$QItemSelection()
sel$select(model$index(3, 0), model$index(5, 0))
sel$select(model$index(10, 0), model$index(16, 0))
sel$select(model$index(20, 0), model$index(24, 0))
selModel$select(sel, Qt$QItemSelectionModel$Select)
@

When multiple selection is allowed, we must take care to interpret the
selection efficiently, especially if a table has many rows. In the
above, we obtained the selected indices. A selection is more formally
represented by a \class{QItemSelection} object, which is a list of
\class{QItemSelectionRange} objects. Under the assumption that the
user has selected three separate ranges of items from the list view,
we retrieve the selection from the selection model:
<<qt-mvc-selection-get>>=
selection <- selModel$selection()
@ 
%
Next, we coerce the \class{QItemSelection} to an explicit list of
\class{QItemSelectionRange} objects and generate a vector of the
selected indices:
<<qt-mvc-selection-as-list>>=
indicesForSelection <- function(selection) {
  selRanges <- as.list(selection)
  unlist(lapply(selRanges, function(range) seq(range$top(), range$bottom())))
}
indicesForSelection(selection)
@ 
%
Coercion with \function{as.list} is possible for any class extending
\class{QList}; \class{QItemSelection} is the only such class the
reader is likely to encounter. Usually, the user selects a relatively
small number of ranges, although the ranges may be wide. Looping
over the ranges, but not the individual indices, will be
significantly more efficient for large selections.

It is also possible to programmatically change the selection.  For
example, we may wish to select the first list item:
<<qt-mvc-selection-set-current>>=
listView$setCurrent(model$index(0, 0))
@ 
%
This approach is simple but only supports selecting a single item.
The selection is most generally modified by calling the
\method{select}{QItemSelectionModel} method on the selection model:
<<qt-mvc-selection-select>>=
selModel$select(model$index(0, 0), Qt$QItemSelectionModel$Select)
@ 
% 
The second argument describes how the selection is to be changed with
regard to the index. It is a flag value and thus can specify several
options at once, all listed in
\qtenumeration{QItemSelectionModel::SelectionFlags}. In the above, we
issued the \qcode{Select} command. Other commands include
\qcode{Deselect} and \qcode{Toggle}. Thus, we could deselect the item
in similar fashion:
<<qt-mvc-selection-deselect>>=
selModel$select(model$index(0, 0), Qt$QItemSelectionModel$Deselect)
@ 
%
To efficiently select a range of items, we construct a
\class{QItemSelection} object and set it on the model:
<<qt-mvc-selection-multiple-set-initial, echo=FALSE>>=
sel <- Qt$QItemSelection(model$index(3, 0), model$index(10, 0))
selModel$select(sel, Qt$QItemSelectionModel$Select)
@
%
We have selected items $3$ to $10$. Multiple ranges may be added to
the \class{QItemSelection} object by calling its
\method{select}{QItemSelection} method.

For tabular views, selection may be row-wise, column-wise or item-wise
(\GTK{} supports only row-wise selection). By default, selection is by
item. While this is common in spreadsheets, one usually desires
row-wise selection in a table, so we will override the default:
<<qt-mvc-selection-set-behavior>>=
tableView$selectionBehavior <- Qt$QAbstractItemView$SelectRows
@ 
%
<<qt-mvc-selection-select-row, echo=FALSE>>=
tableView$selectRow(1)
tableView$selectRow(2)
@ 
% 
Querying a selection is essentially the same as for the list
view, except we can request indices representing entire rows or
columns. In this example, we are interested in the rows, where the
user has selected the second and third rows:
<<qt-mvc-selection-get-rows>>=
selModel <- tableView$selectionModel()
sapply(selModel$selectedRows(), qinvoke, "row")
@
%
We invoke the \method{row}{QModelIndex} method on each returned
\class{QModelIndex} object to get the row indices.
When setting the selection, there are conveniences for selecting
an entire row or column. We select the first row of the table:
<<qt-mvc-selection-select-row>>=
tableView$selectRow(0)
@ 
%
Selecting a range of rows is very similar to selecting a range of list
items, except we need to add the \qcode{Rows} selection flag:
<<qt-mvc-selection-select-rows>>=
selModel$select(sel, Qt$QItemSelectionModel$Select | 
                Qt$QItemSelectionModel$Rows)
@ 

To respond to a change in selection, connect to the
\signal{selectionChanged} signal on the selection model:
<<qt-mvc-selection-changed>>=
selectedIndices <- rep(FALSE, nrow(mtcars))
selectChangedHandler <- function(selected, deselected) {
  selectedIndices[indicesForSelection(selected)] <<- TRUE
  selectedIndices[indicesForSelection(deselected)] <<- FALSE
}
qconnect(selModel, "selectionChanged", selectionChangedHandler)
@ 
%
The change in selection is communicated as two 
\class{QItemSelection} objects: one for the selected items, the other
for the deselected items.  We update a vector of the selected
indices according to the change.

\section{Sorting and Filtering}

One of the benefits of the MVC design is that models can serve as
proxies for other models. Two common applications of proxy models are
sorting and filtering. Decoupling the sorting and filtering from the
source model avoids modifying the original data. This is a requirement
for immutable models, like \class{DataFrameModel}. The filtering and
sorting is dynamic, in the sense that no data is actually stored in
the proxy. The proxy delegates to the child model, while mapping
indices between the filtered and unfiltered (or sorted and unsorted)
coordinate space. Thus, there is little cost in memory.

\Qt{} implements both sorting and filtering in a single class:
\class{QSortFilterProxyModel}. After constructing an instance and
specifying the child model, the proxy model may be handed to a view
like any other model:
<<qt-mvc-proxy>>=
proxy <- Qt$QSortFilterProxyModel()
proxy$setSourceModel(model)
tableView$setModel(proxy)
listView$setModel(proxy)
@ 
%
Our views will now draw data through the proxy, rather than from
the original model.

Both table and tree views provide an interface for the user to sort
the underlying model. The user clicks on a column header to sort by
the corresponding column.  Clicking multiple times toggles the sort
order. This behavior is enabled by setting the
\qtproperty{sortingEnabled} property:
<<qt-mvc-proxy-sort-enable>>=
tableView$sortingEnabled <- TRUE
@ 
%
Since the sort occurs in the model, both the table view and list view
display the sorted data. The sort has been applied to both the table
and list view. It is also possible to sort programmatically by calling
the \method{sort}{QAbstractItemModel} method, passing the index of the
sort column. We sort our data by the \qcode{mpg} variable:
<<qt-mvc-proxy-sort>>=
proxy$sort(1)
@ 
%
The built-in sorting logic understands basic data types like strings
and numbers. Customizing the sorting requires overriding the
\method{lessThan}{QSortFilterProxyModel} virtual method in a new
class.

\class{QSortFilterProxyModel} supports filtering by row. The column
indicated by the \qtproperty{filterKeyColumn} property is matched
against a string pattern. Only rows with a matching value in the key
column are allowed past the filter. The pattern is a \class{QRegExp},
which supports several different syntax forms, including: fixed
strings, wildcards (globs), and regular expressions. For example, we
can filter for cars made by Mercedes:
<<qt-qvc-proxy-filter>>=
proxy$filterKeyColumn <- 0
proxy$filterRegExp <- Qt$QRegExp("^Merc")
@ 
%
This approach should satisfy the majority of use cases. To achieve
more complex filtering, including filtering of columns, subclassing is
necessary.

\section{Decorating Items}

Thus far, we have only considered the display of plain text in item
views. To move beyond this, the model needs to communicate extra
rendering information to the view. With \GTK{}, this information is
stored in extra columns, which are mapped to visual properties. Unlike
\GTK{}, however, \Qt{} does not require every cell in a column to have
the same rendering strategy or even the same type of data. Thus, \Qt{}
stores rendering information at the item level. An item is actually
a collection of data elements, each with a unique \textit{role}
identifier. The mapping of roles to visual properties depends on the
\class{QItemDelegate} associated with the item. The default item
delegate, \class{QStyledItemDelegate}, understands most of the standard
roles listed in the \qtenumeration{Qt::ItemDataRole} enumeration.

For example, when we create a \class{DataFrameModel}, the default
behavior is to associate the data frame values with the
\qtenumeration{Qt\$DisplayRole}.  \class{QStyledItemDelegate} (and its
extension \class{RTextFormattingDelegate}) convert the value to a
string for display. Other roles control aspects like the background
and foreground colors, the font, and the decorative icon, if any.

\class{DataFrameModel} supports role-specific values for each item,
\qcode{useRoles = TRUE} is passed to the constructor. It is then up to
the programmer to indicate the mapping from a data frame column to a
column and role in the model. The mapping is encoded in the column
names. Each column name should have the syntax \qcode{[.NAME][.ROLE]},
where \qcode{NAME} indicates the column name in the model and
\qcode{ROLE} refers to a value in \qtenumeration{Qt::ItemDataRole},
without the \qcode{Role} suffix. If the column name does not contain a
period (i.e., there is no \qcode{ROLE}), the display role is assumed.
For example, we could shade the background of the first column, the
makes and models, in gray:
<<qt-mvc-role-background>>=
qdataFrame(model)$.makeAndModel.background <- list(qcolor("gray"))
@ 
%
In the above, we store a list of \class{QColor} instances in our data
frame. As a side note, if we had added that column in a call
to \qcode{data.frame} or \function{cbind}, it would have been
necessary to wrap the list with \qcode{I()} in order to prevent
coercion of the list to a data frame.

The set of supported data types for each role depends on the
delegate. For delegates derived from \class{QStyledItemDelegate}, see
\qcode{qhelp(QStyledItemDelegate)}.  Due to implicit conversion in the
internals of \Qt{}, the number of possible inputs is much greater than
those explicitly documented. For example, the \qcode{background} role
demonstrated above formally accepts a \class{QBrush} object, while
implicit conversion allows types such as \class{QColor} and
\class{QGradient}.

It is possible for a single data frame column to specify the values
for a particular role across multiple model columns. This is useful,
for example, when modifying the font uniformly across several columns
of interest. Here, we bold the \qcode{mpg} and \qcode{hp} columns:
<<qt-mvc-role-multi-font>>=
qdataFrame(model)$.mpg.hp.font <- list(qfont(weight = Qt$QFont$Bold))
@ 
%
As shown, periods separate the data frame column names in the
\qcode{NAME} component. To apply a column to all columns in the model,
omit the column name:
<<qt-mvc-role-all-font>>=
qdataFrame(model)$.font <- list(qfont(pointsize = 14))
@ 

For models other than \class{DataFrameModel}, one sets data for a
specific role by passing the optional \argument{role}{setData}
argument to \method{setData}{QAbstractItemModel}. The value of
\argument{role}{setData} defaults to \qcode{EditRole}, meaning that
the data is in an editable form. We create a list view and set the
background of the first item to yellow:
<<qt-mvc-role-set-data>>=
listModel <- Qt$QStringListModel(rownames(mtcars))
listModel$setData(listModel$index(0, 0), "yellow", Qt$Qt$BackgroundRole)
listView <- Qt$QListView()
listView$setModel(listModel)
@ 
%

<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\code{DisplayRole}", "How data is displayed (\\class{QString})"),
            c("\\code{EditRole}", "Data for editing (\\class{QString})"),
            c("\\code{ToolTipRole}", "Displayed in tooltip (\\class{QString})"),
            c("\\code{StatusTipRole}", "Displayed in status bar (\\class{QString})"),
            c("\\code{SizeHintRole}", "Size hint for views (\\class{QSize})"),
            c("\\code{DecorationRole}", " (\\class{QColor}, \\class{QIcon}, \\class{QPixmap})"),
            c("\\code{FontRole}", "Font for default delegate (\\class{QFont})"),
            c("\\code{TextAlignmentRole}", "Alignment for default delegate (\\qtenumeration{Qt::AlignmentFlag})"),
            c("\\code{BackgroundRole}", "Background for default delegate (\\class{QBrush})"),
            c("\\code{ForegroundRole}", "Foreground for default delegate (\\class{QBrush})"),
            c("\\code{CheckStateRole}", "Indicates checked state of item (\\qtenumeration{Qt::CheckState})")
            )
colnames(df) <- c("Constant","Description")
cat(booktabs(df,
             colTypes=c("l","p{0.7\\textwidth}"),
             caption="Partial list of roles that an item can hold data for and the class of the data.",
             label="tab:qt:enum:itemDataRole"))
@

%% Could work into previous sections
\section{Table View Details}
\label{ssec:table-views}

Columns (similarly rows) may be hidden or shown through the
\method{setColumnHidden}{QTreeView} method. Their widths can be
adjusted by the mouse, or through
\method{setColumnWidth}{QTreeView}. The grid style can be adjusted
through \method{setGridStyle}{QTreeView}.

The view may allow sorting of the underlying model. This is enabled
through \method{setSortingEnabled}{QTreeView}. The method
\method{sortByColumn}{QTreeView} can be called specifying the column
and a sort order (e.g. \code{Qt\$Qt\$AscendingOrder}).


\paragraph{Headers}
The table view has headers, horizontal ones for the columns and
vertical ones for the rows. The methods
\method{verticalHeader}{QTreeView} and
\method{horizontalHeader}{QTreeView} return instances of the
\class{QHeaderView} class. This class has many methods. We mention
\method{setHidden}{QHeaderView}, to suppress the header display;
\method{showSortIndicator}{QHeaderView}, to display a sort arrow; and
\method{setStretchLastSection}, to strech the last section to fill the
space. For tree views, this is \code{TRUE} for horizontal headers but
not for table views.


\begin{example}{Using a custom model to edit a data frame}{eg:qt-editable-data}
  \SweaveInput{ex-qt-edit-data-frame}
\end{example}

\section{Displaying Hierarchical Data}

Hierarchical data is generally stored in \class{QStandardItemModel},
the primary implementation of \class{QAbstractItemModel} provided by
\Qt. The API of \class{QStandardItemModel} is based on
\class{QStandardItem}, a wrapper around the actual item data. 

\section{Model-based combo boxes}

Combo boxes were previously introduced as containers of string items
and accompanying icons. The high-level API is sufficient for most use
cases; however, it is beneficial to understand that a combo box
displays its popup menu with a \class{QListView}, which is based on a
\class{QStandardItemModel} by default. It is possible to provide a
custom data model for the list view. Explicitly leveraging the MVC
pattern with a combo box affords greater aesthetic control and
facilitates synchronizing the items with other views.

For example, we can create a combo box that lists the same cars that
are present in our table and list views:
<<qt-mvc-combo-box>>=
comboBox <- Qt$QComboBox()
comboBox$setModel(model)
@ 
By default, the first column from the model is displayed; this is
controlled by the \qtproperty{modelColumn} property.

\section{User Editing of Data Models}


%% MFL: Arguable as to whether we even need to discuss these in depth
\section{Widgets With Internal Models}


\label{sec:using-standard-item}

%% decoupled/coupled with model 
The use of a model separate from a view can be relatively complicated.
As such, \Qt{} provides classes that couple a standard model and
view. Defining the model then is much easier. In the case of a combobox and
a list view the model can be specified simply through a character vector.


%% MOVEME: probably belongs in the basic controls section
\subsection{Comboboxes}
\label{sec:comboboxes}

The \class{QComboBox} class implements the combobox widget.  The
\class{QListWidget} class implements a basic list view. Both do
similar things -- allow selection from a list of possible vlaues,
although differently. As such, their underlying methods are mostly
similar although their implementations have a different class
inheritance.  We discuss here the basic usage for comboboxes. Both
widgets are views for an underlying model and we restrict ourselves,
for now, to the simplest choice of these models.

By basic usage we mean setting a set of values
for the user to choose from, and for comboboxes optionally allowing
them to type in a new value.  In the simplest use, we can define the
items in their model through a character vector through the method
\method{addItems}{QComboBox}. (The items must be character, so numeric
vectors must be coerced. This works through a convesion into a
\class{QStringList} object.)  One can remove items by index with
\method{removeItem}{QComboBox}.  To allow a user to
enter a value not in this list, the property
\property{editable}{QComboBox} can be set to \code{TRUE}.



Once values are entered the property
\property{currentIndex}{QComboBox} holds the 0-based index of the
selected value. This will be $-1$ when no selection is made, and may
be meaningless if the user can edit the values. Use
\method{setCurrentIndex}{QComboBox} to set the popup value by index
($-1$ to leave unselected). The \method{count}{QComboBox} method
returns the number of items available.

The property \property{currentText}{QComboBox} returns the current
text. This will be a blank string if there is no current index.  There
is no corresponding \meth{setCurrentText}, rather one can use the
\method{findText}{QComboBox} method to get the index of the specified
string. There is an option to adjust  how finding occurs through
the enumeration \qtenumeration{Qt::MatchFlags}.


The signal \signal{activated} is emitted when the user chooses an
item. When activated, the item index is passed to the callback. This
signal is emitted when the user finishes editing of the text by
the return key.  The \signal{highlighted} signal is emitted when the
popup is engaged and the user mouses over an entry.  For editable
comboboxes, the signal \signal{editTextChanged} is emitted after each
change to the text.


\begin{example}{An example of one combobox updating another}{ex:qt-comboboxes}
This example shows how one combobox, to select a region in the U.S.,
is used to update another, which lists states in that region. We will
use the following data frame for our data., which we split into a list.

<<>>=
df <- data.frame(name=state.name, region=state.region,
                 highlight=state.x77[,1], stringsAsFactors=FALSE)
l <- split(df, df$region)
@ 



Our \code{region} combobox is loaded with the state regions. When one
is selected, the callback for \signal{activated} will first remove any
items in the \code{state} combobox, then add in the appropriate
states. The \code{ind} index is used to determine which region.
<<QComboBox, results=hide>>=
region <- Qt$QComboBox()
state <- Qt$QComboBox()

region$addItems(names(l))
region$setCurrentIndex(-1)              # no selection
qconnect(region, "activated", function(ind) {
  state$clear()
  state$addItems(l[[ind+1]]$name)       # add
})
@ 

The state combobox shows how the \signal{highlighted} signal can be
employed. In this case, information about the highlighted state is
placed in the window's title. Not really a great choice, but
sufficient for this example.
<<Highlighted, results=hide>>=
qconnect(state, "highlighted", function(ind) {
  pop <- l[[region$currentText]][ind + 1, "highlight"]
  w$setWindowTitle(sprintf("Popuplation is %s", pop))
})
@ 
Finally, we use a form layout to organize the widgets.
<<results=hide>>=
w <- Qt$QGroupBox("Two comboboxes")
lyt <- Qt$QFormLayout()
w$setLayout(lyt)
lyt$addRow("Region:", region)
lyt$addRow("State:", state)
@ 

<<eval=FALSE, echo=FALSE, results=hide>>=
w$show(); w$raise()
@ 
\end{example}



\subsection{A list widget}
\label{sec:list-view}

The \class{QListWidget} provides an easy-to-use widget for displaying
a set of items for selection. It uses an item-based model for its
data. The \class{QListView} widget provides a more general framework
with different backend models.
As with comboboxes, we can populate the
items directly from a character vector through the
\method{addItems}{QListWidget} method. However, here we mostly focus
on interacting with the widget through the item model.

The items in a \class{QListWidget} instance are of the
\class{QListWidgetItem} class. New items can be constructed directly
through the constructor. The first argument is the text and the
optional second argument a parent \class{QListWidget}. If no parent is
specified, the the item may be added through the methods
\method{addItem}{QListWidget}, or \method{insertItem}{QListWidget}
where the row to insert is specified by index. 

\class{QListWidgetItems} can have their text specified at construction
or through the method \method{setText}{QListWidgetItem} and optionally
have an icon set through the \method{setIcons}{QListWidgetItem}. There
are also methods to set a status bar tip or a tooltip.

The method \method{takeItem}{QListWidget} is used to remove items
specified by their index, \method{clear}{QListWidget} will remove all
of them.

Once an item is added to list widget it can be referenced several
ways. The currently selected item is returned by
\method{currentItem}{QListWidget}, whereas
\method{currentRow}{QListWidget} returns the current row by index, and
\method{currentIndex}{QListWidget} returns a \class{QModelIndex}
instance (with a method \meth{row} to get the index). As well, any item
may be referenced by row index through \method{item}{QListWidget} or
position (say within an event handler) by
\method{itemAt}{QListWidget}. One can search for the items with the
\method{findItems}{QListWidget} method, which returns a list of
items. An optional second argument uses the
\qtenumeration{Qt::MatchFlags} enumeration to adjust how matches are
made, for example \code{Qt\$Qt\$MatchRegExp} to match by regular expression.



\paragraph{Selection}
By default, single selection mode is enabled. This can be adjusted
through the \method{setSelectionMode}{QListWidget} argument by
specifying a value in
\qtenumeration{QAbstractItemView::SelectionMode}, such as
\code{SingleSelection} or \code{ExtendedSelection}.  Extended
selection allows the user to extend the current selection by
simultaneously pressing the \kbd{control} key or the \kbd{shift} key
(selecting all items between the current selection and the newly
selected item).  

To retrieve the selected values, the method
\method{selectedItems}{QListWidget} will return the items in a list.

Setting an item to be selected is done through
\method{setCurrentItem}. The first argument is the item, the optional
second argument one of the
\qtenumeration{QItemSelectionModel::SelectionFlag} enumeration. If
specified as \code{Qt\$QItemSelectionModel\$Select} (the default) the
item will be selected, but other choices are possible such as
\qcode{Deselect} or \qcode{Toggle}.

\paragraph{Checkable items}
The underlying items may be checkable. This is initiated by setting an
initial check state (\method{setCheckState}{QListWidgetItem}) with a value from \qcode{Checked}
(\code{Qt\$Qt\$Checked}), \qcode{Unchecked} or
\qcode{PartiallyChecked}. For example, we can populate a list widget
and set the values unchecked with.

<<Checkable,results=hide>>=
w <- Qt$QListWidget()
w$addItems(state.name)
sapply(1:w$count, function(i) 
       w$item(i-1)$setCheckState(Qt$Qt$Unchecked))
@ 
<<echo=FALSE, results=hide>>=
## w$show(); w$raise()
set.seed(1)
sapply(sample(1:w$count, 30), 
       function(i) w$item(i-1)$setCheckState(Qt$Qt$Checked))
@ 
Then, after checking a few we can get the state along the lines of:
<<>>=
sapply(1:8, function(i) as.logical(w$item(i-1)$checkState()))
@ 
This uses the fact that the enumeration for \qcode{Unchecked} is $0$
and \qcode{Checked} is $2$.


\paragraph{Signals}
There are several signals that are emitted by the widget. Chief among
them are \signal{itemActivated}, which is emitted when a user clicks
on an item or presses the activation key. The latter is what
distinguishes it from the \signal{itemClicked} signal. For capturing
double clicks there is \signal{itemDoubleClicked}. For these three,
the undelying item is passed to the callback. The
\signal{itemSelectionChanged} signal is emitted when the underlying
selection is changed.

\begin{example}{Filtering example}{ex-qt-listwidget-filter}
We illustrate the widget with a typical filtering example, where
a user types in values to narrow down the available choices. We begin
by setting up our widgets.
<<FilteringByListWidget, results=hide>>=
w <- Qt$QGroupBox("Filtering example")
lyt <- Qt$QFormLayout()
w$setLayout(lyt)

lyt$addRow("Filter:", f <- Qt$QLineEdit())      # define f
lyt$addRow("State:", lw <- Qt$QListWidget())    # define lw
lyt$addRow("", b <- Qt$QPushButton("Click me")) # define b
@ 

For convenience, we use a built-in data set for our choices. We
populate the list widget and add a tooltip indicating the area.
<<setToolTip, results=hide>>=
for(i in state.name) {
  item <- Qt$QListWidgetItem(i, lw)             # populate
  txt <- sprintf("%s has %s square miles", i, state.x77[i, "Area"])
  item$setToolTip(txt)
}
@ 
For this example, we allow multiple selection.
<<setSelectionMode, results=hide>>=
lw$setSelectionMode(Qt$QAbstractItemView$ExtendedSelection)
@ 

The following callback updates the displayed items so that only ones
matching the typed in string are displayed. Rather than compare each
item to the matched items, we simply hide them all then unhide those
that match.
<<textChanged, results=hide>>=
qconnect(f, "textChanged", function(str) {
  matching <- lw$findItems(str, Qt$Qt$MatchStartsWith)
  sapply(seq_len(lw$count), function(i) lw$item(i-1)$setHidden(TRUE))
  sapply(matching, function(i) i$setHidden(FALSE))
})
@ 


<<echo=FALSE>>=
## Code to show how to set a selection
## find and set selection
## items <- lw$findItems("New", Qt$Qt$MatchStartsWith)
## sapply(items, function(i) {
##   lw$setCurrentItem(i, Qt$QItemSelectionModel$Select)
## })
@ 

The following shows how we can grab the selected values.
<<results=hide>>=
qconnect(b, "pressed", function() {
  vals <- sapply(lw$selectedItems(), function(i) i$text())
  print(vals)
})
@ 

<<eval=FALSE, echo=FALSE, results=hide>>=
w$show()
w$raise()
@ 
\end{example}


\begin{example}{Combining a combobox and list widget to select a
    variable name}{eg-qt-select-variable}
  \SweaveInput{ex-qt-select-variable}
\end{example}

\subsection{A table widget}
\label{sec:table-widget}

The \class{QTableWidget} class provides a widget for displaying
tabular data in an item-based approach, similar to
\class{QListWidget}. The \class{QTableView} widget is more flexible,
but also more demanding, as it has the ability to have different data
models (which can be much faster with large tables). As such, only if
your needs are not too complicated will this widget will be a good choice.

The dimensions of the table must be set prior to adding items. The
methods \method{setRowCount}{QTableWidget} and
\method{setColumnCount}{QTableWidget} are used.



The \class{QTableWidget} class has a built in model that is populated
item by item. Items are of class \class{QTableWidgetItem} and are
created first, then inserted into the widget, by row and column, through
the method \method{setItem}. (These operations are not vectorized and
can be slow for large tables.)  Items can be removed by row-and-column index with
\method{takeItem}{QTableWidget}. The item can be reinserted. The
\method{clear}{QTableWidget} method will remove all items, even headers
items, whereas, \method{clearContents}{QTableWidget} will leave the
headers. Both keep the dimensions.

As with \class{QListWidget}, items have various properties that can be
adjusted. The text can be specified to the constructor, or set through
\method{setText}{QTableWidgetItem}. Text alignment is specified
through \method{setTextAlignment}{QTableWidgetItem}. The font may be
configured through \method{setFont}{QTableWidgetItem}. The methods
\method{setBackground}{QTableWidgetItem} and
\method{setForeground}{QTableWidgetItem} are used to adjust the colors.


Items may also have icons (\method{setIcon}{QTableWidgetItem}),
tooltips (\method{setToolTip}{QTableWidgetItem}), and statusbar tips
(\method{setStatusTip}{QTableWidgetItem}).


Similar to \class{QListWidget}, \class{QTableWidgetItem} instances are
returned by the method \method{item}{QTableWidget}, with a
specification of row and column; and by \method{itemAt}{QTableWidget},
only with a specification of a position. The
\method{findItems}{QTableWidget} method will return a list of items
matching a string. Also, there is the method
\method{currentItem}{QTableWidget}, to return the currently selected
item. From an item, its column and row can be found through its
methods \method{column}{QTableWidget} and \method{row}{QTableWidget}

\paragraph{Item flags}
As mentioned, items may have several different properties: are they
editable, draggable, \dots ? To specify, one sets an items flags with
values taken from the \qtenumeration{Qt::ItemFlag} enumeration. The
possible values are: \qcode{NoItemFlags}, \qcode{ItemIsSelectable},
\qcode{ItemIsEditable}, \qcode{ItemIsDragEnabled},
\qcode{ItemIsDropEnabled}, \qcode{ItemIsUserCheckable},
\qcode{ItemIsEnabled}, and \qcode{ItemIsTriState} (has three check
states). To make an item checkable, one must first set the check
state. By default, the widget is selectable, editable, drag and
droppable, checkable and enabled. To remove a flag, one can specify all the ones they want, or
use integer arithmetic and subtract. E.g., to remove the editable
attribute one has this possibility:
<<results=hide>>=
item <- Qt$QTableWidgetItem("Set not editable")
if(item$flags() & Qt$Qt$ItemIsEditable)
  item$setFlags(item$flags() - Qt$Qt$ItemIsEditable)
@ 


\paragraph{Headers}
Columns may have headers (horizontal ones, rows have vertical
headers). These are set all at once by specifying a character vector
to \method{setHorizontalHeaderLabels}{QTableWidget}, or can be set
with an item by \method{setHorizontalHeaderItem}{QTableWidget}. The
header itself, of class \class{QHeaderView}, is returned by
\method{horizontalHeader}{QTableWidget}. Headers have the method
\meth{setVisible} to toggle their visibility. To make the last column
stretch to fill the available space is specified through the header
vier method \method{setStretchLastSection}{QHeaderView} with a value
of \code{TRUE}.  

Otherwise, to specify the width of a column programmatically  the method
\method{setColumnWidth}{QTableView} is available. One specifies the
column, then the width in pixels.

\paragraph{Sorting and Filtering}

This widget can have its rows sorted by the values of a column through
the method \method{sortItems}{QTableWidget}. One specifies the column
by index, and an order. The default is \qcode{AscendingOrder}, the
alternative is \code{Qt\$Qt\$DescendingOrder}. Sorting should be done
after the table is populated with items.



Rows and columns can be hidden through the table widget's methods
\method{setRowHidden}{QTableWidget} and
\method{setColumnHidden}{QTableWidget}. This can be used for filtering
purposes without redrawing the table.


\paragraph{Selection}
\XXX{Does \class{QTableWidgetSelectionRange} work to set the selection?}

For the table widget one can easily select rows, columns, blocks and
even combinations thereof.  An underlying selection model implements
selection, but the \class{QTableWidget} class provides an easier
interface. The currently selected items are returned as a list through
the method \method{selectedItems}{QTableWidget}.

A given cell may be selected by index (row then column) through the
method \method{setCurrentCell}{QTableWidget}, or if the item instance
is known by \method{setCurrentItem}{QTableWidget}. In addition, an
optional selection flag from the enumeration
\qtenumeration{QItemSelectionModel::SelectionFlag} can be specified
with values among \qcode{Select}, to add the item to the selection;
\qcode{Clear}, to clear all selection; \qcode{Toggle}, to toggle the
specified item; \qcode{Rows}, to extend the selection to the enclosing
row; and similarly for \qcode{Columns}.  For an item itself, the method
\method{setSelection}{QTableWidgetItem} takes a logical value to
indicate the selection state.


The current selection can be cleared by selecting an item with the
\qcode{Clear} attribute, or by grabbing the underlying selection model
and calling its \meth{clearSelection} method. E.g, something like:
<<eval=FALSE>>=
tbl$selectionModel()$clearSelection()
@ 


\paragraph{Signals}

The \class{QTableWidget} class has a number of signals it emits. They
mostly come in pairs: ``cell'' ones passing in the row and column index and
``item'' ones passing in an item reference. For example,
\signal{cellClicked} and \signal{itemClicked}, both called when a cell
is clicked. Also there are \signal{cellDoubleClicked},
\signal{cellEntered}, \signal{cellPressed},
\signal{currentCellChanged} and \signal{cellChanged} (with similar
``item'' ones). Also of interest is the \signal{itemSelectionChanged}
which is called when the selection changes.


\begin{example}{Selection of variables}{eg:qt-selection-from-tablewidget}
  \SweaveInput{ex-qt-table-selection}
\end{example}


\begin{example}{A drag and drop interface to \function{xtabs}}{eg:qt-dnd-table}
  \SweaveInput{ex-qt-dnd-table}
\end{example}



\subsection{A Tree Widget}
\label{sec:tree-widget}

The \constructor{QTreeWidget} provides a tree view based on a coupled
tree model. It is used in a manner similar to the table widget,
however, one must adjust for the heiarchical nature of the data it can display.
The widget shows a specific number of columns, which is specified via
\method{setColumnCount}{QTreeWidget}. The column headers are set through
\method{setHeaderLabels}{QTreeWidget} by specifying a vector of column
names. 


%% items
\paragraph{Tree Widget Items}
The widget organizes itself through items, with each item having $1$
or more columns.  The items in the tree widget are instances of the
\class{QTreeWidgetItem} class. An item displays a value in each
column. The method \method{setText}{QTreeWidgetItem} takes two
arguments, an integer specifying a column, and a value to
display. Similarly, other such item methods require one to specify the
column. These methods include:
\method{setTextAlignment}{QTreeWidgetItem},
\method{setFont}{QTreeWidgetItem},
\method{setToolTip}{QTreeWidgetItem},
\method{setStatusTip}{QTreeWidgetItem}, and
\method{setIcon}{QTreeWidgetItem}. To retrieve these values, the
method \method{data}{QTreeWidgetItem} takes a column number and a
role, such as \code{Qt\$Qt\$DisplayRole} to get the text.


%% heiarchy
\paragraph{Heirarchy}
A tree is used to represent a heirarchy. The items have several
methods related to this. Each item has a
\method{parent}{QTreeWidgetItem} method pointing to the parent item,
or \code{NULL} if a top-level item. (In the latter case, the tree
widget's \method{invisibleRootItem}{QTreeWidget} method returns the
parent item.)  The method \method{child}{QTreeWidgetItem} returns the
child item, specified by index. The index of a given item in the
parent is returned by \method{indexOfChild}{QTreeWidgetItem}. The
total number of children for an item is returned by
\method{childCount}{QTreeWidgetItem}. There is not a
\code{nextSibling} method, but one could do something like:

<<nextSibling>>=
nextSibling <- function(tr, i) {
  parent <- i$parent()
  if(is.null(parent))
    parent <- tr$invisibleRootItem()
  ind <- parent$indexOfChild(item)
  n <- parent$childCount()
  if(ind + 1 < n)
    parent$child(ind + 1)                   # 1 already added
  else
    NULL
}
@ 

New child items are added with either with
\method{addChild}{QTreeWidgetItem}, adding at the end; or
\method{insertChild}{QTreeWidgetItem} adding the child item at the
specified index. Child items are removed by the
\method{removeChild}{QTreeWidgetItem} method or the
\method{takeChild}{QTreeWidgetItem}, if specifying by index. The
latter returns the item to be reparented if desired.

The view can be made to show if a child is present by
calling  \method{setChildIndicatorPolicy}{QTreeWidgetItem} with a
value of \code{Qt\$QTreeWidgetItem\$ShowIndicator} (or one of
\code{DontShowIndicator} or
\code{DontShowIndicatorWhenChildless}).

When an item has children and an indicator is shown, the view may be
expanded by clicking on this indicator. The item method
\method{isExpanded}{QTreeWidgetItem} returns \code{TRUE} when an item is
expanded. This state can be set via
\method{setExpanded}{QTreeWidgetItem}.  The methods
\method{setDisabled}{QTreeWidgetItem} and
\method{setHidden}{QTreeWidgetItem} are also available to disable or
hide an item.



%% heiarchchy
\paragraph{Adding items to a tree}
The children of the invisible root
item are the ``top-level'' items. These are added through
\method{addTopLevelItem}{QTreeWidget} or the
\method{insertTopLevelItem}{QTreeWidget} methods, the latter requiring
an index to specify where. The basic idea is that each top-level item is
prepared, along with its heirarchy, then added through these methods.



%% selection
\paragraph{Selection}
The currently selected item is returned by
\method{currentItem}{QTreeWidget} and may be specified by item through
\method{setCurrentItem}{QTreeWidget}. For multiple selection, see the
discussion on selection models~\ref{para:selection-models}.



%% signals
\paragraph{Signals}
The widget emits several signals, most passing the item and the column
to the handler. Some useful signals are \signal{itemClicked},
\signal{itemDoubleClicked}, \signal{itemExpanded}, and
\signal{itemActivated} (for clicking or the \kbd{Enter} key).


\begin{example}{A workspace browser}{eg:qt-workspace-browser}
  \SweaveInput{ex-qt-treewidget}
\end{example}


\section{Implementing Custom Models}
\label{sec:using-model-with}


\paragraph{Required methods}
The basic implementation of a subclass must provide the methods 
\meth{rowCount}, \meth{columnCount}, and \meth{data}.  The first two
describe the size of the table for any views, the third describes to
the view how to display data for a given role. The signature for the
\meth{data} method is \code{(index, role)}. The \code{index} value, an
instance of \class{QModelIndex}, has methods \meth{row} and
\meth{column}, whereas \code{role} is one of the roles defined in the
\qtenumeration{Qt::ItemDataRole} enumeration. This method should
return the appropriate value for the given role. For example, if one
is displaying numeric data, the \code{display} role might format the
numeric values (showing a fixed number of digits say), yet the
\code{edit} role might display all the digits so accuracy is not
lost. If a role is not implemented, a value of \code{NULL} should be
returned, as this is mapped to a null instance of \class{QVariant}.

One may also implement the \meth{headerData} method to return the
appropriate data to display in the header for a given role. The main
one being \code{Qt\$Qt\$DisplayRole}.

\paragraph{Editable Models}
For editable models, one must implement the \meth{flags} method to
return a flag containing \code{ItemIsEditable} and the \meth{setData}
method. This has signature \code{(index, value, role)} where
\code{value} is a character string containing the edited value. When a
value is updated, one should call the \meth{dataChanged} method to
notify the views that a portion of the model is changed. This method
takes two indices, together specifying a rectangle in the table.


To provide for resizable tables, \code{Qt} requires one to call some
(of several such) functions so that any connected views can be
notified. For example, an implemented \meth{insertColumns} should call
\meth{beginInsertColumns} before adding the column to the model and
then \meth{endInsertColumns} just after. 

\section{Implemeting Custom Views}
\label{sec:custom-views}

One can write a custom view for a model. In the example, we show how
to connect a label's text to the values in a column of a model. The
base class for a view of an item model is
\class{QAbstractItemView}. This class has many methods -- that can be
overridden -- to cover keyboard, mouse, scrolling, selection etc. Here
we focus on just enough for our example.

\begin{example}{A label that updates as a model is updated}{eg:qt-custom-view}
  \SweaveInput{ex-qt-custom-view}
\end{example}


\XXX{Should we illustrate a tree model? I don't have a good example to
  do right now and this section is getting a bit long.}
%% \subsection{Tree models}
%% \label{sec:tree-models}

