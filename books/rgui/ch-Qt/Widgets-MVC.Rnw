%% widgets using MVC framework
\section{Model View Controller implementation in Qt}
\label{sec:models}

%% overview
The model-view-controller architecture adds a complexity to widgets
that is paid in order to create more flexible and efficient use of
resources. Keeping the model separate from the view allows multiple
views for the same data. It also allows views to be more responsive when
there are large data sets involved. The basic MVC architecture has a
controller to act as a go-between for a model and its views. In \Qt,
this is different, an item in a model has a delegate that allows the user to see and
perhaps edit the item's data within a view. Although custome delagates can be
defined, we are content to use those provided by \Qt. 

We discuss in the following various views: comboboxes, list views,
table views and tree views. These are all familiar. The primary
difficulty with using backend models is the specification and
interaction with the model. For the simplest usages, \Qt{} provides a
set of convenience classes where the items and views are coupled.


Models in \Qt{} are derived from the \class{QAbstractItemModel} class,
although there are standard sub-classes for list, table and
heirarchical models (\class{QStringListModel},
\class{QAbstractListModel}, \class{QAbstractTableModel}, and
\class{QStandardItemModel}). In addition, the \pkg{qtbase} package
provides the \constructor{qdataFrameModel} constructor to provide an
mapping from a data frame to an item model.

%% items, roles
A model is comprised of items, each having an associated index. Items
have associated data which may vary based on the role
(Table~\ref{tab:qt:enum:itemDataRole}) the item is playing. For
example, one role describes the data for display whereas another role
describes the data for editing.  This allows a numeric item, to be
displayed with just a few digits, but edited with all of them. Both
descriptions, and others, are stored in the item's data and set
through the \meth{setData} method.
For the \constructor{qdataFrameModel} constructor these roles are
encoded as additional, specially named, columns in the data frame.


<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\code{DisplayRole}", "How data is displayed (\\class{QString})"),
            c("\\code{EditRole}", "Data for editing (\\class{QString})"),
            c("\\code{ToolTipRole}", "Displayed in tooltip (\\class{})"),
            c("\\code{StatusTipRole}", "Displayed in status bar (\\class{})"),
            c("\\code{SizeHintRole}", "Size hint for views (\\class{QSize})"),
            c("\\code{DecorationRole}", " (\\class{QColor}, \\class{QIcon}, \\class{QPixmap})"),
            c("\\code{FontRole}", "Font for default delegate (\\class{QFont})"),
            c("\\code{TextAlignmentRole}", "Alignment for default delegate (\\qtenumeration{Qt::AlignmentFlag})"),
            c("\\code{BackgroundRole}", "Background for default delegate (\\class{QBrush})"),
            c("\\code{ForegroundRole}", "Foreground for default delegate (\\class{QBrush})"),
            c("\\code{CheckStateRole}", "Indicates checked state of item (\\qtenumeration{Qt::CheckState})")
            )
            colnames(df) <- c("Constant","Description")
            cat(booktabs(df,
                         colTypes=c("l","p{0.7\\textwidth}"),
                         caption="Partial list of roles that an item can hold data for and the class of the data."),
                label="tab:qt:enum:itemDataRole")
@


An item has several properties that are described by the
\qtenumeration{Qt::ItemFlag} enumeration. These indicate whether an
item is selectable (\code{ItemIsSelectable}), editable
(\code{ItemIsEditable}), enabled (\code{ItemIsEnabled}), checkable
(\code{ItemIsCheckable}) etc. The \method{flags}{QAbstractItemModel}
returns the flag recording combinations of these.








\section{The item-view classes}
\label{sec:using-standard-item}

%% decoupled/coupled with model 
The use of a model separate from a view can be relatively complicated,
as such \Qt{} provides classes that couple a standard model and
view. Defining the model is much easier. In the case of a combobox and
a list view the model can be specified by a character vector.


\subsection{Comboboxes}
\label{sec:comboboxes}

The \class{QComboBox} class implements the combobox widget.  The
\class{QListWidget} class implements a basic list view. Both do
similar things -- allow selection from a list of possible vlaues,
although differently. As such, their underlying methods are mostly
similar although their implementations have a different class
inheritance.  We discuss here the basic usage for comboboxes. Both
widgets are views for an underlying model and we restrict ourselves,
for now, to the simplest choice of these models.

By basic usage we mean setting a set of values
for the user to choose from, and for comboboxes optionally allowing
them to type in a new value.  In the simplest use, we can define the
items in their model through a character vector through the method
\method{addItems}{QComboBox}. (The items must be character, so numeric
vectors must be coerced. This works through a convesion into a
\class{QStringList} object.)  One can remove items by index with
\method{removeItem}{QComboBox}.  To allow a user to
enter a value not in this list, the property
\property{editable}{QComboBox} can be set to \code{TRUE}.



Once values are entered the property
\property{currentIndex}{QComboBox} holds the 0-based index of the
selected value. This will be $-1$ when no selection is made, and may
be meaningless if the user can edit the values. Use
\method{setCurrentIndex}{QComboBox} to set the popup value by index
($-1$ to leave unselected). The \method{count}{QComboBox} method
returns the number of items available.

The property \property{currentText}{QComboBox} returns the current
text. This will be a blank string if there is no current index.  There
is no corresponding \meth{setCurrentText}, rather one can use the
\method{findText}{QComboBox} method to get the index of the specified
string. There is an option to adjust  how finding occurs through
the enumeration \qtenumeration{Qt::MatchFlags}.


The signal \signal{activated} is emitted when the user chooses an
item. The item index is passed to the callback. This signal responds
to activation by the finishing editing of the text by the return key.
The \signal{highlighted} signal is emitted when the popup is engaged
and the user mouses over an entry.  For editable comboboxes, the
signal \signal{editTextChanged} is emitted after each change to the
text.


\begin{example}{An example of one combobox updating another}{ex:qt-comboboxes}
This example shows how one combobox, to select a region in the U.S.,
is used to update another, which lists states in that region. We will
use the following data frame for our data., which we split into a list.

<<>>=
df <- data.frame(name=state.name, region=state.region,
                 highlight=state.x77[,1], stringsAsFactors=FALSE)
l <- split(df, df$region)
@ 



Our \code{region} combobox is loaded with the state regions. When one
is selected, the callback for \signal{activated} will first remove any
items in the \code{state} combobox, then add in the appropriate
states. The \code{ind} index is used to determine which region.
<<results=hide>>=
region <- Qt$QComboBox()
region$addItems(names(l))
region$setCurrentIndex(-1)              # no selection
qconnect(region, "activated", function(ind) {
  sapply(rev(seq_len(state$count)), function(i)
         state$removeItem(i-1))         # clear states
  state$addItems(l[[ind+1]]$name)       # add
})
@ 

The state combobox shows how the \signal{highlighted} signal can be
employed. In this case, information about the highlighted state is
placed in the window;s title. Not really a great choice, but
sufficient for this example.
<<results=hide>>=
state <- Qt$QComboBox()
qconnect(state, "highlighted", function(ind) {
  pop <- l[[region$currentText]][ind + 1, "highlight"]
  w$setWindowTitle(sprintf("Popuplation is %s", pop))
})
@ 
Finally, we use a form layout to organize the widgets.
<<results=hide>>=
w <- Qt$QGroupBox("Two comboboxes")
lyt <- Qt$QFormLayout()
w$setLayout(lyt)
lyt$addRow("Region:", region)
lyt$addRow("State:", state)
@ 

<<echo=FALSE, results=hide>>=
w$show(); w$raise()
@ 
\end{example}



\subsection{A list widget}
\label{sec:list-view}

The \class{QListWidget} provides an easy-to-use widget for displaying
a set of items for selection. It uses an item-based model for its
data. The \class{QListView} widget provides a more general framework
with different backend models.
As with comboboxes, we can populate the
items directly from a character vector through the
\method{addItems}{QListWidget} method. However, here we mostly focus
on interacting with the widget through the item model.

The items in a \class{QListWidget} instance are of the
\class{QListWidgetItem} class. New items can be constructed directly
through the constructor. The first argument is the text and the
optional second argument a parent \class{QListWidget}. If no parent is
specified, the the item may be added through the methods
\method{addItem}{QListWidget}, or \method{insertItem}{QListWidget}
where the row to insert is specified by index. The method
\method{takeItem}{QListWidget} is used to remove items by their index
and \method{clear}{QListWidget} will remove all of them.

\class{QListWidgetItems} can have their text specified at construction
or through the method \method{setText}{QListWidgetItem} and optionally
have an icon set through the \method{setIcons}{QListWidgetItem}. There
are also methods to set a status bar tip or a tooltip.

Once an item is added to list widget it can be referenced several
ways. The currently selected item is returned by
\method{currentItem}{QListWidget}, whereas
\method{currentRow}{QListWidget} returns the current row by index, and
\method{currentIndex}{QListWidget} returns a \class{QModelIndex}
instance (with method \meth{row} to get the index). As well, any item
may be referenced by row index through \method{item}{QListWidget} or
position (say within an event handler) by
\method{itemAt}{QListWidget}. One can search for the items with the
\method{findItems}{QListWidget} method, which returns a list of
items. An optional second argument uses the
\qtenumeration{Qt::MatchFlags} enumeration to adjust how matches are
made, for example \code{Qt\$Qt\$MatchRegExp} to match by regular expression.



\paragraph{Selection}
By default, single selection mode is enabled. This can be adjusted through
the \method{setSelectionMode}{QListWidget} argument by specifying a
value in \qtenumeration{QAbstractItemView::SelectionMode}, such as
\code{SingleSelection} or \code{ExtendedSelection}. The latter changes
selection when a new item is chosen, unless the \kbd{Control} or
\kbd{Shift} keys are pressed.

To retrieve the selected values, the method
\method{selectedItems}{QListWidget} will return the items in a list. 

Setting an item to be selected is done through
\method{setCurrentItem}. The first argument is the item, the optional
second one the \qtenumeration{QItemSelectionModel::SelectionFlag}
enumerations. If specified as \code{Qt\$QItemSelectionModel\$Select}
(the default) the item will be selected, but other choices are
possible such as \qcode{Deselect} or \qcode{Toggle}.

\paragraph{Checkable items}
The underlying items may be checkable. This is initiated by setting an
initial check state (\method{setCheckState}{QListWidgetItem}) with a value from \qcode{Checked}
(\code{Qt\$Qt\$Checked}), \qcode{Unchecked} or
\qcode{PartiallyChecked}. For example, we can populate a list widget
and set the values unchecked with.

<<Checkable,results=hide>>=
w <- Qt$QListWidget()
w$addItems(state.name)
sapply(1:w$count, function(i) w$item(i-1)$setCheckState(Qt$Qt$Unchecked))
@ 
<<echo=FALSE, results=hide>>=
w$show(); w$raise()
set.seed(1)
sapply(sample(1:w$count, 30), 
       function(i) w$item(i-1)$setCheckState(Qt$Qt$Checked))
@ 
Then, after checking a few we can get the state along the lines of:
<<>>=
sapply(1:8, function(i) as.logical(w$item(i-1)$checkState()))
@ 
This uses the fact that the enumeration for \qcode{Unchecked} is $0$
and \qcode{Checked} is $w$.


\paragraph{Signals}
There are several signals that are emitted by the widget. Chief among
them are \signal{itemActivated}, which is emitted when a user clicks
on an item or presses the activation key. The latter is what
distinguishes it from the \signal{itemClicked} signal. For capturing
double clicks there is \signal{itemDoubleClicked}. For these three,
the undelying item is passed to the callback. The
\signal{itemSelectionChanged} signal is emitted when the underlying
selection is changed.

\begin{example}{Filtering example}{ex-qt-listwidget-filter}
We illustrate the widget with a typical filtering example, where
a user types in values to narrow down the available choices. We begin
by setting up our widgets.
<<FilteringByListWidget, results=hide>>=
w <- Qt$QGroupBox("Filtering example")
lyt <- Qt$QFormLayout()
w$setLayout(lyt)

lyt$addRow("Filter:", f <- Qt$QLineEdit())
lyt$addRow("State:", lw <- Qt$QListWidget())
lyt$addRow("", b <- Qt$QPushButton("Click me"))
@ 

For convenience, we use a built-in data set for our choices. He
populate the list widget and add a tooltip indicating the area.
<<results=hide>>=
for(i in state.name) {
  item <- Qt$QListWidgetItem(i, lw)             # populate
  item$setToolTip(sprintf("%s has %s square miles", i, state.x77[i, "Area"]))
}
@ 
For this example, we allow multiple selection.
<<results=hide>>=
lw$setSelectionMode(Qt$QAbstractItemView$ExtendedSelection)
@ 

The following callback updates the displayed items so that only ones
matching the typed in string are displayed. Rather than compare each
items to the matched items, we simply hide them all then unhide those
that match.
<<results=hide>>=
qconnect(f, "textChanged", function(str) {
  matching <- lw$findItems(str, Qt$Qt$MatchStartsWith)
  sapply(seq_len(lw$count), function(i) lw$item(i-1)$setHidden(TRUE))
  sapply(matching, function(i) i$setHidden(FALSE))
})
@ 


<<echo=FALSE>>=
## Code to show how to set a selection
## find and set selection
## items <- lw$findItems("New", Qt$Qt$MatchStartsWith)
## sapply(items, function(i) {
##   lw$setCurrentItem(i, Qt$QItemSelectionModel$Select)
## })
@ 

The following shows how we can grab the selected values.
<<results=hide>>=
qconnect(b, "pressed", function() {
  vals <- sapply(lw$selectedItems(), function(i) i$text())
  print(vals)
})
@ 

<<echo=FALSE, results=hide>>=
w$show()
w$raise()


@ 
\end{example}


\begin{example}{Combining a combobox and list widget to select a
    variable name}{eg-qt-select-variable}
  This example shows how we can combine a combobox and a list widget
  to select a variable name from a data frame. Here we select a value
  by dragging it. A such we need to define a sub-class of
  \class{QListWidget} to implement the \code{mousePressEvent}.
  
<<VariableSelector, results=hide>>=
## A subclass of ListWidget so that we can drag values
qsetClass("DraggableListWidget", Qt$QListWidget, function(parent=NULL) {
  super(parent)
  this$df <- NULL
 })
@   
%
The property \code{df} holds the name of the dataframe that will be
selected through a combobox. Here is a method to set the value.
<<results=hide>>=
qsetMethod("setDf", DraggableListWidget, function(df) this$df <- df)
@ 
%
For drag and drop we show how to serialize an arbitrary \R{} object to
pass through to the drop target.  We pass in a list of the data frame
name and the selected variable name. The method
\method{setData}{QMimeData} takes a MIME type (which we arbitrarily
define) and a value. This value will be retrieved by the
\method{data}{QMimeData} method and we can then call
\function{unserialize}.
<<>>=
qsetMethod("mousePressEvent", DraggableListWidget, function(e) {
  item <- itemAt(e$pos())
  val <- list(df=this$df, var=item$text())

  md <- Qt$QMimeData()
  md$setData("R/serialized-data", serialize(val, NULL))

  drag <- Qt$QDrag(this)
  drag$setMimeData(md)

  drag$exec(Qt$Qt$CopyAction | Qt$Qt$MoveAction, Qt$Qt$CopyAction)
})
@ 


With this, we know create a widget to hold the combobox and the list
box. The constructor creates the widgets, lays them out, initializes
the data sets then sets a handler to update the variable list when the
dataframe selector does.
<<>>=
qsetClass("VariableSelector", Qt$QWidget, function(parent=NULL) {
  super(parent)

  this$dfcb <- Qt$QComboBox()
  this$varList <-  DraggableListWidget()

  lyt <- Qt$QVBoxLayout()
  lyt$addWidget(dfcb)
  lyt$addWidget(varList)
  varList$setSizePolicy(Qt$QSizePolicy$Expanding, Qt$QSizePolicy$Expanding)
  setLayout(lyt)

  updateDataSets()
  qconnect(dfcb, "activated", function(ind) {
    updateVarList(dfcb$currentText)
  })
})
@ 
%

Our method to update the data frame choice is a bit convoluted as we try to
keep the currently selected data frame, if possible.
<<>>=
qsetMethod("updateDataSets", VariableSelector, function() {
  curVal <- this$dfcb$currentText
  this$dfcb$clear()
  x <- ls(envir=.GlobalEnv)
  dfs <- x[sapply(x, function(i) is.data.frame(get(i, inherits=TRUE)))]
  if(length(dfs)) {
    this$dfcb$addItems(dfs)
    if(is.null(curVal) || !curVal %in% dfs) {
      this$dfcb$setCurrentIndex(-1)
      updateVarList(NULL)
    } else {
      this$dfcb$setCurrentIndex(which(curVal == dfs))
      updateVarList(curVal)               # curVal NULL, or a name
    }
  }
})
@ 

Finally, we need to update the list of variables to reflect the state
of the combo box selection. Here we define a helper method to display
an appropriate icon based on the class of the variable.
<<>>=
getIconFile <- function(x) UseMethod("getIconFile")
getIconFile.default <- function(x)
  Qt$QIcon(system.file("images/numeric.gif", package="gWidgets"))
getIconFile.factor <- function(x)
  Qt$QIcon(system.file("images/factor.gif", package="gWidgets"))
getIconFile.character <- function(x)
  Qt$QIcon(system.file("images/character.gif", package="gWidgets"))
@ 

This method populates the variable list to reflect the indicated data
frame. As items are automatically drag enabled, we do not need to add
anything more here, as we've implement the \code{mousePressEvent}.
<<results=hide>>=
qsetMethod("updateVarList", VariableSelector, function(df=NULL) {
  this$varList$setDf(df)
  this$varList$clear()
  if(!is.null(df)) {
    d <- get(df)
    sapply(names(d), function(i) {
      item <- Qt$QListWidgetItem(i, this$varList)
      item$setIcon(getIconFile(d[,i]))
    })
  }
})
@ 
\end{example}

\subsection{A table widget}
\label{sec:table-widget}

The \class{QTableWidget} class provides a widget for displaying
tabular data in an item-based approach, similar to
\class{QListWidget}. The \class{QTableView} widget is more flexible,
but also more demanding, as it has the ability to have different data
models (which can be much faster with large tables). As such, only if
your needs are not too complicated this widget will be a good choice.

The dimensions of the table must be set prior to adding items. The methods
\method{setRowCount}{QTableWidget} and
\method{setColumnCount}{QTableWidget} are used.



The \class{QTableWidget} class has a built in model that is built up
item by item. Items are of class \class{QTableWidgetItem} and are
created first, then inserted into the widget by row and column through
the method \method{setItem}. (These operations are not vectorized and
can be slow for large tables.)  Items can be removed by index with
\method{takeItem}{QTableWidget}. The item can be reinserted. The
\method{clear}{QTableWidget} will remove all items, even headers
items, whereas, \method{clearContents}{QTableWidget} will leave the
headers. Both keep the dimensions.

As with \class{QListWidget}, items have various properties that can be
adjusted. The text can be specified to the constructor, or set through
\method{setText}{QTableWidgetItem}. Text alignment is specified
through \method{setTextAlignment}{QTableWidgetItem}. The font may be
configured through \method{setFont}{QTableWidgetItem}. The methods
\method{setBackground}{QTableWidgetItem} and
\method{setForegroup}{QTableWidgetItem} are used to adjust the colors.


Items may also have icons (\method{setIcon}{QTableWidgetItem}),
tooltips (\method{setToolTip}{QTableWidgetItem}), and statusbar tips
(\method{setStatusTip}{QTableWidgetItem}.


Similar to \class{QListWidget}, \class{QTableWidgetItem} instances are
returned by the method \method{item}{QTableWidget}, with a
specification of row and column; and by \method{itemAt}{QTableWidget},
with a specification of a position. The \method
{findItems}{QTableWidget} will return a list of items matching a
string. Also, there is the method
\method{currentItem}{QTableWidget}. From an item, the current column
and row can be found with the methods \method{column}{QTableWidget}
and \method{row}{QTableWidget}

\paragraph{Item flags}
As mentioned, items may have several different properties: are they
editable, draggable, ... To specify, one sets an items flags with
values taken from the \qtenumeration{Qt::ItemFlag} enumeration. The
possible values are: \qcode{NoItemFlags}, \qcode{ItemIsSelectable},
\qcode{ItemIsEditable}, \qcode{ItemIsDragEnabled},
\qcode{ItemIsDropEnabled}, \qcode{ItemIsUserCheckable},
\qcode{ItemIsEnabled}, and \qcode{ItemIsTriState} (has three check
states). To make an item checkable, one must first set the check
state. By default, the widget has all these sets (except no and tri
state). To remove a flag, one can specify all the ones they want, or
use integer arithmetic and subtract. E.g., to remove the editable
attribute one has this possibility:
<<results=hide>>=
item <- Qt$QTableWidgetItem("Not editable")
item$setFlags(item$flags() - Qt$Qt$ItemIsEditable)
@ 


\paragraph{Headers}
Columns may have headers. These are set all at once by specifying a character vector to
\method{setHorizontalHeaderLabels}{QTableWidget}, or can be set with
an item by \method{setHorizontalHeaderItem}{QTableWidget}. The header
is returned by \method{horizontalHeader}{QTableWidget} which has a
method \meth{setVisible} to toggle its visibility. Similarly, rows can
have (vertical) headers.

To specify the width of a column the method
\method{setColumnWidth}{QTableView} is available. One specifies the
column, then the width in pixels.  The method
\method{horizontalHeader}{QTableView} returns an instance of class
\class{QHeaderView}. To make the last column stretch to fill the
available space is specified through the method
\method{setStretchLastSection}{QHeaderView} with a value of
\code{TRUE}.

\paragraph{Sorting and Filtering}

This widget can have its rows sorted by the values of a column through
the method \method{sortItems}{QTableWidget}. One specifies the column
by index, and an order. The default is \qcode{AscendingOrder}, the
alternative is \code{Qt\$Qt\$DescendingOrder}. Sorting should be done
after the table is populated with items.



Rows and columns can be hidden through the methods
\method{setRowHidden}{QTableWidget} and
\method{setColumnHidden}{QTableWidget}. This can be used for filtering
purposes without redrawing the table.


\paragraph{Selection}
\XXX{Does \class{QTableWidgetSelectionRange} work to set the selection?}

For the table widget one can easily select rows, columns, blocks and
even combinations thereof.  An underlying selection model implements
selection, but the \class{QTableWidget} provides an interface. The
currently selected items are returned as a list through the method
\method{selectedItems}{QTableWidget}.

A given cell may be selected by index (row then column) through the
method \method{setCurrentCell}{QTableWidget}, or if the item instance
is known by \method{setCurrentItem}{QTableWidget}. In addition, an
option selection flag from the enumeration
\qtenumeration{QItemSelectionModel::SelectionFlag} can be specified
with values among \qcode{Select}, to add the item to the selection;
\qcode{Clear}, to clear all selection; \qcode{Toggle}, to toggle the
specified item; \qcode{Rows}, to extend the selection to the enclosing
row; and similarly for \qcode{Columns}.  For an item, the method
\method{setSelection}{QTableWidgetItem} takes a logical value to
indicate the selection state.


The current selection can be cleared with by selecting an item with
the \qcode{Clear} attribute, or by grabbing the underlying selection
model and calling its \meth{clearSelection} method. E.g, something like:
<<eval=FALSE>>=
tbl$selectionModel()$clearSelection()
@ 


\paragraph{Signals}

The \class{QTableWidget} class has a number of signals it emits. They
mostly come in pairs: ``cell'' ones passing in the row and column index and
``item'' ones passing in an item reference. For example,
\signal{cellClicked} and \signal{itemClicked}, both called when a cell
is clicked. Also there are \signal{cellDoubleClicked},
\signal{cellEntered}, \signal{cellPressed},
\signal{currentCellChanged} and \signal{cellChanged} (with similar
``item'' ones). Also of interest is the \signal{itemSelectionChanged}
which is called when the selection changes.


\begin{example}{Selection of variables}{eg:qt-selection-from-tablewidget}
  \SweaveInput{ex-qt-table-selection}
\end{example}


\begin{example}{A drag and drop interface to \function{xtabs}}{eg:qt-dnd-table}
  \SweaveInput{ex-qt-dnd-table}
\end{example}



\subsection{A Tree Widget}
\label{sec:tree-widget}

The \constructor{QTreeWidget} provides a tree view based on a coupled
tree model. It is used in a manner similar to the table widget,
however, one must adjust for the heiarchical nature of the data it can display.
The widget shows a specific number of columns, which is specified via
\method{setColumnCount}{QTreeWidget}. The column headers are set through
\method{setHeaderLabels}{QTreeWidget} by specifying a vector of column
names. 


%% items
\paragraph{Tree Widget Items}
The widget organizes itself through items, with each item having $1$
or more columns.  The items in the tree widget are instances of the
\class{QTreeWidgetItem} class. An item displays a value in each
column. The method \method{setText}{QTreeWidgetItem} takes two
arguments, an integer specifying a column, and a value to
display. Similarly, other such item methods require one to specify the
column. These methods include:
\method{setTextAlignment}{QTreeWidgetItem},
\method{setFont}{QTreeWidgetItem},
\method{setToolTip}{QTreeWidgetItem},
\method{setStatusTip}{QTreeWidgetItem}, and
\method{setIcon}{QTreeWidgetItem}. To retrieve these values, the
method \method{data}{QTreeWidgetItem} takes a column number and a
role, such as \code{Qt\$Qt\$DisplayRole} to get the text.


%% heiarchy
\paragraph{Heirarchy}
A tree is used to represent a heiarchy. The items have several methods
related to this. Each item has a \method{parent}{QTreeWidgetItem}
method pointing to the parent item, or \code{NULL} if a top-level
item. The method
\method{child}{QTreeWidgetItem} returns the child item, specified by
index. The index of a given item in the parent is returned by
\method{indexOfChild}{QTreeWidgetItem}. The total number of children
for an item is returned by \method{childCount}{QTreeWidgetItem}. 

New child items are added with either with
\method{addChild}{QTreeWidgetItem}, adding at the end; or
\method{insertChild}{QTreeWidgetItem} adding the child item at the
specified index. Child items are removed by the
\method{removeChild}{QTreeWidgetItem} method or the
\method{takeChild}{QTreeWidgetItem}, if specifying by index. The
latter returns the item to be reparented if desired.

The view can be made to show if a child is present by
calling  \method{setChildIndicatorPolicy}{QTreeWidgetItem} with a
value of \code{Qt\$QTreeWidgetItem\$ShowIndicator} (or one of
\code{DontShowIndicator} or
\code{DontShowIndicatorWhenChildless}).

When an item has children and an indicator is shown, the view may be
expanded by clicking on this indicator. The method
\method{isExpanded}{QTreeWidgetItem} returns \code{TRUE} if
expanded. This state can be set via
\method{setExpanded}{QTreeWidgetItem}.  The methods
\method{setDisabled}{QTreeWidgetItem} and
\method{setHidden}{QTreeWidgetItem} are also available to disable or
hide an item.



%% heiarchchy
The tree widget itself also has methods related to the heirarchy. For
the tree widget, there is an invisible root item, returned by
\method{invisibleRootItem}{QTreeWidget}. The children of this root
item are the ``top-level'' items, These are added through
\method{addTopLevelItem}{QTreeWidget} or the
\method{insertTopLevelItem}{QTreeWidget} methods, the latter requiring
an index to specify where. The basic idea is that a top-level item is
prepared, along with its heirarchy, then added.



%% selection
\paragraph{Selection}
The currently selected item is returned by
\method{currentItem}{QTreeWidget} and may be specified by item view
\method{setCurrentItem}{QTreeWidget}. For more multiple selection, see
the discussion on selection models~\ref{para:selection-models}. 



%% signals
\paragraph{Signals}
The widget emits several signals, most passing the item and the column
to the handler. Some useful signals are \signal{itemClicked},
\signal{itemDoubleClicked}, \signal{itemExpanded}, and
\signal{itemActivated} (for clicking or the \kbd{Enter} key).


\begin{example}{A workspace browser}{eg:qt-workspace-browser}
  \SweaveInput{ex-qt-treewidget}
\end{example}


\section{Item models and their views}
\label{sec:using-model-with}

In this section, we consider models and their views decoupled from
each other. We focus our discussion to tabular data, although we note
that \Qt{} provides various means to provide models for heiarchical
data.



\subsection{Using a data frame for a model}
\label{ssec:using-data-frame}

For tabular data a model can be made quite easily with the constructor
\constructor{qdataFrameModel} provided by \pkg{qtbase}. This function maps a data frame to the
model, returning an instance of class \class{DataFrameModel} a
subclass of \class{QAbstractTableModel}.

The default role is for display of the data. Other roles can be
defined by adding additional columns with a specific naming
convention. A column with name \code{a} can have its role information
specified with another column with name \code{.a.ROLE} where
\code{ROLE} is one of available roles, such as \code{"decoration"}, \code{"edit"}, \code{"toolTip"},
\code{"statusTip"}, or \code{"textAlignment"}.

The following illustrates a basic usage. We use a \class{QTableView}
instance for a view. The model is connected to the view through its
\method{setModel}{QTableView} method.           

\begin{example}{Using \constructor{qdataFrameModel} to list variables
    in a data frame}{eg:qt-list-variables}
  \SweaveInput{ex-qt-qdataFrameModel}
\end{example}



\subsection{Table Models}
\label{ssec:table-models}

The \constructor{qdataFrameModel} creates a subclass of
\class{QAbstractTableModel}, itself of subclass of
\class{QAbstractItemModel}. One can subclass
\class{QAbstractTableModel} to provide a custom model for a view.
This may be useful in different instances, for example, if the cell
columns need to be computed dynamically or if editing of cells is
desired.


%% index
Before discussing methods that must be implemented, we mention some
useful inherited methods.  For a table model, items are organized by
row and column. This allows one to easily refer to an item by
index. The inherited \method{index}{QAbstractTableItem} method uses $0$-based
row and column arguments to return a \class{QModelIndex}
instance. In turn, this index instance has methods \method{row}{QModelIndex}
and \method{column}{QModelIndex} for getting back the coordinate information.

%% match and sort
The \method{match}{QAbstractItemModel} can be used to return items in
a column that match a specific string for a given role. The column is
specified by a model index, the role by one of the
\qtenumeration{Qt::ItemDataRole} enumeration. The
\qtenumeration{Qt:::MatchFlag} specifies how the matching is to
occur. Matches are returned as a list of indices.

The \method{sort}{QAbstractItemModel} method can be used to sort the
data by the values in a column. The column is specified by its index,
and the order is one of \code{Qt\$Qt\$AscendingOrder} or \code{Qt\$Qt\$DescendingOrder}.


\paragraph{Required methods}
The basic implementation of a subclass must provide the methods for
\meth{rowCount}, \meth{columnCount}, and \meth{data}.  The first two
describe the size of the table for any views, the third describes to
the view how to display data for a given role. The signature for the
\meth{data} method is \code{(index, role)}. The \code{index} value, an
instance of \class{QModelIndex}, has methods \meth{row} and
\meth{column}, whereas \code{role} is one of the roles defined in the
\qtenumeration{Qt::ItemDataRole} enumeration. This method should
return the appropriate value for the given role. For example, if one
is displaying numeric data, the \code{display} role might format the
numeric values (showing a fixed number of digits say), yet the
\code{edit} role might display all the digits so accuracy is not
lost. If a role is not implemented, a value of \code{NULL} should be
returned, as this is mapped to a null instance of \class{QVariant}.

One may also implement the \meth{headerData} method to return the
appropriate data to display in the header for a given role. The main
one is \code{display}.

\paragraph{Editable Models}
For editable models, one must implement the \meth{flags} method to
return a flag containing \code{ItemIsEditable} and the \meth{setData}
method. This has signature \code{(index, value, role)} where
\code{value} is a character string containing the edited value. When a
value is updated, one should call the \meth{dataChanged} method to
notify the views that a portion of the model is changed. This method
takes two indices, together specifying a rectangle in the table.


To provide for resizable tables, \code{Qt} requires one to call some
functions so that any connected views can be notified. For example, an
implemented \meth{insertColumns} should call \meth{beginInsertColumns}
before adding the column to the model and then \meth{endInsertColumns}
just after.


\subsection{Table views}
\label{ssec:table-views}

A table model is typically displayed through the \class{QTableView}
widget, although one can use the model -- first column only -- with \class{QListView} or even
\class{QComboBox}. A custom view is also possible, as illustrated
later. The table view widget inherits from \class{QAbstractItemView}
which provides the method \method{setModel}{QAbstractItemView} to link
the underlying model with a view. This link passes along information
about the model being changed back to the view to process and connects
the delegates that allow one to edit values in the view and have the
changes propogate back to the model.

Once, connected, the table view can have its properties adjusted to
control its appearance. For example, columns (and rows) may be hidden
or shown through the \method{setColumnHidden}{QTreeView} method. Their
widths can be adjusted by the mouse, or through
\method{setColumnWidth}{QTreeView}. The grid style can be adjusted
through \method{setGridStyle}{QTreeView}.

The view may allow sorting of the underlying model. This is enabled
through \method{setSortingEnabled}{QTreeView}. The method
\method{sortByColumn}{QTreeView} can be called specifying the column
and a sort order (e.g. \code{Qt\$Qt\$AscendingOrder}).
  

\paragraph{Headers}
The table view has headers, horizontal ones for the columns and
vertical ones for the rows. The methods
\method{verticalHeader}{QTreeView} and
\method{horizontalHeader}{QTreeView} return instances of the
\class{QHeaderView} class. This class has many methods. We mention
\method{setHidden}{QHeaderView}, to suppress the header display;
\method{showSortIndicator}{QHeaderView}, to display a sort arrow; and
\method{setStretchLastSection}, to strech the last section to fill the
space. For tree views, this is \code{TRUE} for horizontal headers but
not for table views.

\paragraph{Selection Models}
\label{para:selection-models}

%% selection mode
The type of selection possible is determined by the
\property{selectionMode}{QAbstractItemView} of the view, the options for which are enumerated in
\qtenumeration{QAbstractItemView::SelectionMode}. Typical values are
\code{SingleSelection} or \code{ExtendedSelection}, which allows one
to extend their selection by pressing the \kbd{Control} or \kbd{Shift} keys while
selecting. 

%% selection model
For abstract item views, the underlying selection is handled by a
selection model, which is found in the \code{selectionModel}
property. The \class{QItemSelectionModel} can return the current
selection by rows through \method{selectedRows}{QItemSelectionModel}
(with an argument to specify the column to check), columns
(\method{selectedColumns}{QItemSelectionModel}) or by index with
\method{selectedIndexes}{QItemSelectionModel}. In each case, a list of
model indices is returned. The method \meth{row} and \meth{column} are
useful then.  The selection model allows one specify if the selection
will apply to the entire row or column of if selection is cell by
cell. This is done through the selection flags
(\qtenumeration{QItemSelectionModel::SelectionFlag})


%% setting selection
The selection can be updated programattically through the
\method{setCurrentIndex}{QItemSelectionModel} method. The index and a
selection flag must be given. The latter enumerated in
\qtenumeration{QItemSelectionModel::SelectionFlag}, with values such
as \code{Select}, to select the item; \code{Deselect}, \code{Clear};
\code{Toggle}; and \code{Rows} and \code{Columns} to select the entire
range.

The selection model emits a few signal, notable
\signal{selectionChanged} is emitted when a new selection is made.




\begin{example}{Using a custom model to edit a data frame}{eg:qt-editable-data}
  \SweaveInput{ex-qt-edit-data-frame}
\end{example}

\subsection{Custom Views}
\label{sec:custom-views}

One can write a custom view for a model. In the example, we show how
to connect a label's text to the values in a column of a model. The
base class for a view of an item model is
\class{QAbstractItemView}. This class has many methods -- that can be
overridden -- to cover keyboard, mouse, scrolling, selection etc. Here
we focus on just enough for our example.

\begin{example}{A label that updates as a model is updated}{eg:qt-custom-view}
  \SweaveInput{ex-qt-custom-view}
\end{example}


\XXX{Should we illustrate a tree model? I don't have a good example to
  do right now and this section is getting a bit long.}
%% \subsection{Tree models}
%% \label{sec:tree-models}

