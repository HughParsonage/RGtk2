
\section{The Qt library}
\label{sec:qt-overview}

\Qt{} is an open-sourced, cross-platform application framework that is
perhaps best known for its widget toolkit. The features of \Qt{} are
divided into about a dozen modules. We highlight some of the more
important and interesting ones:
\begin{description}
\item[Core] Basic utilties, collections, threads, I/O, ...
\item[Gui] Widgets, models, etc for graphical user interfaces
\item[OpenGL] Convenience layer (e.g., 2D drawing API) over OpenGL
\item[Webkit] Embeddable HTML renderer (shared with Safari, Chrome)
\end{description}
Other modules include functionality for networking, XML, SQL
databases, SVG, and multimedia. However, \R{} packages already
provide many of those features.

The history of \Qt{} begins with Haavard Nord and Eirik Chambe-Eng in
1991, and follows with the Trolltech company until 2008, and now
Nokia, a major cell-phone producer. While it was originally not
available as open-source on every platform, as of version 4 it was
released universally under the GPL. With the release of Qt 4.5, Nokia
placed \Qt{} under the LGPL, so it is available for use in proprietary
software, as well. Popular software developed with \Qt{} include the
communication application Skype and the KDE desktop for Linux.

\Qt{} is developed in C++ with extensions that require a special
preprocessor called the \dfn{Meta Object Compiler}
(\acronym{MOC}). The \acronym{MOC} allows for convenient syntax in the
definition of signals, slots (signal handlers), and properties, which
behave very similarly to those of \GTK.

There are many languages with bindings to \Qt{}, and \R{} is one such
language. The \pkg{qtbase} package interfaces with every module of
\Qt. As its name suggests, \pkg{qtbase} forms the base for a number of
\R{} packages that provide high-level special-purpose interfaces to
\Qt{}. The \pkg{qtpaint} package extends the \Rclass{QGraphicsView}
canvas to better support interactive statistical graphics. Features
include: a layered buffering strategy, efficient spatial queries for
mapping user actions to the data, and an OpenGL renderer optimized for
statistical plots. An interface resembling that of the \pkg{lattice}
package is provided for \pkg{qtpaint} by the \pkg{mosaiq} package. The
\pkg{cranvas} package builds on \pkg{qtpaint} to provide a collection
of high-level interactive plots in the conceptual vein of GGobi. A
number of utilities are implemented by \pkg{qtutils}, including an
object browser widget, an \R{} console widget, and a conventional \R{}
graphics device based on \Rclass{QGraphicsView}.

While \pkg{qtbase} is not yet as mature as \pkg{tcltk} and
\pkg{RGtk2}, we include it in this book, as \Qt{} compares favorably
to \GTK{} in terms of GUI features and excels in several areas,
including its fast graphics canvas and integration of the WebKit web
browser.~\footnote{There is a \GTK{} WebKit port, but it is not
  included with \GTK{} itself.} In addition, \Qt{}, as a commercially
supported package, has thorough documentation of its API, including
many C++ examples. However, the complexity of C++ and Qt may present
some challenges to the \R{} user. In particular, the developer should
have a strong grounding in object-oriented programming and have a
basic understanding of memory management.

The \pkg{qtbase} package is developed as part of the
\textit{qtinterfaces} project at R Forge:
\url{https://r-forge.r-project.org/projects/qtinterfaces/}. It depends
on the \Qt{} framework, available as a binary install from
\url{http://qt.nokia.com/}.

%% ML: I like the idea of a quick-start example up front, but it
%% should probably come after the description of the Qt library.

\section{An introductory example}
\label{sec:qt-introductory-example}
\SweaveInput{ex-qtbase}

\section{Classes and objects}
\label{sec:qt-classes-objects}

The \pkg{qtbase} package exports very few objects. The central one is
an environment, \code{Qt}, that represents the \Qt{} library in
\R.~\footnote{ The \code{Qt} object is an instance of
  \class{RQtLibrary}. The \pkg{qtbase} package provides infrastructure
  for binding any conventional C++ library, even those independent of
  \Qt. Third party packages can define their own \class{RQtLibrary}
  object for some other library.  }  The components of this
environment are \class{RQtClass} objects that represent an actual C++
class or namespace.  For example, the \code{QWidget} class is
represented by \code{Qt\$QWidget}:
<<qtwidget-class>>=
Qt$QWidget
@ 

An \class{RQtClass} object contains methods in the class
scope (\textit{static} methods in C++), enumerations defined by the
class, and additional \class{RQtClass} objects representing nested
classes or namespaces. Here we list some of the components of
\class{QWidget} and access one of the enumeration values:
<<>>=
head(names(Qt$QWidget), n = 3)
Qt$QWidget$DrawChildren
@ 
%
Most importantly, however, an instance of \class{RQtClass} is in fact
an \R{} \class{function} object, and serves as the constructor of
instances of the class. For example, we could construct an instance of
\code{QWidget}:
<<qwidget-object>>=
w <- Qt$QWidget()
@ 

The \code{w} object has a class structure that reflects the
class inheritance structure of \Qt:
<<qwidget-class>>=
class(w)
@ 
%
The base class, \class{RQtObject}, is an environment containing
the properties and methods of the instance. For \code{w}, we list
the first few using \function{ls}:
<<>>=
head(ls(w))
@ 

Properties and methods are accessed from the environment in the usual
manner. The most convenient extractor is the \code{\$}
operator, but \code{[[} 
% ]]
and \code{get} will also work. (With the
\code{\$} operator at the command line, completion works.) For
example, a \code{QWidget} has a \code{windowTitle} property which is
used when the widget draws itself with a window:
<<windowTitle>>=
w$windowTitle                           # initially NULL
w$windowTitle <- "a new title"
w$windowTitle
@ 

Although \Qt{} defines methods for accessing properties, the \R{} user
will normally invoke methods that perform some action. For example, we
could show our widget:
<<results=hide>>=
w$show()
@
%

The environment structure of the object masks the fact that the
properties and methods may be defined in a parent class of the
object. For example, a button widget is provided by the
\code{QPushButton} constructor, as in
<<pushButton>>=
b <- Qt$QPushButton()
@ 
%
\class{QPushButton} extends \class{QWidget} and thus inherits the
properties like \code{windowTitle}:
<<pushbutton-class>>=
is(b, "QWidget")                        # Yes
b$windowTitle
@ 
%
It is important to realize this distinction when referencing the
documentation. As with \GTK, the methods are documented with the class
that declares the method.

%% JV: Is there some well-written means to look up where a method is
%% defined? I have this hack, but there should be a better way (I'm
%% thinking it would be useful to find the proper help page for a method,...)
% findMeth <- function(obj, meth_name) {
%   cls <- class(obj)
%   ind <- sapply(cls, function(i) exists(i, envir=Qt))
%   l <- lapply(cls[ind], function(i) ls(get(i, envir=Qt)()))
%   names(l) <- cls[ind]
%   for(i in 1:(length(l)-1))
%     l[[i]] <- setdiff(l[[i]], l[[i+1]])

%   if(!missing(meth_name)) {
%     for(i in 1:length(l)) {
%       if(meth_name %in% l[[i]])
%         print(names(l)[i])
%     }
%   }
%   invisible(l)
% }


\section{Methods and dispatch}

In C++, it is possible to have multiple methods and constructors with
the same name, but different signatures. This is called
\dfn{overloading}. An overloaded method is roughly similar to an S4
generic, save the obvious difference that an S4 generic does not
belong to any class. The selected overload is that with the signature
that best matches the types of the arguments. The exact rules of
overload resolution are beyond our scope.

It is particularly common to overload constructors. For example, a
simple push button can be constructed in several different ways. Here
again is the invocation of the \class{QPushButton} constructor with no
arguments:
<<>>=
b <- Qt$QPushButton()
@ 
%
By convention, all classes derived from \class{QObject}, including
\class{QWidget}, provide a constructor that accepts a parent
\class{QObject}. This has important consequences that are discussed
later. We demonstrate this for \class{QPushButton}:
<<constructor-parent>>=
w <- Qt$QWidget()
b <- Qt$QPushButton(w)
@ 
%
An alternative constructor for \class{QPushButton} accepts the text
for the label on the button:
<<constructor-text>>=
b <- Qt$QPushButton("Button text")
@
%
Buttons may also have icons, for example
<<constructor-icon-parent>>=
icon <- Qt$QIcon(system.file("images/ok.gif", package="gWidgets"))
b <- Qt$QPushButton(icon, "Ok")
@ 
%
We have passed three different types of object as the first argument
to \function{Qt\$QPushButton}: a \class{QWidget}, a string, and
finally a \class{QIcon}. The dispatch depends only on the type of
argument, unlike the constructors in \pkg{RGtk2}, which dispatch based
on which arguments are specified. (In particular, dispatch is based on
position of argument, but not on names given to arguments. We use
names only for clarity in our examples.)

The function \function{qmethods} will show the methods defined for a
class. It returns a data frame with variables indicating the name,
return value, signature, and whether the method is protected and
static. For example, to learn the methods for a simple button, we
would call:
<<>>=
out <- qmethods(Qt$QPushButton)
dim(out)
head(out)
@ 

\section{Properties}
\label{sec:properties}

%% JV How does a subclass define properties so that qproperties lists
%% them. (A qsetProperty function?)

Every \class{QObject}, which includes every widget, may declare a set
of properties that represent its state. We list some of the available
properties for our button:
<<list-properties>>=
head(qproperties(b))
@
%
As shown in the table, every property has a type and logical settings
for whether the property is readable and/or writeable. Virtually every
property value may be read, and it is common for properties to be
read-only. For example, we can fully manipulate the \code{objectName}
property, but our attempt to modify the \code{modal} property fails: 
<<modal-property>>=
b$objectName <- "My button"
b$objectName
b$modal
try(b$modal <- TRUE)
@ 

\Qt{} provides accessor methods for getting and setting
properties. The getter methods have the same name as the property, so
they are masked at the \R{} level. Setter methods are available and
are typically named with the word "set" followed by the property name:
<<windowTitleMethod, results=hide>>=
b$setObjectName("My button")
@ 
% 
%% JV: I'm not so sure I'd recommend this, but will defer
However, it is recommended to use the replacement syntax shown in the
previous example, for the sake of symmetry.

\section{Signals}
\label{sec:qt-signals}



\Qt{} in C++ uses an architecture of signals and slots to have
components communicate with each other. A component emits a signal
when some event happens, such as a user clicking on a button. \Qt{}
allows one to define a special type of method known as a slot in
another component (or the same) that can be connected to the signal as
the handler. The two components are decoupled as the emitter does not
need to know about the receiver except through the signal
connection. In \R{}, any function can be treated as a slot and
connected as a signal handler. This is similar to the signal handling
in \pkg{RGtk2}. The function \function{qconnect} establishes the
connection of an R function to a signal. For example
<<results=hide>>=
b <- Qt$QPushButton("click me")
qconnect(b, "clicked", function() print("ouch"))
b$show()
@ 

Signals are defined by a class and are inherited by
subclasses.  Here, we list some of the available signals for the
\class{QPushButton} class:
<<qt-signals-list>>=
tail(qsignals(Qt$QPushButton))
@ 
%
The signal definition specifies the callback signature, given in the
\code{signature} column. Like other methods, signals can be overloaded
so that there are multiple signatures for a given signal name. Signals
can also have default arguments, and arguments with a default value
are optional in the signal handler. We see this for the \code{clicked}
signal, where the \code{bool} (logical) argument, indicating whether
the button is checked, has a default value of \code{FALSE}. The
\code{clicked} signal is automatically overloaded with a signature
without any arguments.

The \function{qconnect} function attempts to pick the correct
signature by considering the number of formal arguments in the
callback. When two signatures have the same number of arguments, one
will be chosen arbitrarily. To connect to a specific signature, the
full signature, rather than only the name, should be passed to
qconnect. For example, the following is equivalent to the invocation
of \function{qconnect} above:
<<qt-signals-qconnect-sig, results=hide>>=
qconnect(b, "clicked(bool)", function(checked) print("ouch"))
@ 

Any object passed to the optional argument
\argument{user.data}{qconnect} is passed as the last argument to the
signal handler. The user data serves to parameterize the callback. In
particular, it can be used to pass in a reference to the sender object itself.

The \code{qconnect} function returns a dummy \class{QObject} instance
that provides the slot that wraps the \R{} function. This dummy object
can be used with the \method{disconnect}{QObject} method on the
sender to break the signal connection:
<<qt-signals-disconnect>>=
proxy <- qconnect(b, "clicked", function() print("ouch"))
b$disconnect(proxy)
@ 

One can block all signals from being emitted with
the \method{blockSignals}{QObject} method, which takes a logical value
to toggle whether the signals should be blocked.

Unlike \GTK, \Qt{} widgets generally do not emit hardware events, such
as a mouse press, via signals. Instead, a method in the widget is
invoked upon receipt of an event. The developer is expected to extend
the widget and override the method to catch the event. The apparent
philosophy of \Qt{} is that hardware events are low-level and thus
should be handled by the widget, not some other instance. We will
discuss extending classes in Section~\ref{sec:defin-class-meth}.
Example~\ref{eg:qt-dnd} demonstrates handling widget events.

\section{Enumerations and flags}
\label{sec:qt-enums}

Often, it is useful to have discrete variables with more than two
states, in which case a logical value is no longer sufficient.  For
example, the label widget has a property for how its text is
aligned. It supports the alignment styles left, right, center, top,
bottom, etc. These styles are enumerated by integer values and
\Qt{} defines these by name within the relevant class or,
for global enumerations, in the \code{Qt} namespace. Here are examples
of both:
<<Enumeration-example>>=
Qt$Qt$AlignRight
Qt$QSizePolicy$Exanding
@
% 
The first is the value for right alignment from the
\qtenumeration{Alignment} enumeration in the \code{Qt} namespace,
while the second is from the \qtenumeration{Policy} enumeration in the
\class{QSizePolicy} class (referenced here by \qtenumeration{QSizePolicy::Policy}).

Although these enumerations can be specifed directly as integers, they are
given the class \class{QtEnum} and have the overloaded operators
\OR{} and \AND{} to combine values bitwise. This makes the most
sense when the values correspond to bit flags, as is the case for the
alignment style. For example, aligning the text in a label in the upper
right can be done through
<<alignexample, results=hide>>=
l <- Qt$QLabel("Our text")
l$alignment <- Qt$Qt$AlignRight | Qt$Qt$AlignTop
@ 
%
To check if the alignment is to the right, we could query by:
<<>>=
as.logical(l$alignment & Qt$Qt$AlignRight)
@ 

\section{Extending Qt Classes from R}
\label{sec:qt-defin-class-meth}

As \Qt{} is implemented in an object-oriented language, C++, the
designers of the API expect the developer to extend \Qt{} classes,
like \class{QWidget}, during the normal course of GUI
development. This is a significant difference from \GTK, where it is
only necessary to extend classes when one needs to fundamentally alter
the behavior of a widget. The \pkg{qtbase} package allows the \R{}
user to extend C++ classes in order to enhance the features of \Qt.
The \pkg{qtbase} package includes functions \function{qsetClass} and
\function{qsetMethod} to create subclasses and their methods. Methods
may override virtual methods in an ancestor C++ class, and C++ code
will invoke the \R/ implementation when calling the overridden
virtual. Properties may be defined with a getter and setter
function. If a type is specified, and the class derives from
\class{QObject}, the property will be exposed by \Qt. It is also
possible to store arbitrary objects in an instance of an \R/ class; we
will refer to these as dynamic fields. They are private to the class
but are otherwise similar to attributes on any R object. Their type is
not checked, and they are not exposed as \Qt/ properties. They are
useful as a storage mechanism for implementing properties.

\subsection{Defining a Class}
\label{sec:qt-defin-class}

Here, we extend \Rcode{QMessageBox} to create a dialog, shown when the
application is closing, that asks the user whether a document should
be saved:
<<results=hide>>=
qsetClass("SubClass", Qt$QWidget)
@ 
% 
This creates a variable named \code{SubClass} in the workspace:
<<qt-classes-show-class>>=
SubClass
@ 
% 
Its value is an \class{RQtClass} object that behaves like the
\class{RQtClass} for the built-in classes, such as
\code{Qt\$QWidget}. There are no static methods or enumerations in an
\R/ class, so the class object is essentially the constructor:
<<qt-classes-constructor>>=
instance <- SubClass()
@ 

By default, the constructor delegates directly to the constructor in
the parent class. A custom constructor is often useful, for example,
to initialize fields or to make a compound widget.  The function
implementing the constructor should be passed as the
\argument{constructor}{qsetClass} argument. By convention, \class{QObject}
subclasses should provide a \code{parent} constructor argument, for
specifying the parent object. A typical usage would be
<<results=hide>>=
qsetClass("SubClass2", Qt$QWidget, function(title, prop, parent=NULL) {
  super(parent)
  this$property <- prop
  setWindowTitle(title)
})
@ 
% 
Within the body of a constructor, the \function{super} variable refers
to the constructor of the parent class, often called the ``super''
class. In the above, we call \code{super} to delegate the registration
of the parent to the \class{QWidget} constructor. Another special
symbol in the body of a constructor is \code{this}, which refers to
the instance being constructed. We can set and implicitly create
fields in the instance by using the same syntax as setting
properties.

\subsection{Defining Methods}
\label{sec:qt-defin-methods}


One may define new methods, or override methods from a base class
through the \function{qsetMethod} function.  For example, accessors
for a field may be defined with
<<results=hide>>=
qsetMethod("field", SubClass, function() field)
qsetMethod("setField", SubClass, function(value) {
  this$field <- value
})
@ 
% 
For an override of an existing method to be visible from C++, the
method must be declared virtual in C++. The
\argument{access}{qsetMethod} argument specifies the scope of the
method: \qcode{public}, \qcode{protected}, or \qcode{private}. These
have the same meaning as in C++.

As with a constructor, the symbol \code{this} in a method definition
refers to the instance.  There is also a \Rfunction{super} function
that behaves similarly to the \Rfunction{super} found in a
constructor: it searches for an inherited method of a given name and
invokes it with the passed arguments:
<<results=hide>>=
qsetMethod("setVisible", SubClass, function(value) {
  message("Visible: ", value)
  super("setVisible", value)
})
@ 
% 
In the above, we intercept the setting of the visibility of our
widget. If we hide or show the widget, we will receive a notification
to the console:
<<subclass-show,results=hide>>=
instance$show()
@ 
% 
This is somewhat similar to the behavior of
\Rfunction{callNextMethod}, except \Rfunction{super} is not restricted
to calling the same method.

\subsection{Defining Signals and Slots}
\label{sec:qt-defin-sig-slots}

Two special types of methods are slots and signals, introduced earlier
in the chapter. These exist only for \class{QObject} derivatives. Most
useful are signals. Here we define a signal:
<<qt-overview-qsetSignal>>=
qsetSignal("somethingHappened", SubClass)
@ 
%
If the signal takes an argument, we need to indicate that in the
signature:
<<qt-overview-qsetSignal-sig>>=
qsetSignal("somethingHappenedAtIndex(int)", SubClass)
@ 
%
Writing a signature requires some familiarity with C/C++ types and
syntax, but this is concise and consistent with how \Qt\/ describes
its methods. Although almost always public, it is possible to make a
signal protected or private, via the \argument{access}{qsetSignal}
argument.

Defining a slot is very similar to defining a signal, except a method
implementation must be provided as an R function:
<<qt-overview-qsetSlot>>=
qsetSlot("doSomethingToIndex(int)", SubClass, function(index) {
  # ....
})
@ 
%
The advantage of a slot compared to a method is that a slot is exposed
to the \Qt{} metaobject system. This means that a slot could be called
from another dynamic environment, like Javascript running in the
\class{QScript} module or via D-Bus with the \class{QDBus} module.

%% TODO: Example here? Or just refer to other examples?

%% JV: Agreed. this section needs to  be reworked. It is hard to find
%% the key information: qsetClass and a conversation about
%% constructors and scope (super, this), and qsetMethod and a
%% conversation about inheritance and scope (super, this). As well, I
%% find the example a bit awkward too. The bit about
%% minimumheight (too kludgy), the call of widget as it isn't a line
%% edit, ... How do you add an icon in a line edit widget?


\section{\class{QWidget} Basics}
\label{sec:comm-meth-qwidg}

The widgets we discuss in the next section inherit many properties and
methods from the base \class{QObject} and \class{QWidget} classes. The
\class{QObject} class is the base class and forms the basis for the
object heirarchy. It implements the event processing and property
systems. The \class{QWidget} class is the base class for all widgets
and implements their shared functionality.

Upon construction, widgets are invisible, so that they may be
configured behind the scenes. The \property{property}{QWidget}
property controls whether a widget is visible. 
<<qt-overview-visible>>=
w <- Qt$QWidget()
w$visible
w$visible <- TRUE
w$visible
@ 
%
The \method{show}{QWidget} and \method{hide}{QWidget} methods are
the corresponding convenience functions for making a widget visible
and invisible, respectively. 
<<qt-overview-show-hide>>=
w$show()
w$visible
w$hide()
w$visible
@ 
%
There is an S3 method for \meth{print} on \class{QWidget} that invokes
\method{show}{QWidget}. Whenever a widget is shown, all of its
children are also made visible. The method \method{raise}{QWidget}
will raise the window to the top of the stack of windows.

Similary, the property \property{enabled}{QWidget} controls whether a
widget is sensitive to user input, including mouse events.
<<qt-overview-enabled>>=
b <- Qt$QPushButton("button")
b$enabled <- FALSE
b$enabled
@ 
%

Only one widget can have the keyboard focus at once. The user shifts
the focus by tab-navigation or mouse clicks (unless customized, see
\method{focusPolicy}{QWidget}). When a widget has the focus, its
\property{focus}{QWidget} property is \code{TRUE}. The property is
read-only; the focus may be shifted to a widget by calling its
\method{setFocus}{QWidget} method.

\Qt{} has a number of mechanisms for the user to query a widget for
some description of its purpose and usage. Tooltips, stored as a
string in the \property{toolTip}{QWidget} property, may be shown the
user hovers the mouse over the widget. Similarly, the
\property{statusTip}{QWidget} property holds a string to be shown in
the statusbar instead of a popup window. Finally, \Qt/ provides a
``What's This?'' tool that will show the text in the
\property{whatsThis}{QWidget} property in response to query, such as
pressing \kbd{SHIFT+F1} when the widget has focus.

Except for top-level windows, the position and size of a widget are
determined automatically by a layout algorithm; see
Chapter~\ref{cha:layout-managers}. To specify the size of a top-level
window, manipulate the \property{size}{QWidget} property, which
holds a \class{QSize} object: 
<<qt-overview-size>>=
w$size <- qsize(400, 400)
## or
w$resize(400, 400)
w$show()
@ 
%
We create the \class{QSize} object with the \function{qsize}
convenience function implemented by the \pkg{qtbase} package. The
\method{resize}{QWidget} method is another convenient shortcut. One
should generally configure the size of a window before showing
it. This helps the window manager optimally place the window.

\subsection{Fonts}
\label{sec:fonts}

Fonts in \Qt{} are represented by the \class{QFont} class. The
\pkg{qtbase} package defines a convenience constructor for \class{QFont}
called \function{qfont}. The
constructor accepts a \code{family}, such as
\code{helvetica}; \code{pointsize}, an integer; \code{weight}, an
enumerated value such as \code{Qt\$QFont\$Light} (or \code{Normal},
\code{DemiBold}, \code{Bold}, or \code{Black}); and whether the font
should be italicized, as a logical. Defaults are obtained from the
application font, returned by \code{Qt\$QApplication\$font()}.

For example, we could create a 12 point, bold, italicized font from
the helvetica family:
<<>>=
f <- qfont(family="helvetica", pointsize=12,  weight=Qt$QFont$Bold, 
           italic=TRUE)
@ 

The font for a widget is stored in the \property{font}{QWidget}
property. For example, we change the font for a label:
<<results=hide>>=
l <- Qt$QLabel("Text for the label")
l$font$toString()
l$font <- f
l$font$toString()
@ 

The \class{QFont} class has several methods to query the font and to
adjust properties. For example, there are the methods
\method{setFamily}{QFont}, \method{setUnderline}{QFont},
\method{setStrikeout}{QFont} and \method{setBold}{QFont} among others.


%% Palettes (colors); roles

\subsection{Styles}
\label{sec:styles}

\paragraph{Palette}

Every platform has its own distinct look and feel, and an application
should conform to platform conventions. \Qt{} hides these details from
the application. Every widget has a palette, stored in its
\property{palette} property and represented by a \class{QPalette}
object. A \class{QPalette} maps the state of a widget to a group of
colors that is used for painting the widget. The possible states are
\code{active}, \code{inactive} and \code{disabled}. Each color within
a group has specific role, as enumerated in
\qtenumeration{QPalette::ColorRole}. Examples include the color for
background (\code{Window}), the foreground (\code{WindowText}) and the
selected state (\code{Highlight}). \Qt{} chooses the correct default
palette depending on the platform and the type of widget. One can
change the colors used in rendering a widget by manipulating the
palette, as illustrated in Example~\ref{eg:qt-dnd}.

\paragraph{Style Sheets}
\label{ssec:style-sheets}

Cascading style sheets (CSS) are used by web deisgners to decouple the
layout and look and feel of a web page from the content of the
page. It is possible to customize the rendering of a widget using CSS
syntax. The supported syntax is described in the overview on
stylesheets provided with \Qt{} documentation and is not summarized
here, as it is quite readable.

The style sheet for a widget is stored in its
\property{styleSheet}{QWidget} property, as a string. For example, for
a button, we could set the background to white and the foreground to red:
<<qt-overview-stylesheets>>=
b <- Qt$QPushButton("Style sheet example")
b$show()
b$styleSheet <- "QPushButton {color: red; background: white}"
@ 

The CSS syntax may be unfamiliar to \R/ programmers, so the \pkg{qtbase}
package provides an alternative interface that is reminiscent of the
\function{par} function. We specify the above stylesheet in this syntax:
<<qt-overview-qsetStyleSheet>>=
qsetStyleSheet(color = "red", background = "white", what = "QPushButton", 
               widget = b)
@ 
%
The \code{widget} argument defaults to \code{NULL}, which applies the
stylesheet application-wide through the \class{QApplication}
instance. The default for \code{what} is \code{"*"}, meaning that the
stylesheet applies to any widget class. The following would cause all
widgets in the application to have the same colors as the button:
<<qt-overview-qsetStyleSheet-defaults, eval=FALSE>>=
qsetStyleSheet(color = "red", background = "white")
@ 

\begin{example}{A ``error label''}{eg:qt-error}
  
  %% JV: Replace with this: (drawback: no a custom constructor, issue with
  %% base:::paste, versus paste is a good one; style sheet example; 

  This example extends the line edit widget to display an error state
  via an icon embedded within the entry box. Such a widget might prove
  useful when one is validating entered values. Our implementation
  uses a stylesheet to place the icon in the background and to prevent
  the text from overlapping the icon.

  To indicate an error, we will add an icon and set the tooltip to
  display an informative message. The constructor will be the default,
  so our class is defined with:
<<LineEditWithError, results=hide>>=
qsetClass("LineEditWithError", Qt$QLineEdit)
@   

  The main method sets the error state. We use stye sheets to place an
  image to the left of the entry message and set the tooltip.
<<>>=
qsetMethod("setError", LineEditWithError, function(msg) {
  f <- system.file("images/cancel.gif", package="gWidgets")
  qsetStyleSheet("background-image" = sprintf("url(%s)", f),
                 "background-repeat" = "no-repeat",
                 "background-position" = "left top",
                 "padding-left" = "20px",
                 widget = this)
  setToolTip(msg)
})
@ 
% 

  We can clear the error by resetting the properties to \code{NULL}.
<<results=hide>>=
qsetMethod("clearError", LineEditWithError, function() {
  setStyleSheet(NULL)
  setToolTip(NULL)
})
@ 
% 

  Finally, to test this out, we have the following
<<>>=
e <- LineEditWithError()
e$text <- "The quick brown fox..."
e$setError("Replace with better boilerplate text")
@ 
% 
<<echo=FALSE, results=hide>>=
e$show()
e$raise()
@ 

\end{example}
