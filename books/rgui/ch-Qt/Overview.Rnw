
%% ML: I like the idea of a quick-start example up front, but it
%% should probably come after the description of the Qt library.

\section{An introductory example}
\label{sec:qt-introductory-example}
\SweaveInput{ex-qtbase}

\section{The Qt library}
\label{sec:qt-overview}

\XXX{An overview of Qt, qtbase and its development, Flesh me out}

\Qt{} is an open-sourced, cross-platform application framework that is
perhaps best known for its widget toolkit. The features of \Qt{} are
divided into about a dozen modules. We highlight some of the more
important and interesting ones:
\begin{description}
\item[Core] Basic utilties, collections, threads, I/O, ...
\item[Gui] Widgets, models, etc for graphical user interfaces
\item[OpenGL] Convenience layer (e.g., 2D drawing API) over OpenGL
\item[Webkit] Embeddable HTML renderer (shared with Safari, Chrome)
\end{description}
Other modules include functionality for networking, XML, SQL
databases, SVG, and multimedia. However, \R{} packages already
provide many of those features.

The history of \Qt{} begins with Haavard Nord and Eirik Chambe-Eng in
1991, and follows with the Trolltech company until 2008, and now
Nokia, a major cell-phone producer. While it was originally not
available as open-source on every platform, as of version 4 it was
released universally under the GPL. With the release of Qt 4.5, Nokia
placed \Qt{} under the LGPL, so it is available for use in proprietary
software, as well. Popular software developed with \Qt{} include the
communication application Skype and the KDE desktop for Linux.

\Qt{} is developed in C++ with extensions that require a special
preprocessor called the \dfn{Meta Object Compiler}
(\acronym{MOC}). The \acronym{MOC} allows for convenient syntax in the
definition of signals, slots (signal handlers), and properties, which
behave very similarly to those of \GTK.

There are many languages with bindings to \Qt{}, and \R{} is one such
language. The \pkg{qtbase} package interfaces with every module
of \Qt. As its name suggests, \pkg{qtbase} forms the base for a number
of \R{} packages that provide high-level special-purpose interfaces to
\Qt{}. As these are still early in development, they will not be
mentioned here.

%% JV: We will mention qtpaint, do we want this last sentence above?

While \pkg{qtbase} is not yet as mature as \pkg{tcltk} and
\pkg{RGtk2}, we include it in this book, as \Qt{} compares favorably
to \GTK{} in terms of GUI features and excels in several areas,
including its fast graphics canvas and integration of the WebKit web
browser.~\footnote{There is a \GTK{} WebKit port, but it is not
  included with \GTK{} itself.} In addition, \Qt{}, as a commercially
supported package, has thorough documentation of its API, including
many C++ examples. However, the complexity of C++ and Qt may present
some challenges to the \R{} user. In particular, the developer should
have a strong grounding in object-oriented programming and have a
basic understanding of memory management.

The \pkg{qtbase} package is developed as part of the
\textit{qtinterfaces} project at R Forge:
\url{https://r-forge.r-project.org/projects/qtinterfaces/}. It depends
on the \Qt{} framework, available as a binary install from
\url{http://qt.nokia.com/}.

\section{Classes and objects}
\label{sec:qt-classes-objects}

The \pkg{qtbase} package exports very few objects. The central one is
an environment, \code{Qt}, that represents the \Qt{} library in
\R.~\footnote{ The \code{Qt} object is an instance of
  \class{RQtLibrary}. The \pkg{qtbase} package provides infrastructure
  for binding any conventional C++ library, even those independent of
  \Qt. Third party packages can define their own \class{RQtLibrary}
  object for some other library.  }  The components of this
environment are \class{RQtClass} objects that represent an actual C++
class or namespace.  For example, the \code{QWidget} class is
represented by \code{Qt\$QWidget}:
<<qtwidget-class>>=
Qt$QWidget
@ 

An \class{RQtClass} object contains methods in the class
scope (\textit{static} methods in C++), enumerations defined by the
class, and additional \class{RQtClass} objects representing nested
classes or namespaces. Here we list some of the components of
\class{QWidget} and access one of the enumeration values:
<<>>=
head(names(Qt$QWidget), n = 3)
Qt$QWidget$DrawChildren
@ 
%
Most importantly, however, an instance of \class{RQtClass} is in fact
an \R{} \class{function} object, and serves as the constructor of
instances of the class. For example, we could construct an instance of
\code{QWidget}:
<<qwidget-object>>=
w <- Qt$QWidget()
@ 

The \code{w} object has a class structure that reflects the
class inheritance structure of \Qt:
<<qwidget-class>>=
class(w)
@ 
%
The base class, \class{RQtObject}, is an environment containing
the properties and methods of the instance. For \code{w}, we list
the first few using \function{ls}:
<<>>=
head(ls(w))
@ 

Properties and methods are accessed from the environment in the usual
manner. The most convenient extractor is the \code{\$}
operator, but \code{[[} 
% ]]
and \code{get} will also work. (With the
\code{\$} operator at the command line, completion works.) For
example, a \code{QWidget} has a \code{windowTitle} property which is
used when the widget draws itself with a window:
<<windowTitle>>=
w$windowTitle                           # initially NULL
w$windowTitle <- "a new title"
w$windowTitle
@ 

Although \Qt{} defines methods for accessing properties, the \R{} user
will normally invoke methods that perform some action. For example, we
could show our widget:
<<results=hide>>=
w$show()
@
%

The environment structure of the object masks the fact that the
properties and methods may be defined in a parent class of the
object. For example, a button widget is provided by the
\code{QPushButton} constructor, as in
<<pushButton>>=
b <- Qt$QPushButton()
@ 
%
\class{QPushButton} extends \class{QWidget} and thus inherits the
properties like \code{windowTitle}:
<<pushbutton-class>>=
is(b, "QWidget")                        # Yes
b$windowTitle
@ 
%
It is important to realize this distinction when referencing the
documentation. As with \GTK, the methods are documented with the class
that declares the method.

%% JV: Is there some well-written means to look up where a method is
%% defined? I have this hack, but there should be a better way (I'm
%% thinking it would be useful to find the proper help page for a method,...)
% findMeth <- function(obj, meth_name) {
%   cls <- class(obj)
%   ind <- sapply(cls, function(i) exists(i, envir=Qt))
%   l <- lapply(cls[ind], function(i) ls(get(i, envir=Qt)()))
%   names(l) <- cls[ind]
%   for(i in 1:(length(l)-1))
%     l[[i]] <- setdiff(l[[i]], l[[i+1]])

%   if(!missing(meth_name)) {
%     for(i in 1:length(l)) {
%       if(meth_name %in% l[[i]])
%         print(names(l)[i])
%     }
%   }
%   invisible(l)
% }


\section{Methods and dispatch}

In C++, it is possible to have multiple methods and constructors with
the same name, but different signatures. This is called
\dfn{overloading}. An overloaded method is roughly similar to an S4
generic, save the obvious difference that an S4 generic does not
belong to any class. The selected overload is that with the signature
that best matches the types of the arguments. The exact rules of
overload resolution are beyond our scope.

It is particularly common to overload constructors. For example, a
simple push button can be constructed in several different ways. Here
again is the invocation of the \class{QPushButton} constructor with no
arguments:
<<>>=
b <- Qt$QPushButton()
@ 
%
By convention, all classes derived from \class{QObject}, including
\class{QWidget}, provide a constructor that accepts a parent
\class{QObject}. This has important consequences that are discussed
later. We demonstrate this for \class{QPushButton}:
<<constructor-parent>>=
w <- Qt$QWidget()
b <- Qt$QPushButton(w)
@ 
%
An alternative constructor for \class{QPushButton} accepts the text
for the label on the button:
<<constructor-text>>=
b <- Qt$QPushButton("Button text")
@
%
Buttons may also have icons, for example
<<constructor-icon-parent>>=
icon <- Qt$QIcon(system.file("images/ok.gif", package="gWidgets"))
b <- Qt$QPushButton(icon, "Ok")
@ 
%
We have passed three different types of object as the first argument
to \function{Qt\$QPushButton}: a \class{QWidget}, a string, and
finally a \class{QIcon}. The dispatch depends only on the type of
argument, unlike the constructors in \pkg{RGtk2}, which dispatch based
on which arguments are specified. (In particular, dispatch is based on
position of argument, but not on names given to arguments. We use
names only for clarity in our examples.)

\section{Properties}
\label{sec:properties}

%% JV How does a subclass define properties so that qproperties lists
%% them. (A qsetProperty function?)

Every \class{QObject}, which includes every widget, may declare a set
of properties that represent its state. We list some of the available
properties for our button:
<<list-properties>>=
head(qproperties(b))
@
%
As shown in the table, every property has a type and logical settings
for whether the property is readable and/or writeable. Virtually every
property value may be read, and it is common for properties to be
read-only. For example, we can fully manipulate the \code{objectName}
property, but our attempt to modify the \code{modal} property fails: 
<<modal-property>>=
b$objectName <- "My button"
b$objectName
b$modal
try(b$modal <- TRUE)
@ 

\Qt{} provides accessor methods for getting and setting
properties. The getter methods have the same name as the property, so
they are masked at the \R{} level. Setter methods are available and
are typically named with the word "set" followed by the property name:
<<windowTitleMethod, results=hide>>=
b$setObjectName("My button")
@ 
% 
%% JV: I'm not so sure I'd recommend this, but will defer
However, it is recommended to use the replacement syntax shown in the
previous example, for the sake of symmetry.

\section{Signals}
\label{sec:qt-signals}



\Qt{} in C++ uses an architecture of signals and slots to have
components communicate with each other. A component emits a signal
when some event happens, such as a user clicking on a button. \Qt{}
allows one to define a special type of method known as a slot in
another component (or the same) that can be connected to the signal as
the handler. The two components are decoupled as the emitter does not
need to know about the receiver except through the signal
connection. In \R{}, any function can be treated as a slot and
connected as a signal handler. This is similar to the signal handling
in \pkg{RGtk2}. The function \function{qconnect} establishes the
connection of an R function to a signal. For example
<<results=hide>>=
b <- Qt$QPushButton("click me")
qconnect(b, "clicked", function() print("ouch"))
b$show()
@ 

Signals are defined by a class and are inherited by
subclasses.  Here, we list some of the available signals for the
\class{QPushButton} class:
<<qt-signals-list>>=
tail(qsignals(Qt$QPushButton))
@ 
%
The signal definition specifies the callback signature, given in the
\code{signature} column. Like other methods, signals can be overloaded
so that there are multiple signatures for a given signal name. Signals
can also have default arguments, and arguments with a default value
are optional in the signal handler. We see this for the \code{clicked}
signal, where the \code{bool} (logical) argument, indicating whether
the button is checked, has a default value of \code{FALSE}. The
\code{clicked} signal is automatically overloaded with a signature
without any arguments.

The \function{qconnect} function attempts to pick the correct
signature by considering the number of formal arguments in the
callback. When two signatures have the same number of arguments, one
will be chosen arbitrarily. To connect to a specific signature, the
full signature, rather than only the name, should be passed to
qconnect. For example, the following is equivalent to the invocation
of \function{qconnect} above:
<<qt-signals-qconnect-sig, results=hide>>=
qconnect(b, "clicked(bool)", function(checked) print("ouch"))
@ 

Any object passed to the optional argument
\argument{user.data}{qconnect} is passed as the last argument to the
signal handler. The user data serves to parameterize the callback. In
particular, it can be used to pass in a reference to the sender object itself.

The \code{qconnect} function returns a dummy \class{QObject} instance
that provides the slot that wraps the \R{} function. This dummy object
can be used with the \method{disconnect}{QObject} method on the
sender to break the signal connection:
<<qt-signals-disconnect>>=
proxy <- qconnect(b, "clicked", function() print("ouch"))
b$disconnect(proxy)
@ 

One can block all signals from being emitted with
the \method{blockSignals}{QObject} method, which takes a logical value
to toggle whether the signals should be blocked.

Unlike \GTK, \Qt{} widgets generally do not emit hardware events, such
as a mouse press, via signals. Instead, a method in the widget is
invoked upon receipt of an event. The developer is expected to extend
the widget and override the method to catch the event. The apparent
philosophy of \Qt{} is that hardware events are low-level and thus
should be handled by the widget, not some other instance. We will
discuss extending classes in Section~\ref{sec:defin-class-meth}.
Example~\ref{eg:qt-dnd} demonstrates handling widget events.

\section{Enumerations and flags}
\label{sec:qt-enums}

Often, it is useful to have discrete variables with more than two
states, in which case a logical value is no longer sufficient.  For
example, the label widget has a property for how its text is
aligned. It supports the alignment styles left, right, center, top,
bottom, etc. These styles are enumerated by integer values and
\Qt{} defines these by name within the relevant class or,
for global enumerations, in the \code{Qt} namespace. Here are examples
of both:
<<Enumeration-example>>=
Qt$Qt$AlignRight
Qt$QSizePolicy$Exanding
@
% 
The first is the value for right alignment from the
\qtenumeration{Alignment} enumeration in the \code{Qt} namespace,
while the second is from the \qtenumeration{Policy} enumeration in the
\class{QSizePolicy} class (referenced here by \qtenumeration{QSizePolicy::Policy}).

Although these enumerations can be specifed directly as integers, they are
given the class \class{QtEnum} and have the overloaded operators
\OR{} and \AND{} to combine values bitwise. This makes the most
sense when the values correspond to bit flags, as is the case for the
alignment style. For example, aligning the text in a label in the upper
right can be done through
<<alignexample, results=hide>>=
l <- Qt$QLabel("Our text")
l$alignment <- Qt$Qt$AlignRight | Qt$Qt$AlignTop
@ 
%
To check if the alignment is to the right, we could query
by:~\footnote{As flags, combinations of enumerations, are not stored
  as integers they are not of class \class{QtEnum}, so the algebra of
  these operators is limited.}
%% JV: I added this footnote, not sure it isn't too pedantic but you
%% cant do thinkgs like (enum1 | enum2) & (enum1 | enum3)
<<>>=
as.logical(l$alignment & Qt$Qt$AlignRight)
@ 



\section{Defining Classes and Methods}
\label{sec:qt-defin-class-meth}


As \Qt{} is  implemented in an object-oriented language, C++, the
designers of the API expect the developer to extend \Qt{} classes,
like \class{QWidget}, during the normal course of GUI
development. This is a significant difference from \GTK, where it is
only necessary to extend classes when one needs to fundamentally alter
the behavior of a widget. The \pkg{qtbase} package allows the \R{}
user to extend C++ classes in order to enhance the features of \Qt.

We will demonstrate this functionality by example.  In the
introductory example of Section~\ref{sec:qt-introductory-example} we saw this minimal use of
\function{qsetClass}. Our aim is to extend the \code{QValidator}
class to restrict the input in a text entry (\code{QTextEdit}) to a
valid date. The first step is to declare the class, and then methods
are added individually to the class definition, in an analogous manner
to the \pkg{methods} package. We start by declaring the class:
<<DateValidatorSnippet,results=hide>>=
qsetClass("DateValidator", Qt$QValidator)
@ 
% 
The class name is given as \code{DateValidator} and it extends the
\code{QValidator} class in \Qt. Note that only single inheritance is
supported.

As a side-effect of the call to \function{qsetClass}, a variable
named \code{DateValidator} has been assigned into the global
environment (the scoping is similar to \function{methods::setClass}):
<<list-validator-class>>=
DateValidator
@ 
% 

It is an error to redefine the class as above without first deleting the object.



To define a method on our class, we call the \function{qsetMethod}
function:
<<validate, echo=FALSE>>=
validateDate <- function(input, pos) {
  if(!grepl("^[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}$", input)) 
    return(Qt$QValidator$Intermediate)
  else  if(is.na(as.Date(input, format="%Y-%m-%d"))) 
    return(Qt$QValidator$Invalid)
  else 
    return(Qt$QValidator$Acceptable)
}
@ 
<<qsetMethod>>=
qsetMethod("validate", DateValidator, validateDate)
@ 
% 
The virtual method \code{validate} declared by \class{QValidator} has
been overriden by the \class{DateValidator} class.  The
\function{validateDate} function implements the override and has
been defined invisibly for brevity.

As \class{DateValidator} is an \class{RQtClass} object, we can create
an instance by invoking \function{DateValidator} like any other
\code{function}:
<<construct-validator>>=
validator <- DateValidator()
@ 
% 
Now that we have our validator, we can use it with a text entry:
<<text-entry>>=
e <- Qt$QLineEdit()
v <- DateValidator(e)
e$setValidator(v)
e$show()
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% JV alternate to the above.
As \Qt{} is  implemented in an object-oriented language, \proglang{C++}, the
designers of the API expect the developer to extend \Qt{} classes,
like \class{QWidget}, during the normal course of GUI
development. This is a significant difference from \GTK, where it is
only necessary to extend classes when one needs to fundamentally alter
the behavior of a widget. The \pkg{qtbase} package allows the \R{}
user to extend \proglang{C++} classes in order to enhance the features of \Qt.
The \pkg{qtbase} package includes functions \function{qsetClass} and
\function{qsetMethod} to create subclasses and methods of
subclasses. 

To create a subclass of some class, say \class{QWidget}, the basic use is simply
<<results=hide>>=
qsetClass("SubClass", Qt$QWidget)
@ 
%
This assigns to the variable \code{SubClass} an object inheriting from
\class{RQtClass}. (The \argument{where}{qsetClass} argument can be
used to specify where this variable is defined, in a manner similar to
S4's \function{setClass}.) Note the lack of parentheses for the parent
object (\code{Qt\$QWidget}), as the parent also inherits from
\class{RQtClass}. These objects are constructors (functions) that have
augmented environments containing the available methods and
properties.

By default, the parent's constructor is inherited by the subclass. To
create a new constructor, say to initialize values, or to make a
compound widget, the \argument{constructor}{qsetClass} argument is
used. This takes a function that will be called by positional
arguments, so default values are used, but not by name. The function
should allow a \code{parent} argument, to pass along a parent
widget. A typical minimal usage might be
<<results=hide>>=
qsetClass("SubClass2", Qt$QWidget, function(parent=NULL) {
  super(parent)
  ## ... more here
})
@ 
%
Within the body of a constructor, the \function{super} variable refers
to the parent's constructor, and in the above is used to set the
parent object. Within the body of a constructor the variable
\code{this} refers to the environment of the instance of the subclass
being constructed. To set a property, we can assign to a
component. This environment augments the constructor's environment, so
one can refer to the methods without a prefix. For example, a simple
constructor to pass in a window title and some special property might
look like
<<results=hide>>=
qsetClass("SubClass3", Qt$QWidget, function(title, prop, parent=NULL) {
  super(parent)
  this$property <- prop
  setWindowTitle(title)
})
@ 
%

One may define new methods, or override methods from a base class
through the \function{qsetMethod} function. The arguments are the
method name, the class the method is defined in, the method's
definition, and an optional value for \argument{access}{qsetMethod}
indicating if the method should be \qcode{public}, \qcode{protected},
or \qcode{private}.

Within the body of the method definition the variable \code{super} is
a function, somewhat like \function{do.call}, that can be used to call
a method from the parent class by name (the first argument) passing in
all subsequent arguments. The functionality is similar to that
provided by S4's \function{callNextMethod}. The variable \code{this}
refers again to the instance's environment. Again for convenience this
is placed into the search path of the function call.

For example, methods to create accessors for a property may be
defined as
<<results=hide>>=
qsetClass("SubClass4", Qt$QWidget)
qsetMethod("property", SubClass4, function() property)
qsetMethod("setProperty", SubClass4, function(value) {
  this$property <- value
})
@ 
%

To override a base method by adding to its call can be done with the
\function{super} function. For example, to store the window title in our
property one might do this:
<<results=hide>>=
qsetMethod("setWindowTitle", SubClass4, function(value) {
  setProperty(value)
  super("setWindowTitle", value)
})
@ 



%% FIXME: This seems strange. There's an ErrorLabel that extends a
%% line edit, but it is really neither a label nor a line edit. 
%% Would be cool to do something like place an icon within the line
%% edit that has a tooltip with the error message.

%% JV: Agreed. this section needs to  be reworked. It is hard to find
%% the key information: qsetClass and a conversation about
%% constructors and scope (super, this), and qsetMethod and a
%% conversation about inheritance and scope (super, this). As well, I
%% find the example a bit awkward too. The bit about
%% minimumheight (too kludgy), the call of widget as it isn't a line
%% edit, ... How do you add an icon in a line edit widget?

\begin{example}{A ``error label''}{eg:qt-error}
  A common practice when validation is used for text entry is to have
  a ``buddy label.'' That is an accompanying label to set an error
  message. As \Qt{} uses ``buddy'' for something else, we call this an
  ``error label'' below. We show how to implement such a widget in
  \pkg{qtbase} where we define a new type of widget that combines a
  \class{QTextEdit} and the \class{QLabel} for reporting errors. 
  
  This demonstrates the definition of a custom constructor for an \R{}
  class.  The \R\/ function implementing the constructor must be passed
  during the call to \Rfunction{qsetClass}:
<<ErrorLabel, results=hide>>=
qsetClass("ErrorLabel", Qt$QLineEdit, 
          function(text, parent=NULL, message="") {
            super(parent)
            
            this$widget <- Qt$QWidget()           # for attaching
            this$error <- Qt$QLabel()             # set height=0
            this$error$setStyleSheet("* {color: red}")  # set color
                        
            lyt <- Qt$QGridLayout()               # layout
            widget$setLayout(lyt)

            lyt$setVerticalSpacing(0)
            lyt$addWidget(this, 0, 0, 1, 1)
            lyt$addWidget(error, 1, 0, 1, 1)
            
            if(nchar(message) > 0)
              setMessage(message)
            else
              setErrorHeight(FALSE)
            if(!missing(text)) setText(text)
          })
@

By convention, every widget in \Qt\/ accepts its parent as an argument
to its constructor. Via \Rfunction{super}, the parent is passed to the
base class constructor and on up the hierarchy. The \Rfunction{super}
function does not exist outside the scope of a constructor (or
method). Within a constructor, \Rfunction{super} invokes the
constructor of the parent (super) class, with the given
arguments. Within a method implementation, \Rcode{super} will call a
method (named in the first parameter) in the parent class (see
Example~\ref{eg:qt-dnd}).

In addition to the call to \function{super}, we define a
\class{QWidget} instance to contain the line edit widget and its
label. These are placed within a grid layout. The use of \code{this}
refers to the object we are creating. The new method
\meth{setErrorHeight} is used to flatten the height of the label when
it is not needed and is defined below.  The final line sets the
initial text in the line edit widget. The \R{} environment where
\method{setText}{QLineEdit} is defined is extended by the environment
of this constructor, so no prefix is needed in the call.

  The \code{widget} component is needed to actually show the widget. We
  create an accessor method:
<<ErrorLabel-Example, results=hide>>=
qsetMethod("widget", ErrorLabel, function() widget)
@ 


  We extend the API of the line edit widget for this subclass to modify
  the message. We define three methods, one to get the message, one to
  set it and a convenience function to clear the message.
<<results=hide>>=
qsetMethod("message", ErrorLabel, function() error$text)
qsetMethod("setMessage", ErrorLabel, function(msg="") {
  if(nchar(msg) > 0)
    error$setText(msg)
  setErrorHeight(nchar(msg) > 0)
})
qsetMethod("clear", ErrorLabel, function()  setMessage())
@ 

Finally, we define the method to set the height of the label, so that
when there is no message it has no height. We use a
combination of setting both the minimum and maximum height.
<<results=hide>>=
qsetMethod("setErrorHeight", ErrorLabel, function(do.height=FALSE)  {
  if(do.height) {
    m <- 18; M <- 100
  } else {
    m <- 0; M <- 0
  }
  error$setMinimumHeight(m)
  error$setMaximumHeight(m)
})
@ 

To use this widget, we have the extra call to \code{widget()} to
retrieve the widget to add to a GUI. In the following, we just show
the widget.
<<results=hide>>=
e <- ErrorLabel()
w <- e$widget()                # get widget to show
w$show()                       # to view widget
e$setMessage("A label")        # opens message
e$clear()                      # clear message, shrink space
@ 
\end{example}


%% ML: In my opinion, this material is best embedded within the
%% discussion of the available widgets, especially the top-level
%% window and layouts.

\section{Common methods for QWidgets and QObjects}
\label{sec:comm-meth-qwidg}

The widgets we discuss in the sequel inherit many properties and
methods from the base \class{QObject} and \class{QWidget} classes. The
\class{QObject} class is the base class and forms the basis for the
object heirarchy and the event processing system. The \class{QWidget}
class is the base class for objects with a user interface. Defined in
this class are several methods inherited by the widgets we discuss.

The function \function{qmethods} will show the methods defined for a
class. It returns a data frame with variables indicating the name,
return value, signature, and whether the method is protected and
static. For example, for a simple button we have many methods, of
which we can only discuss a handful.
<<>>=
out <- qmethods(Qt$QPushButton)
dim(out)                                # many methods
@ 



\paragraph{Showing or hiding a widget}

Widgets must have their \method{show}{QWidget} method called in order
to have them drawn to the screen. This call happens through the
\meth{print} method for an object inheriting from \class{QWidget}, but
more typically is called recursively by \Qt{} when showing the children
as a top-level window is drawn. The method \method{raise}{QWidget}
will raise the window to the top of the stack of windows, in case it
is covered.  The method \method{hide}{QWidget} will hide the widget.

%% JV: How to delete a widget: get(sprintf("~%s", class(w)[1]), w)()
%% is awkward and doesn't always work.

% XXX JV: this didn't work?
% It is not deleted
% unless it has the ``DeleteOnClose'' attribute set.

% <<>>=
% w <- Qt$QWidget()
% w$windowTitle <- "Title"
% w$show()                                # or simply print(w)
% w$close()                               # hides
% w$setAttribute(Qt$Qt$WA_DeleteOnClose, TRUE)
% w$close()                               # should delete
% w$show()                                # error!
% @ 


A widget can also be hidden by calling its
\method{setVisible}{QWidget} method with a value of \code{FALSE} and
reshown using a value of \code{TRUE}. Similary, the method
\code{setEnabled} can be used to toggle whether a widget is sensitive
to user input, including mouse events.

% When more than one window is drawn, one can adjust whether a window is
% on top. The \method{raise}{QWidget} method will raise a window to the
% top of the stack and \method{lower}{QWidget} lower it.
<<echo=FALSE, eval=FALSE>>=
## doesn't work with Ubuntu
w1 <- Qt$QPushButton("one"); w1
w2 <- Qt$QPushButton("two"); w2
## try to raise w1
w1$activateWindow()
w1$raise() ## doesn't
@ 

Only one widget can have the keyboard focus. This is changed by the
user through tab-navigation or mouse clicks (unless customized, see
\method{focusPolicy}{QWidget}), but can be set programatically through
the \method{setFocus}{QWidget} method, and tested through the
\method{hasFocus}{QWidget} method.

\Qt{} has a number of means to notify the user about a widget when the
mouse hovers over it. The \method{setTooltip}{QWidget} method is used
to specify a tooltip as a string. The message can be made to appear in
the status bar of a top-level window through the method
\method{setStatusTip}{QWidget}. 
% \Qt{} provides a ``What's This?''
% option to provide a bit more information than is customary in a
% tooltip. This is set through \method{setWhatsThis}{QWidget} and
% activated by \kbd{SHIFT+F1} when the widget has focus.

\paragraph{The size of a widget}
A widget may be drawn with its own window, or typically embedded in a more
complicated GUI. The size of the widget can be adjusted through
various methods. 

First, we can get the size of the widget through the
methods \method{frameGeometry}{QWidget} and
\method{frameSize}{QWidget}. The \code{frameGeometry} method returns a \class{QRect}
instance, \Qt's rectangle class for integer sizes. Rectangles are parameterized by an $x-y$
position and two dimensions (\method{x}{QRect}, \method{y}{QRect},
\method{width}{QRect} and \method{height}{QRect}). In this case, the
position refers to the upper left coordinate and dimensions are in pixels. The 
convenience function \function{qrect} is provided to construct
\class{QRect} instances. The
\method{frameSize}{QWidget} method returns a \class{QSize} object with properties
\property{width}{QSize} and \property{height}{QSize}.  The
\function{qsize} function is a convenience constructor for objects of
this class.

The widget's size can be adjusted several ways: with the
\method{resize}{QWidget} method,  by
modifying the rectangle and then resetting the geometry with
\method{setGeometry}{QWidget}, or directly through the same method
when integer values are given for the arguments.

<<ChangeGeometry, results=hide>>=
w <- Qt$QWidget()
rect <- w$frameGeometry
rect$width()
rect$setWidth(2 * rect$width())
w$setGeometry(rect)
@ 

Although the above sets the size, it does not fix it. If that is
desired, the methods \method{setFixedSize}{QWidget} or
\method{setFixedWidth}{QWidget} are available.

%%JV: This seems out of place and not well done. Do you think it
%% should be in the layout section anyways?

When a widget is resized, one can constrain how it changes by
specifying a minimum size or maximum size. These values work in
combination with the size policy of the widget. The properties
\property{minimumSize}{QWidget}, \property{minimumWidth}{QWidget},
\property{minimumHeight}{QWidget}, \property{maximumSize}{QWidget}
\property{maximumWidth}{QWidget} and
\property{maximumHeight}{QWidget}, and their corresponding setters,
are the germane ones.  How these get used is determined by the
\property{sizePolicy} property. For example, buttons will only grow in
the $x$ direction -- not the $y$ direction due to their default size
policy.

The method \method{update}{QWidget} is used to request a repainting of a widget
and the method \method{updateGeometry}{QWidget} is used to notify any
layout manager that the the size hint has changed.

%% JV: Is setUpdatesEnabled reasonable here. 




%% ML: seems like fonts and styles can be introduced on-the-fly - not a
%% core concept.

%% JV: You are right, especially for styles, but fonts alteast seem to
%% be a common question for beginners. This gives them some little bit
%% in the table of contents to search for. As you can see though, I
%% didn't put much into this

\subsection{Fonts}
\label{sec:fonts}

Fonts in \Qt{} are handled through the \class{QFont} class. In
addition to the basic constructor, one constructor allows the
programmer to specify a \code{family}, such as \code{helvetica};
\code{pointsize}, an integer; \code{weight}, an enumerated value such
as \code{Qt\$QFont\$Light} (or \code{Normal}, \code{DemiBold},
\code{Bold}, or \code{Black}); and whether the italic version should
be used, as a logical.

For example, a typical font specification may be given as follows:
<<>>=
f <- Qt$QFont(family="helvetica", ps=12, 
              weight=Qt$QFont$Bold, 
              italics=TRUE)
@ 

For widgets, the \method{setFont}{QWidget} method can be used to
adjust the font. For example, to change the font for a label we have
<<results=hide>>=
l <- Qt$QLabel("Text for the label")
l$setFont(f)
@ 

The \class{QFont} class has several methods to query the font and to
adjust properties. For example, there are the methods
\method{setFamily}{QFont}, \method{setUnderline}{QFont},
\method{setStrikeout}{QFont} and \method{setBold}{QFont} among others.


%% Palettes (colors); roles

\subsection{Styles}
\label{sec:styles}

\Qt{} uses styles to provide a means to customize the look and feel of
an application for the underlying operating system. It is generally
recommended that a GUI be consistent with the given style. For
example, each style implements a palette of colors to indicate the
states ``active'' (has focus), ``inactive'' (does not have focus), and
``disabled'' (not sensitive to user input). Although, many widgets do not have a
visible distinction between active or inactive.  The role an object
plays determines the type of coloring it should receive. A palette has
an enumeration in \qtenumeration{QPalette::ColorRole}. Sample ones are
\code{Qt\$QPalette\$Highlight}, to indicate a selected item, or
\code{Qt\$QPalette\$WindowText} to indicate a foreground color.

These roles are used for setting the foreground or background role to
give a widget a different look, as illustrated in Example~\ref{eg:qt-dnd}.


\subsubsection{Style Sheets}
\label{ssec:style-sheets}

Cascading style sheets (CSS) are used by web deisgners to decouple the
layout and look and feel of a web page from the content of the
page. \Qt{} implements the mechanism in the \class{QWidget} class to
customize a widget through the CSS syntax. The implemented syntax is
described in the overview on stylesheets provided with \Qt{}
documentation and is not summarized here, as it is quite readable.

To implement a change through a style sheet involves the
\method{setStyleSheet}{QWidget} method. For example, to change the
background and text color for a button we could have
<<results=hide>>=
b <- Qt$QPushButton("Style sheet example")
b$show()
b$setStyleSheet("QPushButton {color: red; background: white}")
@ 
One can also set a background image:
<<results=hide>>=
ssheet <- sprintf("* {background-image: url(%s)}", "logo.png")
b$setStyleSheet(ssheet)
@ 


%% ML: This is an advanced topic that probably belongs somewhere else,
%% like at the end of the basic components section.

%% JV: No argument there. I was following what I did in the tcltk
%% chapter where I wanted an example of various events and their
%% handlers and used drag and drop.

\section{Drag and drop}
\label{sec:drag-drop}


\Qt{} has native support for basic drag and drop activities for some
of its widgets, such as text editing widgets, but for more complicated
situations such support must be programmed in. The toolkit provides a
clear interface to allow this.

A drag and drop event consists of several stages: the user selects the
object that initiates the drag event, the user then drags the object
to a target, and finally a drop event occurs. In addition, several
decisions must be made, e.g., will the object ``move'' or simply be
copied. Or,  what kind of object will be transferred (an image? text?, ...)
etc. The type is specified using a standard MIME specification.

\paragraph{Initiating a drag and drop source} When a drag and drop sequence
is initiated, the widget receiving the mouse press event needs to set
up a \class{QDrag} instance that will transfer the necessary
information to the receiving widget. In addition, the programmer
specifies the type of data to be passed, as an instance of the
\class{QMimeData} class. Finally, the user must call the
\method{exec}{QDrag} method with instructions indicating what happens
on the drop event (the supported actions) and possibly what happens if
no modifier keys are specified. These are given using the enumerations
\qtenumeration{CopyAction}, \qtenumeration{MoveAction}, or \qtenumeration{LinkAction}.

This is usually specified in a method for the
\method{mousePressEvent}{QWidget} event, so is done in a subclass of
the widget you wish to use.

\paragraph{Creating a drop target}
The application must also set up drop sources. Each source has its
method \method{setAcceptDrops}{QWidget} called with a \code{TRUE}
value. In addition, one must implement several methods so again, a
subclass of the desired widget is needed. Typically one implements at
a minimum a \method{dropEvent}{QWidget} method. This method has an
\class{QDropEvent} instance passed in which has the method
\method{mimeData}{QDropEvent} to get the data from the \class{QDrag}
instance. This data has several methods for querying the type of data,
as illustrated in the example. If everything is fine, one calls the
even'ts \method{acceptProposedAction}{QDropEvent} method to set the
drop action. One can also specify other drop actions.
\\

Additionally, one can implement methods for
\method{dragMoveEvent}{QWidget} and
\method{dragLeaveEvent}{QWidget}. In the example, the move and leave
event adjust proporties of the widget to indicate it is a drop target.



\begin{example}{Drag and drop}{eg:qt-dnd}
  \SweaveInput{ex-qt-drag-and-drop}
\end{example}
