
\section{The Qt library}
\label{sec:qt-overview}

\Qt{} is an open-sourced, cross-platform application framework that is
perhaps best known for its widget toolkit. The features of \Qt{} are
divided into about a dozen modules. We highlight some of the more
important and interesting ones:
\\

\begin{description}
\item[Core] Basic utilities, collections, threads, I/O, ...
\item[Gui] Widgets, models, etc for graphical user interfaces
\item[OpenGL] Convenience layer (e.g., 2D drawing API) over OpenGL
\item[Webkit] Embeddable HTML renderer (shared with Safari, Chrome)
\end{description}

Other modules include functionality for networking, XML, SQL
databases, SVG, and multimedia. However, \R{} packages already
provide many of those features.

The history of \Qt{} begins with Haavard Nord and Eirik Chambe-Eng in
1991 and follows with the Trolltech company, until 2008. It is now
owned by Nokia, a major cell-phone producer. While it was originally
unavailable as open-source on every platform, version 4 was released
universally under the GPL. With the release of Qt 4.5, Nokia
additionally placed \Qt{} under the LGPL, so it is available for use
in proprietary software, as well. Popular software developed with
\Qt{} include the communication application Skype and the KDE desktop
for Linux. The desktop version of RStudio uses the \class{QWebView}
widget to present a cross-platform web application on the
desktop. This book assumes version Qt 4.7.3 and should remain
compatible for the remainder of the 4.x series.

\Qt{} is developed in C++ with extensions that require a special
preprocessor called the \dfn{Meta Object Compiler}
(\acronym{MOC}). The \acronym{MOC} allows for convenient syntax in the
definition of signals, slots (signal handlers), and properties, which
behave very similarly to those of \GTK.

There are many languages with bindings to \Qt{}, and \R{} is one such
language. The \pkg{qtbase} package interfaces with every module of the
library. As its name suggests, \pkg{qtbase} forms the base for a
number of \R{} packages that provide high-level special-purpose
interfaces to \Qt{}. The \pkg{qtpaint} package extends the
\class{QGraphicsView} canvas to better support interactive statistical
graphics. Features include: a layered buffering strategy, efficient
spatial queries for mapping user actions to the data, and an OpenGL
renderer optimized for statistical plots. An interface resembling that
of the \pkg{lattice} package is provided for \pkg{qtpaint} by the
\pkg{mosaiq} package. The \pkg{cranvas} package builds on
\pkg{qtpaint} to provide a collection of high-level interactive plots
in the conceptual vein of GGobi. A number of general utilities are
implemented by \pkg{qtutils}, including an object browser widget, an
\R{} console widget, and a conventional \R{} graphics device based on
\class{QGraphicsView}.

While \pkg{qtbase} is not yet as mature as \pkg{tcltk} and
\pkg{RGtk2}, we include it in this book, as \Qt{} compares favorably
to \GTK{} in terms of GUI features and excels in several other areas,
including its fast graphics canvas and integration of the WebKit web
browser.\footnote{There is a \GTK{} WebKit port, but it is not
  included with \GTK{} itself.} In addition, \Qt{}, as a commercially
supported package, has thorough documentation of its API\footcite{Qt-Docs}, including
many C++ examples. However, the complexity of C++ and Qt may present
some challenges to the \R{} user. In particular, the developer should
have a strong grounding in object-oriented programming and have a
basic understanding of memory management.

%% ML: need to get this on CRAN before the book is published
The development of \pkg{qtbase} package is hosted on Github
(\url{http://github.com/ggobi/qtbase}).  It depends on the \Qt{}
framework, available as a binary install from
\url{http://qt.nokia.com/}.

\section{An introductory example}
\label{sec:qt-introductory-example}
\SweaveInput{ex-qtbase}

\section{Classes and objects}
\label{sec:qt-classes-objects}

The \pkg{qtbase} package exports very few objects. The central one is
an environment, \code{Qt}, that represents the \Qt{} library in
%% FIXME: RQtLibrary will become RSmokeLibrary, same with RQtObject, etc
\R.\footnote{ The \code{Qt} object is an instance of
  \class{RQtLibrary}. The \pkg{qtbase} package provides infrastructure
  for binding any conventional C++ library, even those independent of
  \Qt. Third party packages can define their own \class{RQtLibrary}
  object for some other library.  }  The components of this
environment are \class{RQtClass} objects that represent an actual C++
class or namespace.  For example, the \code{QWidget} class is
represented by \code{Qt\$QWidget}:
<<qtwidget-class>>=
Qt$QWidget
@ 

An \class{RQtClass} object contains methods in the class
\iprogram{variable scope}scope (\textit{static} methods in C++), enumerations defined by the
class, and additional \class{RQtClass} objects representing nested
classes or namespaces. Here we list some of the components of
\class{QWidget}:
<<eval=FALSE>>=
head(names(Qt$QWidget), n = 3)
@ 
\begin{Soutput}
[1] "connect"    "DrawChildren"     "DrawWindowBackground"  
\end{Soutput}
%
then access one of the enumeration values:
<<>>=
Qt$QWidget$DrawChildren
@
%
Most importantly, however, an instance of \class{RQtClass} is in fact
an \R{} \class{function} object, and serves as the constructor of
instances of the class. For example, we could construct an instance of
\code{QWidget} with:
<<qwidget-object>>=
w <- Qt$QWidget()
@ 

The \code{w} object has a class structure that reflects the
\iprogram{class structure}class inheritance structure of \Qt:
<<qwidget-class, results=hide>>=
class(w)
@ 
\begin{Soutput}
[1] "QWidget"             "QObject"       "QPaintDevice"       
[4] "UserDefinedDatabase" "environment"   "RQtObject"         
\end{Soutput}
%
The base class, \class{RQtObject}, is an \iprogram{reflection}environment containing
the properties and methods of the instance. For \code{w}, we list
the first few using \function{ls}:
<<results=hide>>=
head(ls(w), n=3)
@ 
\begin{Soutput}
[1] "mapFromParent"  "setContextMenuPolicy"  "showMinimized"  
\end{Soutput}

Properties and methods are accessed from the environment in the usual
manner. The most convenient extractor is the \code{\$}
operator, but \code{[[} 
% ]]
and \function{get} will also work. (With the
\code{\$} operator R's completion mechanism works (\code{?rcompgen}).) For
example, a \class{QWidget} has a \property{windowTitle}{QWidget} property which is
used when the widget draws itself with a window:
<<windowTitle>>=
w$windowTitle                           # initially NULL
w$windowTitle <- "a new title"          # set property
w$windowTitle
@ 

Although \Qt{} defines methods for accessing properties, the \R{} user
will normally invoke methods that perform some action. For example, we
could show our widget:
<<results=hide>>=
w$show()
@
%

The environment structure of the object masks the fact that the
properties and methods may be defined in a parent class of the
object. For example, a button widget is provided by the
\class{QPushButton} constructor, as in
<<pushButton>>=
b <- Qt$QPushButton()
@ 
%
\class{QPushButton} extends \class{QWidget} and thus inherits the
properties like \prop{windowTitle}:
<<pushbutton-class>>=
is(b, "QWidget")
b$windowTitle
@ 
%
It is important to realize this distinction when referencing the
documentation. As with \GTK, the methods are documented with the class
that declares the method.

%% JV: Is there some well-written means to look up where a method is
%% defined? I have this hack, but there should be a better way (I'm
%% thinking it would be useful to find the proper help page for a method,...)
% findMeth <- function(obj, meth_name) {
%   cls <- class(obj)
%   ind <- sapply(cls, function(i) exists(i, envir=Qt))
%   l <- lapply(cls[ind], function(i) ls(get(i, envir=Qt)()))
%   names(l) <- cls[ind]
%   for(i in 1:(length(l)-1))
%     l[[i]] <- setdiff(l[[i]], l[[i+1]])

%   if(!missing(meth_name)) {
%     for(i in 1:length(l)) {
%       if(meth_name %in% l[[i]])
%         print(names(l)[i])
%     }
%   }
%   invisible(l)
% }


\section{Methods and dispatch}

In C++, it is possible to have multiple methods and constructors with
the same name, but different signatures. This is called
\iprogram{overloading}\dfn{overloading}. An overloaded method is roughly similar to an S4
generic, save the obvious difference that an S4 generic does not
belong to any class. The selected overload is that with the signature
that best matches the types of the arguments. The exact rules of
overload resolution are beyond our scope.

It is particularly common to overload constructors. For example, a
simple push button can be constructed in several different ways. Here
again is the invocation of the \class{QPushButton} constructor with no
arguments:
<<>>=
b <- Qt$QPushButton()
@ 
%
By convention, all classes derived from \class{QObject}, including
\class{QWidget}, provide a constructor that accepts a parent
\class{QObject}. This has important consequences that are discussed
later. We demonstrate this for \class{QPushButton}:
<<constructor-parent>>=
w <- Qt$QWidget()
b <- Qt$QPushButton(w)
@ 
%
An alternative constructor for \class{QPushButton} accepts the text
for the label on the button:
<<constructor-text>>=
b <- Qt$QPushButton("Button text")
@
%
Buttons may also have icons, for example
<<constructor-icon-parent>>=
style <- Qt$QApplication$style()
icon <- style$standardIcon(Qt$QStyle$SP_DialogOkButton)
b <- Qt$QPushButton(icon, "Ok")
@ 
%
We have passed three different types of object as the first argument
to \function{Qt\$QPushButton}: a \class{QWidget}, a string, and
finally a \class{QIcon}. The dispatch depends only on the type of
argument, unlike the constructors in \pkg{RGtk2} which dispatches based
on which arguments are specified. (In particular, dispatch in \Qt{} is based on
position of argument, but not on names given to arguments. We use
names only for clarity in our examples.)

The function \index{general}{qmethods}\function{qmethods} will show the methods defined for a
class. It returns a data frame with variables indicating the name,
return value, signature, and whether the method is protected and
static. For example, to learn the methods for a simple button, we
would call:
<<>>=
out <- qmethods(Qt$QPushButton)
dim(out)
head(out[,1:3], n=3)
@ 

\iprogram{widget properties}
\section{Properties}
\label{sec:properties}

%% JV How does a subclass define properties so that qproperties lists
%% them. (A qsetProperty function?)
%% ML: Yes, this is now introduced below.

Every \class{QObject}, which includes every widget, may declare a set
of properties that represent its state. We list some of the available
properties for our button:\index{general}{qproperties}
<<list-properties>>=
head(qproperties(b))
@
%
As shown in the table, every property has a type and logical settings
for whether the property is readable and/or writeable. Virtually every
property value may be read, and it is common for properties to be
read-only. For example, we can fully manipulate the \code{objectName}
property, but our attempt to modify the \code{modal} property fails: 
<<modal-property>>=
b$objectName <- "My button"
b$objectName
b$modal
try(b$modal <- TRUE)                    # fails
@ 

\Qt{} provides accessor methods for getting and setting
properties. The getter methods have the same name as the property, so
they are masked at the \R{} level. Setter methods are available and
are typically named with the word "set" followed by the property name:
<<windowTitleMethod, results=hide>>=
b$setObjectName("My button")
@ 
% 
However, it is recommended to use the replacement syntax shown in the
previous example, for the sake of symmetry.

\section{Signals}
\label{sec:qt-signals}

\iprogram{signals}\iprogram{event handlers}
\Qt{} in C++ uses an architecture of signals and slots to have
components communicate with each other. A component emits a signal
when some event happens, such as a user clicking on a button. \Qt{}
allows one to define a special type of method known as a slot in
another component (or the same) that can be connected to the signal as
the handler. The two components are decoupled as the emitter does not
need to know about the receiver except through the signal
connection. In \R{}, any function can be treated as a slot and
connected as a signal handler. This is similar to the signal handling
in \pkg{RGtk2}. The function \index{general}{qconnect}\function{qconnect} establishes the
connection of an R function to a signal. For example
<<results=hide>>=
b <- Qt$QPushButton("click me")
qconnect(b, "clicked", function() print("ouch"))
b$show()
@ 

Signals are defined by a class and are inherited by
subclasses.  Here, we list some of the available signals for the
\class{QPushButton} class:
<<qt-signals-list>>=
tail(qsignals(Qt$QPushButton), n=5)
@ 
%
The signal definition specifies the callback signature, given in the
\code{signature} column. Like other methods, signals can be overloaded
so that there are multiple signatures for a given signal name. Signals
can also have default arguments, and arguments with a default value
are optional in the signal handler. We see this for the \code{clicked}
signal, where the \code{bool} (logical) argument, indicating whether
the button is checked, has a default value of \code{FALSE}. The
\code{clicked} signal is automatically overloaded with a signature
without any arguments.

The \function{qconnect} function attempts to pick the correct
signature by considering the number of formal arguments in the
callback. Rarely, two signatures will have the same number of
arguments, in which case one will be chosen arbitrarily. To connect to
a specific signature, the full signature, rather than only the name,
should be passed to \function{qconnect}. For example, there are two signatures
for the \code{clicked} signal: \code{clicked()} and
\code{clicked(bool)}. Even if we only specify \code{clicked} as the signal
name, the \code{clicked(bool)} signature is chosen, since our handler
has a single argument. Thus, these two calls are equivalent:
<<qt-signals-qconnect-sig, results=hide>>=
qconnect(b, "clicked", function(checked) print(checked))
qconnect(b, "clicked(bool)", function(checked) print(checked))
@ 

Any object passed to the optional argument
\argument{user.data}{qconnect} is passed as the last argument to the
signal handler. The user data serves to parameterize the callback. In
particular, it can be used to pass in a reference to the sender object
itself, although we encourage the use of closures for this purpose.

\paragraph{Disconnecting or blocking signals}
The \code{qconnect} function returns a dummy \class{QObject} instance
that provides the slot that wraps the \R{} function. This dummy object
can be used with the \method{disconnect}{QObject} method on the
sender to break the signal connection:
<<qt-signals-disconnect>>=
proxy <- qconnect(b, "clicked", function() print("ouch"))
b$disconnect(proxy)
@ 
%
The above will permanently disconnect the signal handler. To
temporarily block all of the signals emitted by a particular
\class{QObject}, call the \method{blockSignals}{QObject} method. The
method takes a logical value indicating whether the signals should be
blocked.

\paragraph{Hardware events}\iprogram{hardware events}
Unlike \GTK, \Qt{} widgets generally do not emit hardware events, such
as a mouse press, via signals. Instead, a method in the widget is
invoked upon receipt of an event. The developer is expected to extend
the widget's class and override the method to catch the event. The apparent
philosophy of \Qt{} is that hardware events are low-level and thus
should be handled by the widget, not some other instance. We will
discuss extending classes in Section~\ref{sec:qt-defin-class-meth}.


\section{Enumerations and flags}
\label{sec:qt-enums}

\iprogram{enumeration}
Often, it is useful to have discrete variables with more than two
states, in which case a logical value is no longer sufficient.  For
example, the label widget has a property for how its text is
aligned. It supports the alignment styles left, right, center, top,
bottom, etc. These styles are \iprogram{enumeration}enumerated by
integer values and \Qt{} defines these by name within the relevant
class or, for global enumerations, in the \code{Qt} namespace. Here
are examples of both:
<<Enumeration-example>>=
Qt$Qt$AlignRight
Qt$QSizePolicy$Expanding
@
% 
The first is the value for right alignment from the
\qtenumeration{Alignment} enumeration in the \code{Qt} namespace,
while the second is from the \qtenumeration{Policy} enumeration in the
\class{QSizePolicy} class.

Although these enumerations can be specified directly as integers, they are
given the class \class{QtEnum} and have the overloaded operators
\OR{} and \AND{} to combine values bitwise. This makes the most
sense when the values correspond to bit flags, as is the case for the
alignment style. For example, aligning the text in a label in the upper
right can be done through
<<alignexample, results=hide>>=
l <- Qt$QLabel("Our text")
l$alignment <- Qt$Qt$AlignRight | Qt$Qt$AlignTop
@ 
%
To check if the alignment is to the right, we could query by:
<<>>=
as.logical(l$alignment & Qt$Qt$AlignRight)
@ 
\iprogram{subclass}
\section{Extending Qt classes from R}
\label{sec:qt-defin-class-meth}

As \Qt{} is implemented in an object-oriented language, C++, the
designers of the API expect the developer to extend \Qt{} classes,
like \class{QWidget}, during the normal course of GUI
development. This is a significant difference from \GTK, where it is
only necessary to extend classes when one needs to fundamentally alter
the behavior of a widget (cf. Chapter~\ref{chapter:extending-GTK}). The \pkg{qtbase} package allows the \R{}
user to extend C++ classes in order to enhance the features of \Qt.
The \pkg{qtbase} package includes functions \function{qsetClass} and
\function{qsetMethod} to create subclasses and their methods. Methods
may override virtual methods in an ancestor C++ class, and C++ code
will invoke the \R\/ implementation when calling the overridden
virtual. Properties may be defined with a getter and setter
function. If a type is specified, and the class derives from
\class{QObject}, the property will be exposed by \Qt. It is also
possible to store arbitrary objects in an instance of an \R\/ class; we
will refer to these as dynamic fields. They are private to the class
but are otherwise similar to attributes on any R object. Their type is
not checked, and they are useful as a storage mechanism for
implementing properties.

\subsection{Defining a class}
\label{sec:qt-defin-class}

Here, we show a generic example, and follow with a specific one.
<<results=hide>>=
qsetClass("SubClass", Qt$QWidget)
@ 
% 
This creates a variable named \code{SubClass} in the workspace:
<<qt-classes-show-class>>=
SubClass
@ 
% 
Its value is an \class{RQtClass} object that behaves like the
\class{RQtClass} for the built-in classes, such as
\code{Qt\$QWidget}. There are no static methods or enumerations in an
\R\/ class, so the class object is essentially the constructor:
<<qt-classes-constructor>>=
instance <- SubClass()
@ 

By default, the constructor delegates directly to the constructor in
the parent class. A custom constructor is often useful, for example,
to initialize fields or to make a compound widget.  The function
implementing the constructor should be passed as the
\argument{constructor}{qsetClass} argument. By convention, \class{QObject}
subclasses should provide a \code{parent} constructor argument, for
specifying the parent object. A typical usage would be
<<results=hide>>=
qsetClass("SubClass2", Qt$QWidget, 
          function(title, prop, parent=NULL) {
            super(parent)
            this$property <- prop
            setWindowTitle(title)
          })
@ 
% 
Within the body of a constructor, the \index{general}{super}\function{super} variable refers
to the constructor of the parent class, often called the ``super''
class. In the above, we call \code{super} to delegate the registration
of the parent to the \class{QWidget} constructor. Another special
symbol in the body of a constructor is \code{this}, which refers to
the instance being constructed. We can set and implicitly create
fields in the instance by using the same syntax as setting
properties.

\subsection{Defining methods}
\label{sec:qt-defin-methods}


One may define new methods, or override methods from a base class
through the \index{general}{qsetmethod}\function{qsetMethod} function.  For example, accessors
for a field may be defined with
<<results=hide>>=
qsetMethod("field", SubClass, function() field)
qsetMethod("setField", SubClass, function(value) {
  this$field <- value
})
@ 
% 
For an override of an existing method to be visible from C++, the
method must be declared virtual in C++. The
\argument{access}{qsetMethod} argument specifies the scope of the
method: \qcode{public} (default), \qcode{protected}, or \qcode{private}. These
have the same meaning as in C++.

As with a constructor, the symbol \code{this} in a method definition
refers to the instance.  There is also a \index{general}{super}\function{super} function
that behaves similarly to the \function{super} found in a
constructor: it searches for an inherited method of a given name and
invokes it with the passed arguments:
<<results=hide>>=
qsetMethod("setVisible", SubClass, function(value) {
  message("Visible: ", value)
  super("setVisible", value)
})
@ 
% 
In the above, we intercept the setting of the visibility of our
widget. If we hide or show the widget, we will receive a notification
to the console:
<<subclass-show, results=hide>>=
instance$show()
@ 
% 
This is somewhat similar to the behavior of
\function{callNextMethod}, except \function{super} is not restricted
to calling the same method.

\subsection{Defining signals and slots}
\label{sec:qt-defin-sig-slots}

Two special types of methods are slots and signals, introduced earlier
in the chapter. These exist only for \class{QObject} derivatives. Most
useful are signals. Here we define a signal:
<<qt-overview-qsetSignal, results=hide>>=
qsetSignal("somethingHappened", SubClass)
@ 
%
If the signal takes an argument, we need to indicate that in the
signature:
<<qt-overview-qsetSignal-sig, results=hide>>=
qsetSignal("somethingHappenedAtIndex(int)", SubClass)
@ 
%
Writing a signature requires some familiarity with C/C++ types and
syntax, but this is concise and consistent with how \Qt\/ describes
its methods. Although almost always public, it is possible to make a
signal protected or private, via the \argument{access}{qsetSignal}
argument.

Defining a slot is very similar to defining a signal, except a method
implementation must be provided as an R function:
<<qt-overview-qsetSlot, results=hide>>=
qsetSlot("doSomethingToIndex(int)", SubClass, function(index) {
  # ....
})
@ 
%
%% JV: do we want to write about QtDesigner???
The advantage of a slot compared to a method is that a slot is exposed
to the \Qt{} metaobject system. This means that a slot could be called
from another dynamic environment, like from Javascript running in the
\class{QScript} module or via the D-Bus through the \class{QDBus}
module. It is also necessary to use slots as signal handlers for a GUI
built with \software{QtDesigner}, if one is using the automated
connection feature (see Section~\ref{sec:qt-designer}).

\subsection{Defining properties}
\label{sec:qt-overview-define-props}

A property, introduced earlier, is a self-describing field that is
encapsulated by a getter and a setter. We can define a property on any
class using the \index{general}{qsetProperty}\function{qsetProperty} function. Here is the simplest
usage:
<<qt-overview-define-propE>>=
qsetProperty("property", SubClass)
@ 
%
We can now access \property{property}{SubClass} like any other
property; for example:
<<qt-overview-define-prop-get>>=
instance <- SubClass()
instance$property                       # initially NULL
instance$property <- "value"
instance$property
@
%
%% JV did this change???
However, the property is not actually exposed by the \Qt\/ meta object
system to external systems, which would only understand \Qt\/
types. To export a property, one must provide the
\argument{type}{qsetProperty} argument, which we will cover later.

By default, the property value is actually stored as a (private) field
in the object, called \qcode{.property}. One can override the default
behavior by specifying to the \argument{read}{qsetProperty} or
\argument{write}{qsetProperty} arguments a function for the getter
and/or the setter:
<<qt-overview-define-prop-getter-setter, results=hide>>=
qsetProperty("checkedProperty", SubClass, write = function(x) {
  if (!is(x, "character"))
    stop("'checkedProperty' must be a character vector")
  this$.checkedProperty <- x
})
@ 
%
We have taken advantage of the setter override to check the validity
of the incoming value. If \qcode{NULL} is passed as the
\argument{write}{qsetProperty} argument, the property is
read-only. One might also want to override the
\argument{read}{qsetProperty} function, for cases where a property
depends only on other properties or on some external resource.

To automatically emit a signal whenever a property is set, one can
pass the name of the signal to the \argument{notify}{qsetProperty}
argument of \function{qsetProperty}:
<<qt-overview-define-prop-notify, results=hide>>=
qsetSignal("propertyChanged", SubClass)
qsetProperty("property", SubClass, notify = "propertyChanged")
@ 

If a class derives from \class{QObject}, as does any widget, we can
specify the C++ type of the property to expose it to the \Qt\/ meta
object system:
<<qt-overview-define-prop-typed, results=hide>>=
qsetProperty("typedProperty", SubClass, type = "QString")
@
<<qt-overview-define-prop-typed-list>>=
tail(qproperties(SubClass()), 1)
@ 
%
We see that the type is now exposed via the general
\function{qproperties} function. Specifying the type enables all of
the features of a \Qt\/ property.

%% JV 1/29: I think we need an example
\begin{example}{A watcher for workspace objects}{ex-qt-ws-objects}
  \SweaveInput{ex-qt-ws-model}
\end{example}


\section{\class{QWidget} basics}
\label{sec:comm-meth-qwidg}

The widgets we discuss in the next section inherit many properties and
methods from the base \class{QObject} and \class{QWidget} classes. The
\class{QObject} class is the base class and forms the basis for the
object hierarchy. It implements the event processing and property
systems. The \class{QWidget} class is the base class for all widgets
and implements their shared functionality.

Upon construction, widgets are invisible, so that they may be
configured behind the scenes. The \property{visible}{QWidget}
property controls whether a widget is visible. 
<<qt-overview-visible>>=
w <- Qt$QWidget()
w$visible
w$visible <- TRUE
w$visible
@ 
%
The \method{show}{QWidget} and \method{hide}{QWidget} methods are
the corresponding convenience functions for making a widget visible
and invisible, respectively. 
<<qt-overview-show-hide, results=hide>>=
w$show()
@ 
<<>>=
w$visible
@ 
<<results=hide>>=
w$hide()
@ 
<<>>=
w$visible
@ 
%
There is an S3 method for \meth{print} on \class{QWidget} that invokes
\method{show}{QWidget}. Whenever a widget is shown, all of its
children are also made visible. The method \method{raise}{QWidget}
will raise the window to the top of the stack of windows.

Similarly, the property \property{enabled}{QWidget} controls whether a
widget is sensitive to user input, including mouse events.
<<qt-overview-enabled>>=
b <- Qt$QPushButton("button")
b$enabled <- FALSE
b$enabled
@ 
%

Only one widget can have the keyboard focus at once. The user shifts
the focus by tab-navigation or mouse clicks (although this behavior
can be customized, cf. \method{focusPolicy}{QWidget}). When a widget
has the focus, its \property{focus}{QWidget} property is
\code{TRUE}. The property is read-only; the focus is shifted
programmatically to a widget by calling its \method{setFocus}{QWidget}
method.

\Qt{} has a number of mechanisms for the user to query a widget for
some description of its purpose and usage. Tooltips, stored as a
string in the \property{toolTip}{QWidget} property, may be shown when the
user hovers the mouse over the widget. Similarly, the
\property{statusTip}{QWidget} property holds a string to be shown in
the status bar instead of a popup window. Finally, \Qt\/ provides a
``What's This?'' tool that will show the text in the
\property{whatsThis}{QWidget} property in response to query, such as
pressing \kbd{SHIFT+F1} when the widget has focus.

Except for top-level windows, the position and size of a widget are
determined automatically by a layout algorithm; see
Chapter~\ref{cha:layout-managers}. To specify the size of a top-level
window, manipulate the \property{size}{QWidget} property, which
holds a \class{QSize} object: 
<<qt-overview-size, results=hide>>=
w$size <- qsize(400, 400)
## or
w$resize(400, 400)
w$show()
@ 
%
We create the \class{QSize} object with the \function{qsize}
convenience function implemented by the \pkg{qtbase} package. The
\method{resize}{QWidget} method is another convenient shortcut. One
should generally configure the size of a window before showing it, as
this helps the window manager optimally place the window.

\subsection{Fonts}
\label{sec:fonts}

Fonts in \Qt{} are represented by the \class{QFont} class. The
\pkg{qtbase} package defines a convenience constructor for \class{QFont}
called \function{qfont}. The
constructor accepts a \code{family}, such as
\code{helvetica}; \code{pointsize}, an integer; \code{weight}, an
enumerated value such as \code{Qt\$QFont\$Light} (or \code{Normal},
\code{DemiBold}, \code{Bold}, or \code{Black}); and whether the font
should be italicized, as a logical. Defaults are obtained from the
application font, returned by \code{Qt\$QApplication\$font()}.

For example, we could create a 12 point, bold, italicized font from
the Helvetica family with:
<<>>=
f <- qfont(family="helvetica", pointsize=12, 
           weight=Qt$QFont$Bold, italic=TRUE)
@ 

The font for a widget is stored in the \property{font}{QWidget}
property. For example, we change the font for a label:
<<results=hide>>=
l <- Qt$QLabel("Text for the label")
l$font$toString()
l$font <- f
l$font$toString()
@ 

The \class{QFont} class has several methods to query the font and to
adjust properties. For example, there are the methods
\method{setFamily}{QFont}, \method{setUnderline}{QFont},
\method{setStrikeout}{QFont} and \method{setBold}{QFont} among others.

To discover which fonts are available from the windowing system,
construct a \class{QFontDatabase} and call its methods like
\method{families}{QFontDatabase}, \method{pointSizes}{QFontDatabase},
\method{styles}{QFontDatabase}, etc.

%% Palettes (colors); roles

\subsection{Styles}
\label{sec:styles}

\paragraph{Palette}

Every platform has its own distinct look and feel, and an application
should generally conform to platform conventions. \Qt{} hides these details from
the application. Every widget has a palette, stored in its
\property{palette}{QWidget} property and represented by a \class{QPalette}
object. A \class{QPalette} maps the state of a widget to a group of
colors that is used for painting the widget. The possible states are
\code{active}, \code{inactive} and \code{disabled}. Each color within
a group has a specific role, as enumerated in
\qtenumeration{QPalette::ColorRole}. Examples include the color for
background (\code{Window}), the foreground (\code{WindowText}) and the
selected state (\code{Highlight}). \Qt{} chooses the correct default
palette depending on the platform and the type of widget. One can
change the colors used in rendering a widget by manipulating the
palette.

\paragraph{Style sheets}
\label{ssec:style-sheets}
Cascading style sheets (CSS) are used by web designers to decouple the
layout and look and feel of a web page from the content of the
page. In \Qt{} it is also possible to customize the rendering of a widget using CSS
syntax. The supported syntax is described in the overview on
stylesheets provided with \Qt{} documentation and is not summarized
here, as it is quite readable.

The style sheet for a widget is stored in its
\property{styleSheet}{QWidget} property, as a string. For example, for
a button, we could set the background to white and the foreground to
red (see Figure~\ref{fig:qt-style-sheet} for an example):
<<qt-overview-stylesheets, results=hide>>=
b <- Qt$QPushButton("Style sheet example")
b$show()
b$styleSheet <- "QPushButton {color: red; background: white}"
@ 

<<echo=FALSE, eval=FALSE>>=
w <- Qt$QWidget()
w$windowTitle <- "Using Style Sheets"
lyt <- Qt$QHBoxLayout()
w$setLayout(lyt)

b <- Qt$QPushButton("Style sheet example")
lyt$addWidget(b)
b1 <- Qt$QPushButton("Style sheet example")
qsetStyleSheet(color = "red", background = "white", 
               what = "QPushButton", widget = b1)
lyt$addWidget(b1)

w$show()
w$raise()
@ 

The CSS syntax may be unfamiliar to \R\/ programmers, so the \pkg{qtbase}
package provides an alternative interface that is reminiscent of the
\function{par} function. We specify the above stylesheet in this syntax:
<<qt-overview-qsetStyleSheet, eval=FALSE>>=
qsetStyleSheet(color = "red", background = "white", 
               what = "QPushButton", widget = b)
@ 
%
The \code{widget} argument defaults to \code{NULL}, which applies the
stylesheet application-wide through the \class{QApplication}
instance. The default for \code{what} is \code{"*"}, meaning that the
stylesheet applies to any widget class. The following would cause all
widgets in the application to have the same colors as the button:

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-qt-style-sheet-example}
  \caption{Styling a widget with a style sheet can dramatically alter its appearance}
  \label{fig:qt-style-sheet}
\end{figure}

%% XXX JV -- need to upgrade qtbase
<<qt-overview-qsetStyleSheet-defaults>>=
qsetStyleSheet(color = "red", background = "white")
@ 

\begin{example}{An ``error label''}{eg:qt-error}
 %% JV: Replace with this: (drawback: no a custom constructor, issue with
  %% base:::paste, versus paste is a good one; style sheet example; 
 This example extends the line edit widget to display an error state
  via an icon embedded within the entry box. Such a widget might prove
  useful when one is validating entered values. Our implementation
  uses a stylesheet to place the icon in the background and to prevent
  the text from overlapping the icon.

  \begin{figure}
    \centering
    \includegraphics[width=.7\textwidth]{fig-qt-line-edit-error}
    \caption{Using a stylesheet to customize the line edit class to show an error indicator}
    \label{fig:qt-line-edit-error}
  \end{figure}
  
  
  To indicate an error, we will add an icon and set the tooltip to
  display an informative message
  (Figure~\ref{fig:qt-line-edit-error}). The constructor will be the
  default, so our class is defined with:
<<LineEditWithError, results=hide>>=
qsetClass("LineEditWithError", Qt$QLineEdit)
@   

  The main method sets the error state. We use style sheets to place an
  image to the left of the entry message and set the tooltip.
<<setError, results=hide>>=
qsetMethod("setError", LineEditWithError, function(msg) {
  f <- system.file("images/cancel.gif", package="gWidgets")
  qsetStyleSheet("background-image" = sprintf("url(%s)", f),
                 "background-repeat" = "no-repeat",
                 "background-position" = "left top",
                 "padding-left" = "20px",
                 widget = this)
  setToolTip(msg)
})
@ 
% 

  We can clear the error by resetting the properties to \code{NULL}.
<<clearError,results=hide>>=
qsetMethod("clearError", LineEditWithError, function() {
  setStyleSheet(NULL)
  setToolTip(NULL)
})
@ 
% 

<<testOut,results=hide>>=
e <- LineEditWithError()
e$text <- "The quick brown fox..."
e$setError("Replace with better boilerplate text")
e$clearError()
@ 
% 
<<show_raise,echo=FALSE, results=hide>>=
w <- Qt$QWidget()
lyt <- Qt$QHBoxLayout()
lyt$addWidget(e)
w$setLayout(lyt)
w$show()
w$raise()
@ 

\end{example}

\section{Importing a GUI from QtDesigner}
\label{sec:qt-designer}

\pkg{QtDesigner} is a tool for graphical, drag-and-drop design of GUI
forms. Although this book focuses on constructing a GUI by programming
in R, we recognize that a graphical approach may be preferable in some
circumstances.  \pkg{QtDesigner} outputs a GUI definition as an XML
file in the \qcode{UI} format. The \class{QUiLoader} class loads a
\qcode{UI} definition\footnote{The \texttt{textfinder.ui} file was
  taken from the Qt Text Finder example at
  \url{http://doc.qt.nokia.com/4.7-snapshot/uitools-textfinder.html}.
} through its \method{load}{QUiLoader} method:
%% JV commented these out until I have designer.ui to they run...
%% JV should we put designer.ui into the package somewhere?
<<has_loader, echo=FALSE>>=
has_uiloader <- !is.null(Qt$QUiLoader)
@ 
<<qt-overview-designer-load, eval=FALSE>>=
loader <- Qt$QUiLoader()
widget <- loader$load(Qt$QFile("textfinder.ui"))
@ 
<<echo=FALSE>>=
if(has_uiloader) {
<<qt-overview-designer-load>>
}
@ 
%

The \code{widget} object could be shown directly; however, we first
need to implement the behavior of the GUI by connecting to
signals. Through the \pkg{QtDesigner} GUI, the user can connect
signals to slots on built-in widgets. This works for some trivial
cases, but in general one needs to handle signals with R code. There
are two ways to accomplish this: manual or automatic.

To manually connect an R handler to a signal, we first need to obtain
the widget with the signal.  Every widget in a \code{UI} file is
named, so we can call the \function{qfindChild} utility function to
find a specific widget. Assume we have a button named ``findButton''
and corresponding text entry ``lineEdit'' in our UI file, then we
retrieve them with
<<qt-overview-designer-find, eval=FALSE>>=
findButton <- qfindChild(widget, "findButton") # by name
lineEdit <- qfindChild(widget, "lineEdit")
@ 
<<echo=FALSE>>=
if(has_uiloader) {
<<qt-overview-designer-find>>
}
@ 
%
Then we connect to the \signal{clicked} signal:
<<qt-overview-designer-connect, eval=FALSE>>=
qconnect(findButton, "clicked", function() {
  findText(lineEdit$text)
})
@ 
<<echo=FALSE>>=
if(has_uiloader) {
<<qt-overview-designer-connect>>
}
@ 
%
Note that the \function{findText} function above is not implemented.

Alternatively, we could establish the signal connections
automatically. This requires defining each signal handler to be a slot
in the parent object, which will need to be of a custom class:
<<qt-overview-designer-custom-parent, eval=FALSE>>=
qsetClass("MyMainWindow", Qt$QWidget, function() {
  loader <- Qt$QUiLoader()
  widget <- loader$load(Qt$QFile("textfinder.ui"), this)
  Qt$QMetaObject$connectSlotsByName(this)
})
@ 
<<echo=FALSE>>=
if(has_uiloader) {
<<qt-overview-designer-custom-parent>>
}
@ 
%%
The constructor first loads the UI definition, with the main window as
the parent for the loaded interface. It then calls
\method{connectSlotsByName}{QMetaObject} to automatically establish
the connections. This descends the widget hierarchy, attempting to
match signals in the descendants to slots in the top-level widget. For
a slot to be connected to the correct signal, it must be named
according to the convention
\qcode{on\_[objectName]\_[signalName]}. For example,
<<qt-overview-designed-slot-handler, eval=FALSE>>=
qsetSlot("on_findButton_clicked", MyMainWindow, function() {
  findText(lineEdit$text)
})
@ 
<<echo=FALSE>>=
if(has_uiloader) {
<<qt-overview-designed-slot-handler>>
}
@ 
%
defines a handler for the \signal{clicked} signal on
\code{findButton}.  Finally, the signal handler connection is
established upon construction of the main window:
<<qt-overview-designed-custom-construct, eval=FALSE>>=
MyMainWindow()
@ 
<<echo=FALSE>>=
if(has_uiloader) {
<<qt-overview-designed-custom-construct>>
}
@ 
In the case of a large, complex GUI, this automatic approach is
probably more convenient than manually establishing the connections.

