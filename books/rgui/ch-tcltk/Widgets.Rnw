%% Rewrite
\Tk\/ has widgets for the common GUI controls. As mentioned in
Chapter~\ref{sec:tcltk:overview} -- where we illustrated both buttons
and labels -- the constructors for these widgets call the function
\function{tkwidget} which calls the appropriate \TK\/ command and adds
in extra information including an ID and an environment. As with
labels and buttons, one primarily uses \function{tkconfigure} and
\function{tkcget} to set and get properties of the widget when a
\TCL\/ variable is not used to store the data for the widget.



\section{Dialogs}
\label{sec:tcltk:dialogs}
\SweaveInput{Dialogs}



\section{Selection Widgets}
\label{sec:tcltk:selection-widgets}

This section covers the many different ways to present data for the
user to select a value. The widgets can use \TCL\/ variables to refer
to the value that is displayed or that the user selects.  Recall,
these were constructed through \function{tclVar} and manipulated
through \code{tclvalue}.  For example, a logical value can be stored as
<<>>=
value <- tclVar(TRUE)
tclvalue(value) <- FALSE
tclvalue(value)
@ 
As \code{tclvalue} coerces the logical into the  character string  \qcode{0} or \qcode{1}, some coercion may be desired.

\subsection{Checkbutton}
\label{sec:tcltk:checkboxes}

The \constructor{ttkcheckbutton} constructor returns a check button
object. The checkbuttons value (\code{TRUE} or \code{FALSE}) is linked
to a \TCL\/ variable which can be specified using a logical value.
The checkbutton label can also be specified through a \TCL\/ variable
using the \option{textvariable}{ttkcheckbutton} option.  Alternately,
as with the \code{ttklabel} constructor, the label can be specified
through the \option{text}{ttkcheckbutton} option. As well, one can
specify an image and arrange its display -- as is done with
\function{ttklabel} -- using the \option{compound}{ttkcheckbutton}
option.

The \option{command}{ttkcheckbutton} argument is used at construction
time to specify a callback when the button is clicked. The callback is
called when the state toggles, so often a callback considers the state
of the widget before proceeding.  To add a callback with
\function{tkbind} use \code{\Event{ButtonRelease-1}}, as the callback
for the event \code{\Event{Button-1}} is called before the variable is
updated.

For example, if \code{f} is a frame, we can create a new check button
with the following:
<<setup-window,echo=FALSE>>=
w <- tktoplevel(); tkwm.title(w, "Check button example")
f <- ttkframe(w); tkpack(f, expand=TRUE, fill="both")
@ 

<<make-TCL-variables>>=
value <- tclVar(TRUE)
callback <- function() print(tclvalue(value))     # uses global
labelVar <- tclVar("check button label")
cb <- ttkcheckbutton(f, variable=value, 
                     textvariable=labelVar, command=callback)
tkpack(cb)
@ 

To avoid using a global variable is not trivial here. There is no easy
way to pass user data through to the callback, and there is no easy
way to get the \R\/ object from the values passed through the \%
substitution values. The variable holding the value can be found
through
<<>>=
tkcget(cb, "variable"=NULL)
@ 

But then, one needs a means to lookup the variable from this id. Here is a
wrapper for the \function{tclVar} function and a lookup function that
use an environment created by the \pkg{tcltk} package in place of a
global variable.

<<ourTclVar>>=
ourTclVar <- function(...) {
  var <- tclVar(...)
  .TkRoot$env[[as.character(var)]] <- var
  var
}
## lookup function
getTclVarById <- function(id) {
  .TkRoot$env[[as.character(id)]]
}
@ 

Assuming we used \function{ourTclVar} above, then the callback above
could be defined to avoid a global variable by:

<<ourTclVarExample, echo=FALSE>>=
w <- tktoplevel(); tkwm.title(w, "Check button example")
f <- ttkframe(w); tkpack(f, expand=TRUE, fill="both")
value <- ourTclVar(TRUE)
@

<<>>=
callback <- function(W) {
  id <- tkcget(W, "variable"=NULL)
  print(getTclVarById(id))
}
@ 

<<echo=FALSE>>=
labelVar <- tclVar("check button label")
cb <- ttkcheckbutton(f, variable=value, 
                     textvariable=labelVar, command=callback)
tkpack(cb)
@ 


\paragraph{A toggle button}

By default the widget draws with a check box. Optionally the widget
can be drawn as a button, which when depressed indicates a \code{TRUE}
state. This is done by using the style \code{Toolbutton}, as in:
<<>>=
tkconfigure(cb, style="Toolbutton")
@ 

The ``Toolbutton'' style is for placing widgets into toolbars.

\subsection{Radio Buttons}
\label{sec:tcltk:radio-buttons}

Radiobuttons are basically differently styled checkbuttons linked through a shared \TCL\/
variable. Each radio button is constructed through the
\constructor{ttkradiobutton} constructor. Each button has both a value and
a text label, which need not be the same. The
\option{variable}{ttkradiobutton} option refers to the
value. As with labels, the radio button labels may be specified
through a text variable or the \option{text}{ttkradiobutton} option,
in which case, as with a \code{ttklabel}, an image may also be
incorporated through the \option{image}{ttkradiobutton} and
\option{compound}{ttkradiobutton} options. In \TK\/ the placement of
the buttons is managed by the programmer.

<<radio-button-1,echo=FALSE>>=
w <- tktoplevel(); tkwm.title(w, "Radio example")
f <- ttkframe(w, padding=c(3,3,12,12)); tkpack(f, expand=TRUE, fill="both")
@ 

This small example shows how radio buttons could be used for selection
of an alternative hypothesis, assuming \code{f} is a parent container.

<<radio-button-2, results=hide>>=
values <- c("less", "greater", "two.sided")
var <- tclVar(values[3])                # initial value
callback <- function() print(tclvalue(var))
sapply(values, function(i) {
  rb <- ttkradiobutton(f, variable=var, 
                       text=i, value=i, 
                       command=callback)
  tkpack(rb, side="top", anchor="w")
})
@ 


\subsection{Combo boxes}
\label{sec:tcltk:comboboxes}

The \constructor{ttkcombobox} constructor returns a combo box object
allowing for
selection from a list of values, or, with the appropriate option, allowing
the user to specify a value. Like radiobuttons and checkbuttons, the
value of the combo box can be specified using a \TCL\/ variable to the
option \option{textvariable}{ttkcombobox}, making the getting and
setting of the displayed value straightforward. The possible values to
select from are specified as a character vector through the
\option{values}{ttkcombobox} option. (This may require one to coerce
the results to the desired class.)

Unlike \GTK{} and \Qt{} there is no option to include images in the
displayed text. One can adjust the alignment through the
\option{justify}{ttkcombobox} options.  By default, a user can add in
additional values through the entry widget part of the combo box. The
\option{state}{ttkcombobox} option controls this, with the default
\qcode{normal} and the value \qcode{readonly} as an alternative.

To illustrate, again suppose \code{f} is a parent container. Then we
begin by defining some values to choose from and a \TCL\/ variable.

<<echo=FALSE>>=
w <- tktoplevel(); tkwm.title(w, "Combo box example")
f <- ttkframe(w, padding=c(3,3,12,12))
tkpack(f, expand=TRUE, fill="both")
@ 

<<>>=
values <- state.name
var <- tclVar(values[1])                # initial value
@ 

The constructor call is as follows:
<<>>=
cb <- ttkcombobox(f,
                  values=values,
                  textvariable=var,
                  state="normal", # or "readonly"
                  justify="left")
tkpack(cb)
@ 


The possible values the user can select from can be configured after
construction through the \option{values}{ttkcombobox} option:
<<Combobox-set-values>>=
tkconfigure(cb, values=tolower(values))
@ 

There is one case where the above won't work: when there is a single
value and this value contains spaces. In this case, one can coerce the
value to be of class \class{tclObj}:
<<combobox-set-length-1, eval=FALSE>>=
tkconfigure(cb, values=as.tclObj("New York"))
@ 

\paragraph{Setting the value}
Setting values can be done through the \TCL\/ variable. As well, the
value can be set by value using the \subcommand{set}{ttkcombobox} sub
command through \function{tkset} or by index (0-based) using the
\subcommand{current}{ttkcombobox} sub command.

<<Combobox-set>>=
tclvalue(var) <- values[2]            # using tcl variable
tkset(cb, values[4])                  # by value
tcl(cb, "current", 4)                 # by index
@ 


\paragraph{Getting the value}
One can retrieve the selected object in various ways: from the \TCL\/
variable. Additionally, the \subcommand{get}{ttkcombobox} subcommand
can be used through \function{tkget}.

<<Combobox-get>>=
tclvalue(var)                           # TCL variable
tkget(cb)                               # get subcommand
tcl(cb, "current")                      # 0-based index
@ 


\paragraph{Events}
The virtual event \code{\VirtualEvent{ComboboxSelected}} occurs with
selection. When the combo box may be edited, a user may expect some
action when the \kbd{return} key is pressed. This triggers a
\code{\Event{Return}} event. To bind to this event, one can do something
like the following:
<<combobox-selection-binding, echo=FALSE>>=
tkbind(cb, "<<ComboboxSelected>>", function() {
  print(tclvalue(var))
} )
@ 

<<Combobox-binding-to-return>>=
tkbind(cb, "<Return>", function(W) {
  val <- tkget(W)
  cat(as.character(val), "\n")
})
@ 

For editable combo boxes, the widget also supports some of the
\function{ttkentry} commands discussed in
Section~\ref{sec:tcltk:entry-widgets}.


% \subsection{Listboxes}
% \label{sec:tcltk:listboxes}

% The \constructor{tklistbox} is a non-themed widget that can be used
% to select from a table of values. One can do a similar thing using
% the more general tree widget provided by \function{ttktreeview}
% widget, but the listbox is more convenient to use.



\subsection{Scale widgets}
\label{sec:tcltk:scale-widgets}

The \constructor{ttkscale} constructor to produce a themeable scale
(slider) control is missing~\footnote{As of the version of \pkg{tcltk}
  accompanying \R{} 2.12.0}. You can define your own simply enough:
<<ttkscale>>=
ttkscale <- function(parent, ...) tkwidget(parent, "ttk::scale", ...)
@ 

The orientation is set through the option \option{orient}{ttkscale}
taking values of \qcode{horizontal} (the default) or
\qcode{vertical}. For sizing the slider, the \option{length}{ttkscale}
option is available.  

To set the range, the basic options are \option{from}{ttkscale} and
\option{to}{ttkscale}. There is no \code{by} option as of \TK\/
8.5. The constructor \constructor{tkscale}, for a non-themeable slider,
has the option \option{resolution}{tkscale} to set that. Additionally,
the themeable slider does not have any label or tooltip indicating its
current value.


As a workaround, we show how to display a vector of values by
sliding through the indices and place labels at the ends of the slider
to indicate the range. We write this using an \R{} reference class.

<<ttksliderclass>>=
Slider <-
  setRefClass("TtkSlider",
              fields=c("frame", "widget", "v", "x"),
              methods=list(
                initialize=function(parent, x) {
                  x <<- x
                  v <<- tclVar(1)
                  frame <<- ttkframe(parent)
                  widget <<- ttkscale(frame, from=1, to=length(x),
                                      variable=v, orient="horizontal")
                  #
                  tkgrid(widget, row=0, column=0, columnspan=3, sticky="we")
                  tkgrid(ttklabel(frame, text=x[1]), row=1, column=0)
                  tkgrid(ttklabel(frame, text=x[length(x)]), row=1, column=2)
                  tkgrid.columnconfigure(frame, 1, weight=1)
                  #
                  .self
                },
                get_value=function() x[as.numeric(tclvalue(v))],
                set_value=function(value) {
                  "Set value. Value must be in x"
                  ind <- match(value, x)
                  if(!is.na(ind)) {
                    v_local <- v
                    tclvalue(v_local) <- ind
                  }
                }
                ))
@ 

To use this, we have:
<<>>=
w <- tktoplevel()
x <- seq(0,1,by=0.05)
s <- Slider$new(parent=w, x=x)
tkpack(s$frame, expand=TRUE, fill="x")
#
s$set_value(0.5)
print(s$get_value())
@ 

As seen, the \option{variable}{ttkscale} option can be used for
specifying a \TCL\/ variable to record the value of the slider. This
is convenient when the variable and widget are encapsulated into a
class, as above. Otherwise the \option{value}{ttkscale} option is
available.  The \function{tkget} and \function{tkset} function (using
the \subcommand{get}{ttkscale} and \subcommand{set}{ttkscale} sub
commands) can be used to get and set the value shown. They are used in
the same manner as the same-named subcommands for a combo box.

Again, the \option{command}{ttkscale} option can be used to specify a
callback for when the slider is manipulated by the user. E.g.:
<<use-slider-command>>=
tkconfigure(s$widget, command=function(...) {
  print(s$get_value())
})
@ 
For this widget, the callback is passed a value which we ignore above.


\subsection{Spin boxes}
\label{sec:tcltk:spinboxes}

In \TK\/ version 8.5 there is no themeable spinbox widget. In \TK\/ the
\code{spinbox} command produces a non-themeable spinbox. Again, there
is no direct \constructor{tkspinbox} constructor, but one can be
defined with:
<<tkspinbox>>=
tkspinbox <- function(parent, ...) 
  tkwidget(parent, "tk::spinbox", ...)
@ 

The non-themeable widgets have many more options than the themeable
ones, as style properties can be set on a per-widget basis. We won't
discuss those here. The spinbox can be used to select from a sequence
of numeric values or a vector of character values.


For example, the following allows a user to scroll either direction through the 50
states of the U.S.

<<>>=
w <- tktoplevel()
@ 
<<>>=
sp <- tkspinbox(w, values=state.name, wrap=TRUE)
@ 

Whereas, this invocation will scroll through a numeric sequence
<<>>=
sp1 <- tkspinbox(w, from=1, to=10, increment=1)
@ 

<<>>=
tkpack(sp)
tkpack(sp1)
@ 


The basic options to set the range for a numeric spinbox are
\option{from}{tkspinbox}, \option{to}{tkspinbox}, and
\option{increment}{tkspinbox}.  The \option{textvariable}{tkspinbox}
option can be used to link the spinbox to a \TCL\/ variable. As usual,
this allows the user to easily get and set the value
displayed. Otherwise, the \function{tkget} and \function{tkset}
functions may be used for these tasks. 

As seen, in \TK spin boxes can also be used to select from a list of text
values. These are specified through the \option{values}{tkspinbox}
option. In the example, we set the \option{wrap}{tkspinbox} option to \code{TRUE}
so that the values wrap around when
the end is reached. 
 
The option \option{state}{tkspinbox} can be used to specify whether
the user can enter values, the default of \qcode{normal}; not edit the
value, but simply select one of the given values (\qcode{readonly}),
or not select a value (\qcode{disabled}).  As with a combo box, when
the \TK\/ spinbox displays character data and is in the \qcode{normal}
state, the widget can be controlled like the entry widget of
Section~\ref{sec:tcltk:entry-widgets}.



% \begin{example}{A GUI for selecting a numeric range}{ex-tcltk-doublescale}
%   \SweaveInput{ex-tcltk-doublescale}
% \end{example}

%% Too much? It ain't pretty
\begin{example}{A GUI for \code{t.test}}{ex-tcltk-t-test}
  \SweaveInput{ex-tcltk-t-test.Rnw}
\end{example}


\section{Text widgets}
\label{sec:tcltk:text-widgets}
\Tk\/ provides both single- and multi-line text entry widgets. The
section describes both and introduces scrollbars which are often
desired for multi-line text entry.

\subsection{Entry Widgets}
\label{sec:tcltk:entry-widgets}

The \constructor{ttkentry} constructor provides a single line text
entry widget. The widget can be associated with a \TCL\/ variable at
construction to facilitate getting and setting the displayed values
through its argument \argument{textvariable}{ttkentry}. The width of
the widget can be adjusted at construction time through the
\argument{width}{ttkentry} argument. This takes a value for the number
of characters to be displayed, assuming average-width characters.  The
text alignment can be set through the \argument{justify}{ttkentry}
argument taking values of \qcode{left} (the default), \qcode{right}
and \qcode{center}. For gathering passwords, the argument
\argument{show}{ttkentry} can be used, such as with
\code{show=}\qcode{*}, to show asterisks in place of all the
characters.

The following constructs a basic example
<<entryExample,echo=FALSE>>=
w <- tktoplevel()
tkwm.title(w,"Entry widget test")
f <- ttkframe(w, padding=c(3,3,3,12)); tkpack(f, expand=TRUE, fill="both")
@ 
<<entryExampleDef>>=
eVar <- tclVar("initial value")
e <- ttkentry(w, textvariable=eVar)
tkpack(e)
@ 

We can get and set values using the \TCL\/ variable.
<<>>=
tclvalue(eVar)
tclvalue(eVar) <- "set value"
@ 

The \code{get} command can also be used.
<<tkget>>=
tkget(e)
@ 

\paragraph{Indices}
The entry widget uses an index to record the different positions
within the entry box. This index can be a number (0-based), an
$x$-coordinate of the value (\code{@x}), or one of the values
\qcode{end} and \qcode{insert} to refer to the end of the current text
and the insert point as set through the keyboard or mouse. The mouse
can also be used to make a selection. In this case the indices
\qcode{sel.first} and \qcode{sel.last} describe the selection.

With indices, we can insert  text with the \subcommand{insert}{ttkentry} command
<<tkinsert>>=
tkinsert(e, "end", "new text")
@ 

Or, we can delete a range of text, in this case the first 4
characters, using \subcommand{delete}{ttkentry}. The first value is
the left most index to delete (0-based), the second value the index to
the right of the last value deleted.
<<>>=
tkdelete(e, 0, 4) # e.g.,  a b c d e f   -text
                  #       | | | | | | |
                  #       0 1 2 3 4 5 6  -index
@ 

The \subcommand{icursor}{ttkentry} command can be used to set the
cursor position to the specified index.
<<>>=
tkicursor(e, 0)                         # move to beginning
@ 

Finally, we note that the selection can be adjusted using the
\subcommand{selection range}{ttkentry} subcommand. This takes two
indices. Like \code{delete}, the first index specifies the first character of
the selection, the second indicates the character to the right of the
selection boundary. The following example would select all the text.
<<>>=
tkselection.range(e, 0, "end")
@ 
The \subcommand{selection clear}{ttkentry} subcommand clears the selection and \subcommand{selection present}{ttkentry} signals if a selection is currently made.

\paragraph{Events}
Several useful events include \code{\Event{KeyPress}} and
\code{\Event{KeyRelease}} for key presses and \code{\Event{FocusIn}}
and \code{\Event{FocusOut}} for focus events.

% The examples show a bit more about the entry widget. The first  shows how styles can be used to adjust the look of an entry widget, and the second how to validate the users data entry in an entry widget.

%% XXX This is too technical. -- put into package?
% \begin{example}{Using styles to adjust the look of an entry widget}{ex:tcltk-searchentry}
%   \SweaveInput{ex-tcltk-searchentry.Rnw}
% \end{example}

\begin{example}{Putting in default text}{ex:tcltk-entry-initial-message}
 \SweaveInput{ex-tcltk-initial-message}
\end{example}


\begin{example}{Using validation for dates}{ex:tcltk-validation-dates}
  \SweaveInput{ex-tcltk-validation}
\end{example}


\subsection{Scrollbars}
\label{sec:tcltk:scrollbars}

\TK\/ has several scrollable widgets -- those that use scrollbars.
Widgets which accept a scrollbar (without too many extra steps) have
the options \code{xscrollcommand} and \code{yscrollcommand}.  To use
scrollbars in \pkg{tcltk} requires two steps: the scrollbars must be
constructed and bound to some widget, and that widget must be told it
has a scrollbar. This way changes to the widget can update the
scrollbar and vice versa. Suppose, \code{parent} is a container and
\code{widget} has these options, then the following will set up both
horizontal and vertical scrollbars.
<<scrollbar-example,echo=FALSE>>=
library(tcltk)
w <- tktoplevel(); tkwm.title(w, "Scrollbar example")
parent <- ttkframe(w); tkpack(parent, expand=TRUE, fill="both")
widget <- tktext(parent)
@ 

The scrollbars are defined first, as follows, using the
\option{orient}{ttkscrollbar} option and a command of the following
form.
<<>>=
xscr <- ttkscrollbar(parent, orient="horizontal",
                     command=function(...) tkxview(widget, ...))
yscr <- ttkscrollbar(parent, orient="vertical",
                     command=function(...) tkxview(widget, ...))
@ 
The \code{view} commands set what part of the widget is being shown.

To link the widget back to the scrollbar, the \code{set} command is
used in a callback to the scroll command.  For this example we
configure the options after the widget is constructed, but this can be
done at the time of construction as well. Again, the command takes a
standard form:
<<>>=
tkconfigure(widget,
            xscrollcommand=function(...) tkset(xscr,...),
            yscrollcommand=function(...) tkset(yscr,...))
@ 

Although scrollbars can appear anywhere, the conventional place is on the right and lower side of the parent. The following adds scrollbars using the grid manager. The combination of weights and stickiness below will have the scrollbars expand as expected if the window is resized. 
<<>>=
tkgrid(widget, row=0, column=0, sticky="news")
tkgrid(yscr,row=0,column=1, sticky="ns")
tkgrid(xscr, row=1, column=0, sticky="ew")
tkgrid.columnconfigure(parent, 0, weight=1)
tkgrid.rowconfigure(parent, 0, weight=1)
@ 
%
Although a bit tedious, this gives the programmer some flexibility in
arranging scrollbars. To avoid doing all this in the sequel, we turn
the above into the function \function{addScrollbars} for subsequent
usage (not shown).

<<addScrollbars, echo=FALSE>>=
## function to add scrollbars to widget and pack into grid
## parent uses grid manager -- con't pack in other children
addScrollbars <- function(parent, widget) {
  xscr <- ttkscrollbar(parent, orient="horizontal",
                       command=function(...) tkxview(widget, ...))
  yscr <- ttkscrollbar(parent, orient="vertical",
                       command=function(...) tkxview(widget, ...))

  tkconfigure(widget,
              xscrollcommand=function(...) tkset(xscr,...),
              yscrollcommand=function(...) tkset(yscr,...))

  tkgrid(widget, row=0, column=0, sticky="news")
  tkgrid(yscr,row=0,column=1, sticky="ns")
  tkgrid(xscr, row=1, column=0, sticky="ew")
  tkgrid.columnconfigure(parent, 0, weight=1)
  tkgrid.rowconfigure(parent, 0, weight=1)
}
@ 

\subsection{Multi-line Text Widgets}
\label{sec:tcltk:multi-line-text}

\XXX{Add in bit about fonts!}

The \constructor{tktext} widget creates a multi-line text editing
widget. If constructed with no options but a parent container, the
widget can have text entered into it by the user.
<<ex-tktext-easiest, echo=FALSE>>=
w <- tktoplevel(); tkwm.title(w, "Simple tktext example")
t <- tktext(w); tkpack(t)
@ 
%

%% arguments width, height
The text widget is not a themed widget, hence has numerous arguments
to adjust its appearance. We mention a few here and leave the rest to
be discovered in the manual page (along with much else). The argument
\argument{width}{tktext} and \argument{height}{tktext} are there to
set the initial size, with values specifying number of characters and
number of lines (not pixels). The actual size is font dependent, with
the default for 80 by 24 characters. The \argument{wrap}{tktext}
argument, with a value from \qcode{none}, \qcode{char}, or
\qcode{word}, indicates if wrapping is to occur and if so, does it
happen at any character or only a word boundary. The argument
\argument{undo}{tktext} takes a logical value indicating if the undo
mechanism should be used. If so, the subcommand
\subcommand{edit}{tktext} can be used to undo a change (or the
\kbd{control-z} keyboard combination).



\paragraph{Indices}
As with the entry widget, several commands take indices to specify
position within the text buffer. Only for the multi-line widget both a
line and character are needed in some instances. These indices may be
specified in many ways. One can use row and character numbers
separated by a period in the pattern \code{line.char}. The line is
$1$-based, the column $0$-based (e.g., \code{1.0} says start on the
1st row and first character). In general, one can specify any line
number and character on that line, with the keyword \code{end} used to
refer to the last character on the line. Text buffers may carry
transient marks, in which case the use of this mark indicates the next
character after the mark. Predefined marks include \code{end}, to  specify the end of the
buffer, \code{insert}, to track the insertion point in the text
buffer were the user to begin typing, and \code{current}, which 
follows the character closest to the mouse position. As well, pieces
of text may be tagged. The format \code{tag.first} and \code{tag.last}
index the range of the tag \code{tag}. Marks and tags are described
below. If the $x$-$y$ postion of the spot is known (through percent
substitutions say) the index can be specified by postion, as \code{\@x,y}.

Indices can also be adjusted relative to the above
specifications. This adjustment can be by a number of characters
(\code{chars}), index positions (\code{indices}) or \code{lines}. For
example, \code{insert + 1 lines} refers to 1 line under the insert
point. The values \code{linestart}, \code{lineend}, \code{wordstart}
and \code{wordend} are also available. For instance, \code{insert
  linestart} is the beginning of the line from the insert point, while
\code{end -1 wordstart} and \code{end - 1 chars wordend} refer to the
beginning and ending of the last word in the buffer. (The \code{end}
index refers to the character just after the new line so we go back 2
steps.)

\paragraph{Getting text}
%% multiline? tclvalue versus as.character
The \subcommand{get}{tktext} subcommand is used to retrive the text in the buffer. Coercion to character should be done with \function{tclvalue} and not \function{as.character} to preserve the distinction between spaces and line breaks.

<<get-values>>=
value <- tkget(t, "1.0", "end")
as.character(value)                     # wrong way
tclvalue(value)
@ 

\paragraph{Inserting text}
Inserting text can be done through the \subcommand{insert}{ttktext}
subcommand by specifying first the index then the text to add. One can use \code{$\backslash$n} to add new lines.
<<tkinsert-example>>=
tkinsert(t, "end", "more text\n new line")  
@ 
Images and other windows can be added to a text buffer, but we do not discuss that here.

The buffer can have its contents cleared using \code{tkdelete}, as
with \code{tkdelete(t, "0.0", "end")}.

\paragraph{Panning the buffer: tksee}
After text is inserted, the visible part of buffer may not be what is
desired. The \subcommand{see}{ttktext} sub command is used to position
the buffer on the specified index, its lone argument.


\paragraph{tags}
Tags are a means to assign a name to characters within the text buffer. Tags may be used to adjust the 
foreground, background and font properties of the tagged characters from those specified globally at the time of construction of the widget, or configured thereafter. Tags can be set when the text is inserted, as with
<<>>=
tkinsert(t, "end", "last words", "lastWords") # lastWords is tag
@ 

Tags can be set after the text is added through the
\subcommand{tag add}{tktext} subcommand using indices to specify
location. The following marks the first word:
<<>>=
tktag.add(t,"firstWord","1.0 wordstart", "1.0 wordend")
@ 
The \subcommand{tag configure}{tktext} can be used to configure properties of the tagged characters, for example:
<<>>=
tktag.configure(t, "firstWord", foreground="red", 
                font="helvetica 12 bold")
@ There are several other configuration options for a tag. From within
an \R\/ session, a cryptic list can be produced by calling the
subcommand \subcommand{tag configure}{tktext} without a value for
configuration.


\paragraph{selection}
The current selection, if any, is indicated by the \code{sel} tag,
with \code{sel.first} and \code{sel.last} providing indices to refer
to the selection. (Provided the option \code{exportSelection} was not
modified.) These tags can be used with \code{tkget} to retrieve the
currently selected text. An error will be thrown if there is no
current selection. To check if there is a current selection, the following may be used:
<<>>=
hasSelection <- function(W) {
  ranges <- tclvalue(tcl(W, "tag", "ranges", "sel"))
  length(ranges) > 1 || ranges != ""
}
@ 

The cut, copy and paste commands are implemented through the \Tk\/ functions
\code{tk\_textCut}, \code{tk\_textCopy} and
\code{tk\_textPaste}. Their lone argument is the text widget. These
work with the current selection and insert point. For example to cut
the current selection, one has
<<cutSelection>>=
tcl("tk_textCut", t)
@ 

\paragraph{marks}
Tags mark characters within a buffer, marks denote positions within a
buffer that can be modified. For example, the marks \code{insert} and
\code{current} refer to the position of the cursor and the current
position of the mouse. Such information can be used to provide
context-sensitive popup menus, as in this code example:
<<>>=
popupContext <- function(W, x, y) {
  ## or use sprintf("@%s,$s", x, y) for "current"
  cur <- tkget(W,"current  wordstart", "current wordend") 
  cur <- tclvalue(cur)
  popupContextMenuFor(cur, x, y)        # some function
}
@ 

To assign a new mark, one uses the \subcommand{mark set}{tktext}
subcommand specifying a name and a position through an index. Marks
refer to spaces within characters. The \code{gravity} of the mark can
be \code{left} or \code{right}. When \code{right} (the default), new
text inserted is to the left of the mark. For instance, to keep track
of an initial insert point and the current one, the initial point
(marked \code{leftlimit} below) can be marked with
<<>>=
tkmark.set(t,"leftlimit","insert")
tkmark.gravity(t,"leftlimit","left")    # keep onleft
tkinsert(t,"insert","new text")
tkget(t, "leftlimit", "insert")
@ 
%
The use of the subcommand \subcommand{mark gravity}{tktext} is done so
that the mark attaches to the left-most character at the insert
point. The rightmost one changes as more text is inserted, so would
make a poor choice.


\paragraph{The edit command}
The subcommand \subcommand{edit}{tktext} can be used to undo text. As well, it can be used to test if the buffer has been modified, as follows:
<<>>=
tcl(t, "edit", "undo")                  # no output
tcl(t, "edit", "modified")              # 1 = TRUE
@ 



\paragraph{Events}
The text widget has a few important events.  The widget defines
virtual events \code{\VirtualEvent{Modified}} and
\code{\VirtualEvent{Selection}} indicating when the buffer is modified
or the selection is changed. Like the single-line text widget, the
events \code{\Event{KeyPress}} and \code{\Event{KeyRelease}} indicate
key activity. The \%-substitution \code{k} gives the keycode and
\code{K} the key symbol as a string (\code{N} is the decimal number).



\begin{example}{Displaying commands in a text buffer}{ex-tcltk-text}
  \SweaveInput{ex-tcltk-text.Rnw}
\end{example}


\section{Treeview widget}
\label{sec:tcltk:treeview-widget}

The themed treeview widget can be used to display rectangular data,
like a data frame, or hierarchical data. The usage is similar for each
beyond the need to indicate the hierarchical structure of a tree.

\subsection{Rectangular data}

\XXX{Images -- add comment}

%% constructor
The \constructor{ttktreeview} constructor creates the tree
widget. There is no separate model for this widget, but there is a
means to adjust what is displayed.  The argument
\argument{columns}{ttktreeview} is used to specify internal names for
the columns and indicate the number of columns. A value of \code{1:n}
will work here unless explicit names are desired. The argument
\argument{displaycolunms}{ttktreeview} is used to control which of the
columns are actually displayed. The default is \qcode{all}, but a
vector of indices or names can be given.  The size of the widget is
specified two different ways.  The \argument{height}{ttktreeview}
argument is used to adjust the number of visible rows. The width of
the widget is determined by the combined widths of each column, whose
adjustments are mentioned later.


<<treeExample,echo=FALSE>>=
w <- tktoplevel()
tkwm.title(w, "Choose CRAN mirror")
f <- ttkframe(w, padding=c(3,3,3,12))
tkpack(f, expand=TRUE, fill="both")
@ 

If \code{f} is a frame, then the following call will create a widget
with just one column showing 25 rows, like the older, non-themed,
listbox widget of \Tk.

<<>>=
tr <- ttktreeview(f, 
                  columns=1,            # column identifier is "1"
                  show="headings",      # not "#0"
                  height=25)            
addScrollbars(f, tr)                    # scrollbar function
@ 



The treeview widget has an initial column for showing the tree-like
aspect with the data. This column is referenced by \code{\#0}. The
\argument{show}{ttktreeview} argument controls whether this column is
shown. A value of \qcode{tree} leaves just this column shown,
\qcode{headings} will show the other columns, but not the first, and
the combined value of \qcode{tree headings} will display both (the
default).  Additionally, the treeview is a scrollable widget, so has
the arguments \argument{xscrollcommand}{ttktreeview} and
\argument{yscrollcommand}{ttktreeview} for specifying scrollbars.

\paragraph{Adding values}

Rectangular data has a row and column structure. In \R, data frames
are internally stored by column vectors, so each column may have its
own type. The treeview widget is different, it stores all data as
character data and one interacts with the data row by row.

Values can be added to the widget through the
\subcommanda{insert}{ttktreeview}{parent item [text] [values]}
subcommand. This requires the specification of a parent (always
\qcode{} for rectangular data) and an index for specifying the
location of the new child amongst the previous children. The special
value \qcode{end} indicates placement after all other children, as
would a number larger than the number of children. A value of 0 or a
negative value would put it at the beginning.


In the example this is how we can add a list of possible CRAN mirrors
to the treeview display.
<<getCRANmirrors>>=
x <- getCRANmirrors()
Host <- x$Host
shade <- c("none", "gray")              # tag names
for(i in 1:length(Host))
  ID <- tkinsert(tr, "", "end", values=as.tclObj(Host[i]),
                 tag=shade[i %% 2])              # none or gray
tktag.configure(tr, "gray", background="gray95") # shade rows
@ 

For filling in the columns content the \code{values} option is
used. If there is a single column, like the current example, care
needs to be taken when adding a value. The call to
\function{as.tclObj} prevents the widget from dropping values after
the first space.


There are a number of other options for each row. If column \code{\#0}
is present, the \code{text} option is used to specify the text for the
tree row and the option \code{image} can be given to specify an image
to place to the left of the text value. Finally, we mention that
\code{tag} option for \code{insert} that can be used to specify a tag
for the inserted row. This allows the use of the subcommand
\subcommand{tag configure}{ttktreeview} to configure the foreground
color, background color, font or image of an item.



\paragraph{Column properties}
%% column properties: heading, width, minwidth, stretch
The columns can be configured on a per-column basis. Columns can be
referred to by the name specified through the \code{columns} argument
or by number starting at 1 with \qcode{\#0} referring to the tree
column. The column headings can be set through the
\subcommand{heading}{ttktreeview} subcommand. The heading, similar to
the button widget, can be text, an image or both. The text placement
of the heading may be positioned through the \code{anchor} option. For
example, this command will center the text heading of the first
column:
<<>>=
tcl(tr, "heading", 1, text="Host", anchor="center")
@ 

The \subcommand{column}{ttktreeview} subcommand can be used to adjust
a column's properties including the size of the column. The option
\code{width} is used to specify the pixel width of the column (the
default is large); As the widget may be resized, one can specify the
minimum column width through the option \code{minwidth}. When more
space is allocated to the tree widget, than is requested by the
columns, column with a \code{TRUE} value specified to the option
\code{stretch} are resized to fill the available space. Within each
column, the placement of each entry within a cell is controlled by the
\code{anchor} option, using the compass points.

For example, this command will adjust properties of the lone column of \code{tr}:
<<>>=
tcl(tr, "column", 1, width=400,  stretch=TRUE, anchor="w")
@ 

\paragraph{Item IDs}
%% referring to rows ID
Each row has a unique item ID generated by the widget when a row is
added. The base ID is \qcode{} (why this is specified for the value of
\code{parent} for rectangular data). For rectangular displays, the
list of all IDs may be found through the \subcommand{children}{ttktreeview}
sub command, which we will describe in the next section.  Here we see
it used to find the children of the root. As well, we show how the
\subcommand{index}{ttktreeview} command returns the row index.
<<showChildrenIndex>>=
children <- tcl(tr, "children", "")
(children <- head(as.character(children)))     # as.character
sapply(children, function(i) tclvalue(tkindex(tr, i)))
@ 

%% retrieving values
\paragraph{Retrieving values}
The \subcommand{item}{ttktreeview} subcommand can be used to get the
values and other properties stored for each row. One specifies the item and the
corresponding option:
<<getValue>>=
x <- tcl(tr, "item", children[1], "-values") # no tkitem
as.character(x)
@ 
%
The value returned from the \code{item} command can be difficult to
parse, as \TCL\/ places braces around values with blank spaces. The coercion through
\code{as.character} works much better at extracting the individual
columns. A possible alternative to using the \code{item} command, is
to instead keep the original data frame and use the index of the item
to extract the value from the original.

%% deleting values
\paragraph{Moving and deleting items}
The \subcommand{move}{ttktreeview} subcommand can be used to replace a
child. As with the \code{insert} command, a parent and an index for
where the new child is to go among the existing children is given. The
item to be moved is referred to by its ID. The
\subcommand{delete}{ttktreeview} and \subcommand{detach}{ttktreeview}
can be used to remove an item from the display, as specified by its
ID. The latter command allows for the item to be reinserted at a later
time.


\paragraph{Selection}
The user may select one or more rows with the mouse, as controlled by
the option \argument{selectmode}{ttktreeview}. Multiple rows may be
selected with the default value of \qcode{extended}, a restriction to
a single row is specified with \qcode{browse}, and no selection is
possible if this is given as \code{none}.

%% getting the selection
The \subcommand{select}{ttktreeview} command will return the current
selection. The current selection marks 0, 1 or more than 1 items if
\qcode{extended} is given for the \code{selectmode} argument.  If
converted to a string using \code{as.character} this will be a
character vector of the selected item IDs. Further subcommands
\code{set}, \code{add}, \code{remove}, and \code{toggle} can be used
to adjust the selection programatically.

For example, to select the first 6 children, we have:
<<>>=
tkselect(tr, "set", children)
@ 
%
To toggle the selection, we have:
<<>>=
tkselect(tr, "toggle", tcl(tr, "children", ""))
@ 
%
Finally, the selected IDs are returned with:
<<>>=
IDs <- as.character(tkselect(tr))
@ 

%% Events; handlers.
\paragraph{Events and callbacks}
In addition to the keyboard events \code{\Event{KeyPress}} and
\code{\Event{KeyRelease}} and the mouse events \code{\Event{ButtonPress}},
\code{\Event{ButtonRelease}} and \code{\Event{Motion}}, the virtual event
\code{\VirtualEvent{TreeviewSelect}} is generated when the selection changes.

Within a key or mouse event callback, the clicked on column and row can
be identified by position, as illustrated in this example callback.
<<>>=
callbackExample <- function(W, x, y) {
  col <- as.character(tkidentify(W, "column", x, y))
  row <- as.character(tkidentify(W, "row", x, y))
  ## now do something ...
}
@ 


%% example: filter through data -- table
\begin{example}{Filtering a table}{ex-tcltk-table}
  \SweaveInput{ex-tcltk-table.Rnw}
\end{example}


%% Comment on tktable XXX Do I want more XXX
\paragraph{Editing cells of a table}
There is no native widget for editing the cells of tabular data, as is
provided by the \function{edit} method for data frames. The
\code{tktable} widget (\url{http://tktable.sourceforge.net/}) provides
such an add-on to the base \TK. We don't illustrate its usage here, as
we keep to the core set of functions provided by \TK.  An interface
for this \TCL\/ package is provided in the \pkg{tcltk2} package
(\function{tk2edit}).  The \code{gdf} function of \pkg{gWidgetstcltk}
is based on this.



\subsection{Hierarchical data}

Specifying tree-like or hierarchical data is nearly identical to
specifying rectangular data for the \code{ttktreeview} widget.  The
widget provides column \code{\#0} to display this extra structure. If
an item, except the root, has children, a trigger icon to expand the
tree is shown. This is in addition to any text and/or an icon that is
specified. Children are displayed in an indented manner to indicate
the level of ancestry they have relative to the root.  To insert
hierarchical data in to the widget the same
\subcommand{insert}{ttktreeview} subcommand is used, only instead of
using the root item, \qcode{}, as the parent item, one uses the item
ID corresponding to the desired parent. If the option \code{open=TRUE}
is specified to the \code{insert} subcommand, the children of the item
will appear, if \code{FALSE}, the user can click the trigger icon to
see the children. The programmer can use the
\subcommand{item}{ttktreeview} to configure this state. When the
parent item is opened or closed, the virtual events
\VirtualEvent{TreeviewOpen} and \VirtualEvent{TreeviewClose} will be
signaled.

%% example?
%% tcl(tr, "insert","I001","end", text="child", open=FALSE)
%% tcl(tr, item, "I001", open=TRUE)

%% traversal 

\paragraph{Traversal}
Once a tree is constructed, the programmer can traverse
through the items using the subcommands
\subcommanda{parent}{ttktreeview}{item} to get the ID for the parent of the
item; \subcommanda{prev}{ttktreeview}{item} and
\subcommanda{next}{ttktreeview}{item} to get the immediate siblings of the
item; and \subcommanda{children}{ttktreeview}{item} to return the children of
the item. Again, the latter one will produce a character vector of  IDs for the
children when coerced to character with \code{as.character}.



%% tree example using XML
\begin{example}{Using the treeview widget to show an XML file}{ex-tcltk-tree}
  \SweaveInput{ex-tcltk-tree.Rnw}
\end{example}



\section{Menus}
\label{sec:tcltk:menus}

Menu bars and popup menus in \Tk\/ are constructed with
\constructor{tkmenu}. The \code{parent} argument depends on what the menu is
to do. A toplevel menu bar, such as appears at the top of a window has
a toplevel window as its parent; a submenu of a menu bar uses the
parent menu; and a popup menu uses a widget.  The menu widget in \Tk\/
has an option to be ``torn off.'' This features was at one time common
in GUIs, but now is rarely seen so it is recommended that this option
be disabled. The \argument{tearoff}{tkmenu} option can be used at
construction time to override the default behavior. Otherwise, the
following command will do so globally:
<<tearoff>>=
tcl("option","add","*tearOff", 0)       # disable tearoff menus
@ 

A toplevel menu bar is attached to a top-level window using \code{tkconfigure}
to set the \code{menu} option of the window. For the aqua \TK\/
libraries for Mac OS X, this menu will appear on the top menu bar when
the window has the focus. For other operating systems, it appears at
the top of the window. For Mac OS X, a default menu bar with no
relationship to your application will be shown if a menu is not
provided for a toplevel window. Testing for native Mac OS X may be done via
the following function:
<<testIfMac>>=
usingMac <- function()  
  as.character(tcl("tk", "windowingsystem")) == "aqua"
@ 

The \function{tkpopup} function facilitates the creation of a popup
menu.  This function has arguments for the menu bar, and the postion
where the menu should be popped up. For example, the following code
will bind a popup menu, \code{pmb} (yet to be defined), to the right click event for a
button \code{b}. As \OSX\/ may not have a third mouse button, and when
it does it refers to it differently, the callback is bound
conditionally to different events.

<<echo=FALSE>>=
w <- tktoplevel()
tkwm.title(w, "Popup menu example")
f <- ttkframe(w, padding=c(3,3,3,12))
tkpack(f, expand=TRUE, fill="both")

b <- ttkbutton(f, text="Click me for popup")
@ 

<<>>=
doPopup <- function(X, Y) tkpopup(pmb, X, Y) # define call back
if (usingMac()) {
  tkbind(b, "<Button-2>", doPopup)      # right click
  tkbind(b, "<Control-1>", doPopup)     # Control + click
} else {
  tkbind(b, "<Button-3>", doPopup)
}
@ 


\paragraph{Adding submenus and action items}
Menus show a hierarchical view of action items. Items are added to a
menu through the \subcommand{add}{tkmenu} subcommand.  The nested
structure of menus is achieved by specifying a \code{tkmenu} object as
an item. The \subcommand{add cascade}{tkmenu} subcommand is used for
this. The option \code{label} is used to label the menu and the
\code{menu} option to specify the sub-menu.

Grouping of similar items can be done through nesting, or on occasion
through visual separation. The latter is implemented with the \subcommand{add
  separator}{tkmenu} subcommand.


There are a few different types of action items that can be added:
 
\begin{description}
\item[Commands] 
An action item is one associated with a command. The simplest case is
a label in the menu that activates a command when selected through the
mouse. The \subcommand{add command}{tkmenu} (through
\code{tkadd(widget, "command", ...)}) allows one to specify a
\code{label}, a \code{command} and optionally an \code{image} with a
value for \code{compound} to adjust its layout. (Images are not shown
in Mac OS X.) Action commands may possibly be called for different
widgets, so the use of percent substitution is discouraged here. One can also specify that a keyboard accelerator be displayed through the option \code{accelerator}, but a separate callback must listen for this combination.

\item[Check boxes] 
Action items may also be checkboxes. To create one, the subcommand
\subcommand{add checkbutton}{tkmenu} is used. The available
arguments include \code{label} to specify the text, \code{variable} to
specify a tcl variable to store the state, \code{onvalue} and
\code{offvalue} to specify the state to the tcl variable, and
\code{command} to specify a call back when the checked state is
toggled. The initial state is set by the value in the  \TCL\/ variable.

\item[Radio buttons] 
Additionally, action items may be radiobutton groups. These are
specified with the subcommand \subcommand{add
  radiobutton}{tkmenu}. The \code{label} option is used to identify
the entry, \code{variable} to set a text variable and to group the
buttons that are added, and \code{command} to specify a command when
that entry is selected.
\end{description}

Action items can also be placed after an item, rather than at the end
using the \subcommand{insert command index}{tkmenu} subcommand. The
index may be specified numerically with 0 being the first item for a
menu.  More conveniently the index can be determined by specifying a
pattern to match the menu's labels.


\paragraph{Set state}
The \code{state} option is used to retrieve and set the current state of the a menu item.
This value is typically \code{normal} or
\code{disabled}, the latter to indicate the item is not available. The
state can be set when the item is added or configured after that fact
through the \subcommand{entryconfigure}{tkmenu} command. This function
needs the menu bar specified and the item specified as an index or
pattern to match the labels.

\begin{example}{Simple menu example}{ex-tcltk-menu}
  \SweaveInput{ex-tcltk-menu.Rnw}
\end{example}

\section{Canvas Widget}
\label{sec:tcltk:canvas-widget}

 
The canvas widget provides an area to display lines, shapes, images
and widgets. Methods exist to create, move and delete these objects,
allowing the canvas widget to be the basis for creating interactive
GUIs. The constructor \constructor{tkcanvas} for the widget, being a
non-themeable widget, has many arguments including these standard ones:
\argument{width}{tkcanvas}, \argument{height}{tkcanvas}, and
\argument{background}{tkcanvas}, \argument{xscrollcommand}{tkcanvas}
and \argument{yscrollcommand}{tkcanvas}.


\paragraph{The create command}
The subcommand \subcommanda{create}{tkcanvas}{type [options]} is used
to add new items to the canvas. The options vary with the type of the
item. The basic shape types that one can add are \qcode{line},
\qcode{arc}, \qcode{polygon}, \qcode{rectangle}, and
\qcode{oval}. Their options specify the size using $x$ and $y$
coordinates. Other options allow one to specify colors, etc. The
complete list is covered in the \code{canvas} manual page, which we
refer the reader to, as the description is lengthy.  In the examples,
we show how to use the \qcode{line} type to display a graph and how to
use the \qcode{oval} type to add a point to a canvas. Additionally,
one can add text items through the \qcode{text} type. The first
options are the $x$ and $y$ coordinates and the \code{text} option
specifies the text.  Other standard text options are possible (e.g.,
\code{font}, \code{justify}, \code{anchor}).

The type can also be an image object or a widget (a window object). Images are added by specifying an $x$ and $y$ position, possibly an anchor position, and a value for the \qcode{image} option and optionally, for state dependent display, specifying \qcode{activeimage} and \qcode{disabledimage} values. The \qcode{state} option is used to specify the current state. Window objects are added similarly in terms of their positioning, along with options for \qcode{width} and \qcode{height}. The window itself is added through the \qcode{window} option. An example shows how to add a frame widget.

Once created, a screenshot of the canvas can be created through the \subcommand{postscript}{tkcanvas} subcommand, as in \code{tcl(canvas, "postscript", file="filename")}. To store the widget so that it can be recreated is not supported directly. \TCL\/ code to do so can be found at \url{http://wiki.tcl.tk/9168}.


\paragraph{Items and tags}
The \code{tkcanvas.create} function returns an item ID. This can be
used to refer to the item at a later stage. Optionally, tags can be
used to group items into common groups. The \qcode{tags} option can be
used with \code{tkcreate} when the item is created, or the
\subcommand{addtag}{tkcanvas} subcommand can be used. The call
\code{tkaddtag(canvas, tagName, "withtag", item)} would add the tag ``\code{tagName}''to
the \code{item} returned by \code{tkcreate}. (The \qcode{withtag} is
one of several search specifications.) As well, if one is
adding a tag through a mouse click, the call \code{tkaddtag(W,
  "tagName", "closest", x, y)} could be used with \code{W}, \code{x}
and \code{y} coming from percent substitutions. Tags can be deleted
through the \subcommanda{dtag}{tkcanvas}{tag} subcommand.

%% interaction with items
There are several subcommands that can be called on items as specified
by a tag or item ID. For example, the \subcommand{itemcget}{tkcanvas}
and \subcommand{itemconfigure}{tkcanvas} subcommands allow one to get
and set options for a given item. The
\subcommanda{delete}{tkcanvas}{tag\_or\_ID} subcommand can be used to
delete an item. Items can be moved and scaled but not rotated. The
\subcommanda{move}{tkcanvas}{tag\_or\_ID x y} subcommand implements
incremental moves (where $x$ and $y$ specify the horizontal and
vertical shift in pixels). The subcommand
\subcommanda{coords}{tkcanvas}{ tag\_or\_ID [coordinates]} allows one
to respecify the coordinates for the item. The
\subcommand{scale}{tkcanvas} is used to rescale items. Except for
window objects, an item can be raised to be on top of the others
through the \subcommanda{raise}{tkcanvas}{item\_or\_ID} subcommand.



\paragraph{Bindings}
Bindings can be specified overall for the canvas, as usual, through
\code{tkbind}. However, bindings can also be set on specific items
through the subcommand \subcommanda{bind}{tkcanvas}{tag\_or\_ID event
  function} which is aliased to \code{tkitembind}. This allows
bindings to be placed on items sharing a tag name, without having the
binding on all items. Only mouse, keyboard or virtual events can have
such bindings.

%% do with fonts now
\begin{example}{Using a canvas to make a scrollable frame}{ex:tcltk-scrollable-frame}
  \SweaveInput{ex-tcltk-scrollable-frame.Rnw}
\end{example}

%% example with lines objects
\begin{example}{Using canvas objects to show sparklines}{ex-tcltk-sparklines}
    \SweaveInput{ex-tcltk-sparklines.Rnw}
\end{example}

%% Moving an object
\begin{example}{Capturing mouse movements}{ex-tcltk-canvas}
  \SweaveInput{ex-tcltk-canvas.Rnw}
\end{example}

