\XXX{Where to put loading in external TCL source, packages, ...}
\XXX{tcl("update","idletasks")}
\XXX{use svMisc -- atleast comment on Parse, Complete, CompletePlus}



\TCL\/ (``tool command language'') is a scripting language and
interpreter of that language.  Originally developed in the late 80s by
John Ousterhout as a ``glue'' to combine two or more complicated
applications together, it evolved overtime to find use not just as
middleware, but also as a standalone development tool.

\TK{} is an extension of \TCL\/ that provides GUI components through \TCL.
This was first developed in 1990, again by John Ousterhout. \TK\/
quickly found widespread usage, as, at the time, it made programming GUIs for X11
easier and faster. Over the years, other graphical toolkits have
evolved and surpassed this one, but \TK\/ still has numerous users.

\TK\/ has a large number of bindings available for it,
e.g. \proglang{Perl}, \proglang{Python}, \proglang{Ruby}, and through
the \pkg{tcltk} package, \R. The \pkg{tcltk} package was developed by
Peter Dalgaard and has been included in \R\/ since version 1.1.0. Since then,
the package has been used in a number of GUI projects for \R, most
notably, the \pkg{Rcmdr} GUI. In addition, the \pkg{tcltk2} package
provides additional bindings and bundles in some useful external TCL
code. Our focus here is limited to the base \pkg{tcltk} package.

\TK\/ had a major change between versions 8.4 and 8.5, with the latter
introducing themed widgets. Many widgets were rewritten and their API
dramatically simplified. In \pkg{tcltk} there can be two different
functions to construct a similar widget. For example,
\function{tklabel} or \function{ttklabel}. The latter, with the
\code{ttk} prefix, corresponds to the newer themed variant of the
widget. We assume the \TK\/ version is 8.5 or higher, as this was a
major step forward.\footnote{In fact, we assume version 8.5.8 which
  was the release accompanying \R{} for Windows version 2.13.1.}

Despite its limitations as a graphical toolkit, as compared to \GTK\/
or \Qt, the \TK\/ libraries are widely used for \R\/ GUIs, as for most
users there are no installation issues. \R\/ for Windows has been
bundled with the necessary \TK\/ version for years, so there are no
installation issues for that platform. For Linux users, it is
typically trivial to install the newer libraries and for Mac OS X
users, the provided binary installations include the newer \TK\/
libraries.

%% Documentation sources
\Tk{} has a well documented API\footcite{TclTk:Api}
(\url{www.tcl.tk/man/tcl8.5}).  There are also several books to
supplement. We consulted the one by Welch, Jones and
Hobbs\footcite{beedub} often in the development of this
material. The online sample chapter on geometry management
of Walsh\footcite{Walsh} was perused, as it provides a thorough discussion
of that topic. In addition, the Tk Tutorial of Mark
Roseman\footcite{TclTk:Tutorial} (\url{www.tkdocs.com/tutorial})
provides much detail. \R{} specific documentation include two
excellent R News articles and a proceedings
paper\footcite{Rnews:Dalgaard:2001a}\footcite{Rnews:Dalgaard:2002}\footcite{Dalgaard-DSC}
by Peter Dalgaard, the package author. A
set of examples due to James Wettenhall\footcite{Wettenhall} are also
quite instructive. A main use of \pkg{tcltk} is within the \pkg{Rcmdr}
framework. Writing extensions for that is well documented in an R News
article\footcite{Rnews:Fox:2007} by John Fox, the package author.
 

\section{A first example}
\label{sec:first-example}

In this chapter we give an overview of \Tk\/ and \R's interface to it
through the \pkg{tcltk} package using the following small example of a
dialog to collect a name and echo back a message
(Figure~\ref{fig:tcltk-simple-dialog}). In subsequent chapters we give
more detail on the various widgets provided by \Tk.

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-tcltk-themed-dialog.png}
  \caption{A simple dialog to collect a name for later use
    illustrating three basic widgets: a label, entry widget and
    button.}
  \label{fig:tcltk-simple-dialog}
\end{figure}


<<simpleExample>>=
library(tcltk)
##
window <- tktoplevel()
tkwm.title(window, "Simple dialog")
##
frame <- ttkframe(window, padding = c(3,3,12,12))
tkpack(frame, expand = TRUE, fill = "both")
##
nested_frame <- ttkframe(frame); tkpack(nested_frame)
##
label <- ttklabel(nested_frame, text = "Enter your name:")
tkpack(label, side = "left")
##
text_var <- tclVar("")
entry <- ttkentry(nested_frame, textvariable = text_var)
tkpack(entry)
##
button_frame <- ttkframe(frame)
tkpack(button_frame, anchor = "ne")
button <- ttkbutton(button_frame, text = "Click")
tkpack(button, side = "right")
##
msg <- sprintf("Hello %s", tclvalue(text_var))
handler <- function() print(msg)
tkconfigure(button, command = handler)
@ 
%%
In the above, the first block defines a top-level window and the
second an underlying frame container. We then define and place three
widgets -- a label, entry widget and button -- into a frame. Finally,
we add a callback to respond when the button is clicked.


\section{Interacting with \TCL}
\label{sec:tcltk:interacting-with-tcl}

As the example above makes clear, using \pkg{tcltk} does not
necessarily require knowing anything about the underlying \Tk{} or
\Tcl{} workings, though it can be useful to have a rough sense of these
technologies and how \pkg{tcltk} interfaces with them. As such, we
give a quick overview.


%% Tclk
Although both are scripting languages, the basic syntax of \TCL\/ is
unlike \R. For example a simple string assignment would be made at
tclsh, the \TCL\/ shell with (using \code{\%} as a prompt):
\begin{verbatim}
% set x {hello world}
hello world
\end{verbatim}
Unlike \R\/ where braces are used to form blocks, this example shows
how \TCL\/ uses braces instead of quotes to group the words as a
single string. The use of braces, instead of quotes, in this example
is optional, but in general isn't, as expressions within braces are
not evaluated.  

The example above assigns to the variable \code{x} the
value of \code{hello world}. Once assignment has been made, one can
call commands on the value stored in \code{x} using the \code{\$}
prefix:
\begin{verbatim}
% puts $x
hello world
\end{verbatim}
The \code{puts} command, in this usage, simply writes back its argument to the terminal. Had
we used braces the argument would not have been substituted:
\begin{verbatim}
% puts {$x}
$x
\end{verbatim}

More typical within the \pkg{tcltk} package is the idea of a subcommand. For
example, the \code{string} command provides the subcommand
\code{length} to return the number of characters in the string.
\begin{verbatim}
% string length $x
11
\end{verbatim}

%% .Tcl
The \pkg{tcltk} package provides the low-level function \function{.Tcl} for direct
access to the \TCL\/ interpreter:
<<>>=
library(tcltk)
.Tcl("set x {some text}")               # assignment
.Tcl("puts $x")                         # prints to stdout
@ 

%% must hard code this, as output isn't printed
\begin{Soutput}
some text
\end{Soutput}

<<>>=
.Tcl("string length $x")                # call a command
@ 

The \dfn{\function{.Tcl}} function simply sends a command as a text
string to the \TCL\/ interpreter and returns the result as an object
of class \dfn{\class{tclObj}} (cf. \code{?.Tcl}).  The \function{.Tcl}
function can be used to read in \TCL\/ scripts as with
\code{.Tcl("source filename")}. This allows arbitrary \TCL\/ scripts
to run within an \R\/ session. \TCL\/ packages may be read in with
\function{tclRequire}.\footnote{The add-on package \pkg{tcltk2} uses
  both techniques to enhance the base \pkg{tcltk} package with some
  open-source \Tk\/ extensions.}


\paragraph{The \class{tclObj} class}
The \pkg{tcltk} package creates objects with a few different classes,
\iprogram{class structure}\class{tclObj} being the primary one (\class{tclVar} and \class{tkwin}
are two other important ones).  The \class{tclObj} objects print with
the leading \code{<Tcl>}. The string representation of objects of
class \class{tclObj} is returned by \function{tclvalue} or by coercion
through the \function{as.character} function. These two differ in how
they treat spaces and new lines.  Conversion to vectors of mode
\class{character}, \class{double}, \class{integer} and \class{logical}
is possible, though, in general, direct conversion of complicated
\TCL\/ expressions is not supported. One can create objects of this
class through \function{as.tclObj}.


<<echo=FALSE>>=
## To simplify coercion to logical, we define a new method:
as.logical.tclObj <- function(x, ...) as.logical(as.numeric(x))
@ 

\paragraph{Convenience functions}
The \TK\/ extensions to \TCL\/ have a complicated command structure,
and thankfully, \pkg{tcltk} provides some more conveniently named
functions. To illustrate, the \TCL\/ command to configure the text property for
a label object (\code{.label}) would look like
\begin{verbatim}
% .label configure -text "new text"
\end{verbatim}
The \pkg{tcltk} package provides a corresponding function
\code{tkconfigure}. The above would be done in an \R-like way as (assuming \code{lab} is a
label object):

<<echo=FALSE>>=
## set up label for Sweave below. Not shown
window <- tktoplevel()
label <- ttklabel(window)
tkpack(label)
@ 

<<>>=
tkconfigure(label, text = "new text")
@ 


% Although the \TCL\/ statement appears to have the object-oriented form
% of ``object method arguments,'' behind the scenes \TCL\/ creates a
% command with the same name as the widget with \code{configure} as a
% subcommand. This is followed by options passed in using the form
% \texttt{-key value}.  


The \TK\/ API for \code{ttklabel}'s \code{configure} subcommand is

\begin{quotation}
  \textit{pathName} \textbf{configure} \textit{?option? ?value option value ...?}
\end{quotation}

The \textit{pathName} is the ID of the label widget. This can be found
from the object \code{l} above, in \code{l\$ID}, or in some cases is a
return value of some other command call.  In the \TK\/ documentation
paired question marks indicate optional values. In this case, one can
specify nothing, returning a list of all options; just an option, to
query the configured value; the option with a value, to modify the
option; and possibly do more than one at at time.  For commands such
as \code{configure}, there will usually correspond a function in
\R\/ of the same name with a \code{tk} prefix, as in this case
\function{tkconfigure}.
% \footnote{The package \pkg{tcltk} was written before
% namespaces were implemented in \R, so the ``tk'' prefix serves that role.}

To make consulting the \TK\/ manual pages easier in the text we would
describe the configure subcommand as
\subcommanda{configure}{ttklabel}{[options]}. (The \R\/ manual pages
simply redirect you to the original \TK\/ documentation, so
understanding this is important for reading the API.) However, if such
a function shortcut is present, we will typically use the shortcut when we
illustrate code. 

Some subcommands have further subcommands. An example
is to set the selection. In the \R\/ function, the second command is
appended with a dot, as in \code{tkselection.set}. (There are a few
necessary exceptions to this.)

\paragraph{The \class{tcl} function} 
Within \pkg{tcltk}, the \function{tkconfigure} function is defined by

\begin{Sinput}
function(widget, ...) tcl(widget, "configure", ...)
\end{Sinput}

The \dfn{\function{tcl}} function is the workhorse used to piece
together \TCL\/ commands, call the interpreter, and then return an
object of class \code{tclObj}.  Behind the scenes it
\begin{itemize}
\item Turns an \R\/
object, \code{widget}, into the \textit{pathName} above (using its ID
component);
\item It passes along strings as subcommands (\code{configure});
\item It converts \R\/ \code{key=value} pairs into \code{-key value}
  options for \TCL. As named arguments are only for the \code{-key
    value} expansion, we follow the \TCL\/ language and call the
  arguments ``options'' in the following. Finally,
\item It adjusts any callback functions allowing \R{} functions and
  expressions to be called.
\end{itemize}
The \function{tcl} function uses position to create its command. The
order of the subcommands needs to match that of the \TK\/ API, so
although it is true that often the \R\/ object is first, this is not
always the case.

\begin{figure}
  \centering
\begin{verbatim}
          tcl(widget, subcommand, key = value, callback)
             /            |           |           \
          widget$ID  subcommand   -key value   makeCallback
\end{verbatim}
  \caption{How the \code{tcl} function maps its arguments}
  \label{fig:tcl-function-map}
\end{figure}






%% constructors

\section{Constructors}
\label{sec:tcltk:constructors}

In this chapter, we will stick to a few basic widgets: labels, entry
widgets, and buttons; to illustrate the  usage of \pkg{tcltk},
leaving for later more detail on containers and widgets.

Unlike \GTK, say, the construction of widgets in \pkg{tcltk} is linked
to the widget hierarchy. \TK\/ widgets are constructed as children of
a parent object with the parent specified to the constructor. When
the \TK\/ shell, wish, is used or the \TK\/ package is loaded through
the \TCL\/ command \code{package require Tk}, a top level window named
``\code{.}'' is created. (This is \code{.TkRoot} in \R.) In the variable name \code{.label}, from
above, the dot refers to the top level window.  In \pkg{tcltk} a
top-level window is created separately through the
\constructor{tktoplevel} constructor, as was done in the example:
<<eval>>=
window <- tktoplevel()
@ 

Top-level windows will be explained in more detail in
Chapter~\ref{sec:tcltk:basic-containers}. 

Other widget constructors require that a parent widget be
specified as the first argument of the constructor.  A typical
invocation was given in the example.
<<>>=
label <- ttklabel(nested_frame, text = "Enter your name:")
@ 
%

\paragraph{Options}
The first argument of a widget constructor is the parent container,
subsequent arguments are used to specify the options for the
constructor given as \code{key=value} pairs. The \TK\/ API lists these
options along with their description.

For a simple label, the following options are possible: \code{anchor},
\code{background}, \code{font}, \code{foreground}, \code{justify},
\code{padding}, \code{relief}, \code{text}, and \code{wraplength}.
This is in addition to the standard options \code{class},
\code{compound}, \code{cursor}, \code{image}, \code{state},
\code{style}, \code{takefocus}, \code{text}, \code{textvariable},
\code{underline}, and \code{width}. (Although clearly lengthy, this
list is significantly reduced from the options for \code{tklabel}
where options for the many style properties are also included.)

Many of the options are clear from their name.  The main option,
\code{text}, takes a character string. The label will be multiline if
this contains new line characters.  The \argument{padding}{ttklabel}
argument allows the specification of space in pixels between the text
of the label and the widget boundary. This may be set as four values
\code{c(left, top, right, bottom)}, or fewer, with \code{bottom}
defaulting to \code{top}, \code{right} to \code{left} and \code{top}
to \code{left}. The \argument{relief}{ttklabel} argument specifies how
a 3-d effect around the label should look, if specified. Possible
values are \qcode{flat}, \qcode{groove}, \qcode{raised},
\qcode{ridge}, \qcode{solid}, or \qcode{sunken}.

\paragraph{The functions \class{tkconfigure}, \class{tkcget}}
Option values may be set through the constructor, or adjusted
afterwards by \function{tkconfigure}. A listing (in \TCL\/ code) of possible options
that can be adjusted may be seen by calling \function{tkconfigure}
with just the widget as an argument.

<<>>=
head(as.character(tkconfigure(label)))      # first 6 only
@ 

The \function{tkcget} function returns the value of an
option (again as a \code{tclObj} object). The option can be specified
two different ways. Either using the \TK\/ style of a leading dash or
using the \R{} convention that \code{NULL} values mean to return the value,
and not set it.


<<>>=
tkcget(label, "-text")               # retrieve text property
tkcget(label, text = NULL)           # alternate syntax
@ 

\paragraph{Coercion to character}
As mentioned, the \code{tclObj} objects can be coerced to characters in two ways.
The conversion through \code{as.character} breaks the return value along whitespace:
<<>>=
as.character(tkcget(label, text = NULL))
@ 
%
Whereas, conversion by the \function{tclvalue} function does not:
<<>>=
tclvalue(tkcget(label, text = NULL))
@ 
%

\subsection{The \code{tkwidget} function}
\label{sec:codetkw-funct}


Constructors call the \function{tkwidget} function which returns an
object of class \code{tkwin}. (In \TK\/ the term ``window'' is used to
refer to the drawn widget and not just a top-level window). E.g.,

<<str>>=
str(button)
@ 

The returned widget objects are lists with two components: an ID and an
environment. The \code{ID} component keeps a unique ID of the
constructed widget. This is a character string, such as ``.1.2.1''
coming from the the widget hierarchy of the object. This value is
generated behind the scenes by the \pkg{tcltk} package using numeric
values to keep track of the hierarchy. The \code{env} component
contains an environment that keeps a count of the subwindows, the parent
window and any callback functions. This helps ensure that any copies
of the widget refer to the same object\footcite{Dalgaard-DSC}. As the
construction of a new widget requires the \code{ID} and environment of
its parent, the first argument to \function{tkwidget} (and hence any constructor), \code{parent},
must be a \class{tkwin} object, not simply its character ID, as is
possible for the \function{tcl} function.

%%The latter is useful in
%%a callback, as only the ID may be known to the callback function.

\subsection{Geometry managers}
\label{sec:tcltk:overview:geometry-managers}

In the example we saw several calls to \code{tkpack}. For example,

<<eval=FALSE>>=
tkpack(frame, expand = TRUE, fill = "both")
tkpack(lable, side = "left")
tkpack(entry)
button_frame <- ttkframe(frame)
tkpack(button_frame, anchor = "ne")
@ 


As with \Qt, when a new widget is constructed it is not automatically
mapped. \TK\/ uses geometry managers to specify how the widget will be
drawn within the parent container. We will discuss two such geometry
managers, \code{tkpack} and \code{tkgrid}, in Chapter~\ref{sec:tcltk:basic-containers}.

The \code{tkpack} command packs the widgets into the parent container
in a box-like manner. The example shows various arguments that adjust
the position of the child component and how space is to be allocated
when an excess of space is present.



\subsection{\TCL\/ variables}
\label{sec:tcltk:overview:textvariables}


%% textvariables
For the button and label widgets in our example, their \code{text}
property is configured through calls to their constructors. Many
widgets allow an alternative way to specify one or two important
properties using an independent \Tcl\/ variable.

In the call to \code{ttkentry} in the example we had:

<<eval=FALSE>>=
text_var <- tclVar("")
entry <- ttkentry(g, textvariable = text_var)
@ 
%
The first line defines a new object of class \class{tclVar} which is
used for the \code{textvariable} option when defining the entry
widget. This variable is dynamically bound to the widget, so that
changes to the variable are propagated to the GUI. (The \TCL\/
variable is a model and the widget a view of the model.)  The \Tcl{}
variable may be used with more than one widget, allowing a simple form
of synchronization.

The basic functions involved are \function{tclVar} to create a \TCL\/
variable, \function{tclvalue} to get the assigned value and
\function{tclvalue\ASSIGN} to modify the value.

<<>>=
tclvalue(text_var) <- "Somebody's name"
tclvalue(text_var)
@ 

\TCL\/ variables have a unique identifier, returned by \function{as.character}:
<<>>=
as.character(text_var)
@ 

The advantages of \TCL\/ variables are like those of the MVC paradigm
-- a single data source can have its changes propagated to several
widgets automatically. If the same text is to appear in different
places, their usage is recommended.  One disadvantage, is that in a
callback, the variable is not passed to the callback and can't be
recovered from the object itself. Hence, it must be found
through \R's scoping rules. (In Section~\ref{sec:tcltk:checkboxes} we
show a workaround.)

The package also provides the function \dfn{\function{tclArray}} to
store an array of \TCL\/ variables. The usual list methods \code{[[}
and \code{\$} and their forms for assignment are available for arrays,
but values are only referred to by name, not index:

<<tclVarExample, echo=FALSE, eval=FALSE>>=
x <- tclVar(1)
print(x)                           # a tclVar object
tclvalue(x)                        # internal name
as.numeric(tclvalue(x))            # get value then coerce
@ 


<<tclArrayExample>>=
x <- tclArray()                    # no init
x$one <- 1; x[[2]] <- 2            # $<- and [[<-
x[[1]]                             # no match by index
names(x)                           # the stored names
x[['2']]                           # match by name, not index
@ 



\subsection{Commands}
\label{sec:tcltk-intro-commands}


In the definition of the button we saw:

<<>>=
button <- ttkbutton(button_frame, text = "Click")
#
msg <- sprintf("Hello %s", tclvalue(text_var))
handler <- function() print(msg)
tkconfigure(button, command = handler)
@ 

Button widgets are used to initiate  some action, or
command, and the \code{command} option is used to specify this. This
may be given as a function or expression, though we only illustrate
the former. The command is invoked by clicking and releasing the mouse
on the button, by pressing the space bar when the button has the focus
or by calling the widget's \subcommand{invoke}{ttkbutton}
subcommand. 

The \code{command} option is available for many widgets, but is not
the only means to invoke a function call, as \Tk{} also allows one to
bind to various types of events, e.g., button clicks.  More on
callbacks in \pkg{tcltk} will be explained in
Section~\ref{sec:tcltk:callbacks}.




\subsection{Themes}
\label{sec:tcltk:overview:themes}


%% themes -- ttkframe
As mentioned, the newer themed widgets have a style that determines
how they are drawn based on the state of the widget. The separation of
style properties from the widget, as opposed to having these set for
each construction of a widget, makes it much easier to change the look
of a GUI and easier to maintain the code. A collection of styles makes
up a theme. The available themes depend on the system. The default
theme allows the GUI to have the native look and feel of the operating
system. (This was definitely not the case for the older \TK\/
widgets.)

In our example, the toplevel window has a frame immediately packed
inside of it through the commands:
<<eval=FALSE>>=
window <- tktoplevel()
frame <- ttkframe(window, padding = c(3,3,12,12))
tkpack(frame, expand = TRUE, fill = "both")
@ 

\begin{figure}
  \centering
  \begin{minipage}[c]{.45\linewidth}
    \includegraphics[width=\textwidth]{fig-tcltk-themed-dialog.png}    
  \end{minipage}\quad
  \begin{minipage}[c]{.45\linewidth}
   \includegraphics[width=\textwidth]{fig-tcltk-non-themed-dialog.png}
 \end{minipage}
 \caption{Comparison of themed versus non-themed dialog. The right
    one does not use an inner \code{ttkframe} and in addition to not
    having padding, has a mismatched color.}
  \label{fig:tcltk-compare-themed-non-themed}
\end{figure}


The arguments to \code{tkpack} are given so that the frame, \code{frame},
will expand and fill all the space allocated by the toplevel
window. As the toplevel window is not a themed widget, not doing this
can leave odd-looking effects~\ref{fig:tcltk-compare-themed-non-themed}.

%% Workign with thems
There is no built in command to return the theme, so we use
\code{.Tcl} to call the appropriate \code{names}
sub command:

<<>>=
.Tcl("ttk::style theme names")
@ 
%
The \code{use} sub command is used to set the theme:
<<>>=
.Tcl("ttk::style theme use clam")
@ 

\paragraph{State of themed widgets}

The themed widgets (those with a \code{ttk} constructor) have a state
to determine which style is to be applied when painting the
widget. These states can be adjusted through the \code{state} command
and queried with the \code{instate} command. For example, to see if
button widget \code{b} has the focus we have:
<<has-focus>>=
as.logical(tcl(button, "instate", "focus"))
@ 
To set a widget to be not sensitive to user input we have:
<<>>=
tcl(button, "state", "disabled")             # not sensitive
@ 
The states are bits and can be negated by prefacing the value with \code{!}:
<<>>=
tcl(button, "state", "!disabled")            # sensitive again
@ 

The full list of states is in the manual page for \code{ttk::widget}.


The writing of themes will not be covered, but in
Example~\ref{ex-tcltk-toolbar} we show how to create a new style for a
button. This topic is covered in some detail in the \Tk\/ tutorial by Roseman.
\\

% The example we have shown so far, would not look quite right for some
% operating systems, as the toplevel window is not a themed widget
% (Figure~\ref{fig:tcltk-frame-noframe-example}). To work around that, a
% \function{ttkframe} widget is usually used to hold the child
% components of the top-level window. The following shows how to place a
% frame inside the window, with some arguments to be explained later
% that allow it to act reasonably if the window is resized.

% \begin{figure}
%   \centering
%   \includegraphics[width=.4\textwidth]{fig-tcltk-no-frame}
%   \includegraphics[width=.4\textwidth]{fig-tcltk-with-frame}
%   \caption{Similar GUIs, one using a frame within the toplevel window
%     (right one) and one without. The one without has widgets whose background does not match the toplevel window.}
%   \label{fig:tcltk-frame-noframe-example}
% \end{figure}


% <<no-frame, echo=FALSE>>=
% w <- tktoplevel()
% tkwm.title(w, "No frame")
% l <- ttklabel(w, text = "new text")
% tkpack(l)

% b <- ttkbutton(w, text = "click me", 
%                command = function() print("thanks"))
% tkpack(b)

% textvar <- tclVar("another label")
% l2 <- ttklabel(w, textvariable = textvar)
% tkpack(l2)
% @ 

% <<with-frame, echo=FALSE>>=
% w <- tktoplevel()
% tkwm.title(w, "With frame")
% w <- ttkframe(w, padding = c(3,3,12,12))  # Some breathing room
% tkpack(w, expand = TRUE, fill = "both")     # For window expansion
% l <- ttklabel(w, text = "new text")
% tkpack(l)

% b <- ttkbutton(w, text = "click me", 
%                command = function() print("thanks"))
% tkpack(b)

% textvar <- tclVar("another label")
% l2 <- ttklabel(w, textvariable = textvar)
% tkpack(l2)
% @ 

% <<UseFrameToTheme>>=
% w <- tktoplevel()
% f <- ttkframe(w, padding = c(3,3,12,12))  # Some breathing room
% tkpack(f, expand = TRUE, fill = "both")     # For window expansion
% l <- ttklabel(f,  text = "label")         # some widget
% tkpack(l)
% @ 


\subsection{Window properties and state: \code{tkwinfo}}
\label{sec:tcltk:overview:widget-properties}

For a widget, the function \function{tkcget} is used to get the values
of its options. If it is a themed widget, the \code{instate} command
returns its state values. 

To query the values of the containing window of the widget the
\function{tkwinfo} function is used.  When widgets are mapped, the
``window'' they are rendered to has properties, such as a class or
size. There are a few subcommands provided by \pkg{tcltk}, but by no
means is this exclusive. Rather, one can pass in the subcommand as an
argument to \function{tkwinfo}. If the subcommand's API is of the form

\begin{quotation}
\texttt{winfo} \textbf{subcommand\_name} \textit{window}  
\end{quotation}
the specification to \function{tkwinfo} is in the same order (the
widget is not the first argument). For instance, the
class\footnote{The class of a widget is more like a attribute and should
  not be confused with class in the object oriented sense. The class
  is used internally for bindings and styles.} of a label
is returned by the \texttt{class} subcommand:

<<WindowClass>>=
tkwinfo("class", label)
@ 
%

The window, in this example \texttt{l}, can be specified as an \R\/
object, or by its character ID. This is useful, as the return value of
some functions is the ID. For instance, the \texttt{children}
subcommand returns IDs. Below the \code{as.character} function will
coerce these into a vector of IDs.

<<echo=FALSE, results=hide>>=
window <- tktoplevel()
ttkbutton(window)
ttkbutton(window)
@ 

<<classOfChildren>>=
(children <- tkwinfo("children", window))
sapply(as.character(children), function(i) tkwinfo("class", i))
@ 

There are several possible subcommands, here we list a few. The
\subcommand{geometry}{tkwinfo} sub command returns the location and
size of the widgets' window in the form \code{width x height + x + y};
the sub commands \subcommand{height}{tkwinfo},
\subcommand{width}{tkwinfo}, \subcommand{x}{tkwinfo}, or
\subcommand{y}{tkwinfo} can be used to return just those parts. The
\subcommand{exists}{tkwinfo} command returns 1 (\code{TRUE}) if the
window exists and 0 otherwise; the \subcommand{ismapped}{tkwinfo} sub
command returns 1 or 0 if the window is currently mapped (drawn); the
\subcommand{viewable}{tkwinfo} sub command is similar, only it checks
that all parent windows are also mapped.  

\iprogram{widget hierarchy}
For traversing the widget hierarchy, one has available the
\subcommand{parent}{tkwinfo} sub command which returns the immediate
parent of the component, \subcommand{toplevel}{tkwinfo} which returns
the ID of the top-level window, and \subcommand{children}{tkwinfo}
which returns the IDs of all the immediate child components, if the
object is a container, such as a top-level window.


\subsection{Colors and fonts}
\label{sec:tcltk:overview:colors-fonts}
Colors and fonts are typically specified through a theme, but at times
it is desirable to customize the preset ones.

The label color can be set through its \code{foreground}
property. Colors can be specified by name -- for common colors -- or
by hex RGB values which are common in web programming.
<<>>=
tkconfigure(label, foreground = "red")
tkconfigure(label, foreground = "#00aa00")
@ 

To find the hex RGB value, one can use the \code{rgb} function to
create RGB values from intensities in $[0,1]$.  The \R\/ function
\function{col2rgb} can translate a named color into RGB values. The
\code{as.hexmode} function will display an integer in hexadecimal
notation.

In Example~\ref{ex:tcltk-entry-initial-message} we show how to modify
a style, as opposed to the \code{foreground} option, to change the
text color in an entry widget.

%% fonts
\paragraph{Fonts}
Fonts are a bit more involved than colors. \TK\/ version 8.5 made it
more difficult to change font properties of individual widgets, this
following the practice of centralizing style options for consistency,
ease of maintaining code and ease of theming.  To set a font for a
label, rather than specifying the font properties, one configures the
\code{font} options using a pre-defined font name, such as
<<>>=
tkconfigure(label, font = "TkFixedFont")
@ 

The \qcode{TkFixedFont} value is one of the standard font names, in
this case to use a fixed-width font. A complete list of the standard
names is provided in Table~\ref{tab:tcltk-std-fonts}. Each theme sets
these defaults accordingly.
<<echo=FALSE, results=tex>>=
DF <- rbind(
            c("\\code{TkDefaultFont}","Default font for all GUI items not otherwise specified"),
            c("\\code{TkTextFont}","Font for text widgets"),
            c("\\code{TkFixedFont}","Fixed-width font"),
            c("\\code{TkMenuFont}","Menubar fonts"),
            c("\\code{TkHeadingFont}","Font for column headings"),
            c("\\code{TkCaptionFont}","Caption font (dialogs)"),
            c("\\code{TkSmallCaptionFont}","Smaller caption font"),
            c("\\code{TkIconFont}","Icon and text font")
            )
colnames(DF) <- c("Standard font name", "Description")
cat(booktabs(DF, 
             caption="Standard font names defined by a theme.",
             label="tab:tcltk-std-fonts"))
@ 
%
\paragraph{Using \code{tkfont.create}}
The \index{tkfont!\code{create}} \function{tkfont.create} function can be used to create a new font, as with the following commands:
<<>>=
tkfont.create("our_font", family = "Helvetica", size = 12, 
              weight = "bold")
tkconfigure(label, font = "our_font")
@ 

As font families are system dependent, only \qcode{Courier},
\qcode{Times} and \qcode{Helvetica} are guaranteed to be there. A list
of an installation's available font families is returned by the
function \function{tkfont.families}.
Figure~\ref{fig:fig-tcltk-all-fonts} shows a display of some available
font families on a Mac OS X machine.  See
Example~\ref{ex:tcltk-scrollable-frame} for details.

The arguments for \function{tkfont.create} are optional. The
\argument{size}{tkfont.create} argument specifies the pixel size. The
\argument{weight}{tkfont.create} argument can be used to specify
\qcode{bold} or \qcode{normal}.  Additionally, a
\argument{slant}{tkfont.create} argument can be used to specify either
\qcode{roman} (normal) or \qcode{italic}. Finally,
\argument{underline}{tkfont.create} and
\argument{overstrike}{tkfont.create} can be set with a \code{TRUE} or
\code{FALSE} value.


\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-tcltk-all-fonts.png}
  \caption{A scrollable frame widget (cf. Example~\ref{ex:tcltk-scrollable-frame}) showing the available fonts on a system.}
  \label{fig:fig-tcltk-all-fonts}
\end{figure}


\paragraph{Font metrics}
The average character size is important in setting the width and
height of some components. (For example the text widget specifies its
height in lines, not pixels.) These sizes can be found using the
\function{tkfont.measure} and \function{tkfont.metrics}. Although the
average text size varies for proportional fonts, the size of the
\code{M} character is often used.
<<fontSizes>>=
font_measure <- tcl("font", "measure", "TkTextFont", "M")
font_width <- as.integer(tclvalue(font_measure))
tmp <- tkfont.metrics("TkTextFont", "linespace" = NULL)
font_height <- as.numeric(tclvalue(tmp))
#
c(width = font_width, height = font_height)
@ 


\subsection{Images}
\label{sec:tcltk:overview:images}


Many \pkg{tcltk} widgets, including both labels and buttons, can show
images. In these cases, either with or without an accompanying text
label. Constructing images to display is similar to constructing new
fonts, in that a new image object is created and can be reused by
various widgets. This shared use of resources reduces memory
consumption, and is an example of the flyweight design pattern.
\\

Images are created by the \function{tkimage.create} function.
The following command shows how an image object can be made from the
file \code{tclp.gif} in the current directory:

<<>>=
tkimage.create("photo", "::img::tclLogo", file = "tclp.gif")
@ 


The first argument, \qcode{photo} specifies that a full color image is
being used. (This option could also be \qcode{bitmap} but that is more
a legacy option.)\footnote{The \pkg{tkrplot} package allows a third
  option \code{Rplot}. This package has the high-level command
  \function{tkrplot}, but the low-level use of a) calling
  \code{.my.tkdev(hscale = 1,vscale = 1)} b) creating a graphic and c) creating an image
  object through \code{tkimage.create("Rplot", img\_name)} will
  produce a new image object one can use.} The second argument
specifies the name of the object. We follow the advice of the \TK\/
manual and preface the name with \code{::img::} so that we don't
inadvertently overwrite any existing \TCL\/ commands. (The command
\code{tcl("image", "names")} will return all defined image names.) The
third argument \argument{file}{tkimage.create} specifies the graphic
file. The basic \TK\/ \code{image} command can only show GIF and
PPM/PNM images. Unfortunately, not many \R\/ devices output in these
formats. (The \code{GDD} device driver can.) One may need system
utilities to convert to the allowable formats or install add-on \TCL\/
packages that can display other formats.~

To use the image, one specifies the image name to the
\option{image}{ttklabel} option:
<<>>=
label <- ttklabel(window, image = "::img::tclLogo", text = "logo text", 
              compound = "top")
@ 
<<echo=FALSE>>=
tkpack(label)
@ 

By default the text will not show. The \argument{compound}{ttklabel}
argument takes a value of either \qcode{text}, \qcode{image}
(default), \qcode{center}, \qcode{top}, \qcode{left}, \qcode{bottom},
or \qcode{right} specifying where the label is in relation to the
text.

\paragraph{Image manipulation}
Once an image is created, there are several options to manipulate the
image. These are found in the \TK\/ man page for \code{photo}, not
\code{image}. For instance, to change the palette so that instead of
\code{fullcolor} only 16 shades of gray are used to display the icon,
one could issue the command
<<>>=
tkconfigure("::img::tclLogo", palette = 16)
@ 
%%
Other commands allow one to scale an image (\code{copy zoom} and
\code{copy subsample}).
<<echo=FALSE>>=
## redo changing of palette
tkconfigure("::img::tclLogo", palette = "fullcolor")
@ 

%% changed to active, !active
% Another useful manipulation to draw attention to an image is to change
% the \code{gamma} value when something happens, such as a mouse-over
% event (cf. Example~\ref{ex-tcltk-toolbar}).



\section{Events and callbacks}
\label{sec:tcltk:overview:events-callbacks}

The button widget has the \code{command} option for assigning a
callback which is invoked (among other ways) when the user clicks the
mouse on the button. In addition to such commands, one may use
\function{tkbind} to invoke callbacks in response to many other events
that the user may initiate. The basic call is \code{tkbind(tag, event, script)}. 

%% (Unlike \pkg{RGtk2}, that the event triggers a widget to emit a signal that a callback listens for is not needed)

\subsection{The tag}

The \code{tag} object is more general than just a widget, or its
id. It can be:

\begin{description}
\item[the name of a widget,] in which case the command will be bound to that widget;
\item[a top-level window,] in which case the command will be be bound
  to the event for the window and all its internal widgets;
\item[a class of widget,] such as \qcode{TButton}, in which case all
  such widgets will get the binding; or
\item[the value \qcode{all},] in which case all widgets in the
  application will get the binding.
\end{description}

This flexibility makes it easy to create keyboard accelerators. For
example, the following mimics the linux shortcut \code{Control-q} to
close a window.
<<Ctrl-q-binding>>=
window <- tktoplevel()
button <- ttkbutton(window, text = "Some widget with the focus")
tkpack(button)
tkbind(window, "<Control-q>", function() tkdestroy(window))
@ 
%
By binding to the top-level window, we ensure that no matter which
widget has the focus the command will be invoked by the keyboard shortcut.


\subsection{Events}
\label{sec:tcltk:events}
\iprogram{signals}

%% possible events
%% keys
Of course, the possible events (or sequences of events) vary from widget to
widget. In addition, these events can be specified in a few ways. 

The example below uses two types of events. A single key press event, such as
``C'' or ``O'' can invoke a command and is specified by just its
character. Whereas, the event of pressing the return key is specified
using \code{\event{Return}}. In the following we bind the key presses to the
top-level window and the return event to any button with the default
class \code{TButton}.

<<bind_examples, results=hide>>=
window <- tktoplevel()
label <- ttklabel(window, text = "Click Ok for a message")
button1 <- ttkbutton(window, text = "Cancel", 
                command = function() tkdestroy(w))
button2 <- ttkbutton(window, text = "Ok", command = function() {
  print("initiate an action")
})
sapply(list(label, button1, button2), tkpack)
##
tkbind(window, "C", function() tcl(button1, "invoke"))
tkconfigure(button1, underline = 0)
##
tkbind(window, "O", function() tcl(button1, "invoke"))
tkconfigure(button2, underline = 0)
tkfocus(button2)
##
tkbind("TButton", "<Return>", function(W) {
  tcl(W, "invoke")
})
@ 
%
We modified our buttons using the \code{underline} option to give the
user an indication that the ``C'' and ``O'' keys will initiate some
action (Figure~\ref{fig:tcltk-underline-buttons}). Our callbacks
simply cause the appropriate button to \code{invoke} their
command. The latter one uses a percent substitution (below), which is
how \TK\/ passes along information about the event to the callback.

\begin{figure}
  \centering
  \includegraphics[width=.35\textwidth]{fig-tcltk-underline-buttons.png}
  \caption{Simple GUI showing buttons with \code{underline}
    property. The underlined letters match bindings to the top level
    window to invoke the button.}
  \label{fig:tcltk-underline-buttons}
\end{figure}

%% tkbind(widget,''<modifier-modifier-type-detail'>'', command)
\paragraph{Events with modifiers}
More complicated events can be described with the pattern

\begin{quotation}
\code{\Event{modifier-modifier-type-detail}}.   
\end{quotation}

Examples of a ``type'' are \code{\Event{KeyPress}} or
\code{\Event{ButtonPress}}. The event \code{\Event{Control-q}}, used
above, has the type \code{q} and modifier \code{Control}. Whereas
\code{\Event{Double-Button-1}} uses the detail \code{1} to indicate
which mouse button. The full list of modifiers and types are described
in the man page for \code{bind}. Some familiar modifiers are
\code{Control}, \code{Alt}, \code{Double} and \code{Triple}. The event
types are the standard X event types along with some
abbreviations. These are also listed in the \code{bind} man page. Some
commonly used ones are \code{Return} (as above), \code{ButtonPress},
\code{ButtonRelease}, \code{KeyPress}, \code{KeyRelease},
\code{FocusIn}, and \code{FocusOut}.

\paragraph{Window manager events}\iprogram{window manager events}
Some events are based on window manager events. The \code{\Event{Configure}}
event happens when a component is resized. The \code{\Event{Map}} and
\code{\Event{Unmap}} events happen when a component is drawn or undrawn.

\paragraph{Virtual events}
Finally, the event may be a ``virtual event.'' These are represented
as \code{\VirtualEvent{EventName}}. There are predefined virtual
events listed in the \code{event} man page. These include
\code{\VirtualEvent{MenuSelect}} when working with menus,
\code{\VirtualEvent{Modified}} for text widgets,
\code{\VirtualEvent{Selection}} for text widgets, and
\code{\VirtualEvent{Cut}}, \code{\VirtualEvent{Copy}} and
\code{\VirtualEvent{Paste}} for working with the clipboard. New
virtual events can be produced with the \code{tkevent.add}
function. This function takes at least two arguments, an event name and a
sequence that will initiate that event. The \code{event} man page has
these examples coming from the Emacs world:
<<>>=
 tkevent.add("<<Paste>>", "<Control-y>")
 tkevent.add("<<Save>>", "<Control-x><Control-s>")
@ 
%
In addition to virtual events occurring when the sequence is performed,
the \function{tkevent.generate} can be used to force an event for a
widget. This function requires a widget (or its ID) and the event
name. Other options can be used to specify substitution values,
described below. To illustrate, this command will generate the
\code{\VirtualEvent{Save}} event for the button \code{btn}:
<<>>=
tkevent.generate(button, "<<Save>>")
@ 
%
Example~\ref{ex-tcltk-dnd} uses virtual events to implement drag and
drop features.


\subsection{Callbacks}
\label{sec:tcltk:callbacks}
%% \XXX{ use of tcl(``eval'',''break'') to avoid calling subsequent callbacks} -- doesn't work
%% See PD's comments here on callbacks http://article.gmane.org/gmane.comp.lang.r.general/136705

\iprogram{event handlers}
The \pkg{tcltk} package implements callbacks in a manner different
from \TK, as the callback functions are \R\/ functions, not \TK\/
procedures. This is much more convenient, but introduces some slight
differences.  In \pkg{tcltk} these callbacks can be expressions
(unevaluated calls) or functions. We use only the latter. The basic
callback function need not have any arguments and those that do only
have percent substitutions passed in.


%% scope of callback?
The callback's return value is generally not important, although we
shall see that within the validation framework of entry widgets
(Section~\ref{sec:tcltk:entry-widgets}) it can matter.\footnote{The
  difference in processing of return values can make porting some
  \Tk\/ code to \pkg{tcltk} difficult. For example, the \code{break}
  command to stop a chain of call backs does not work.}



In \pkg{tcltk} only one callback can be associated with a widget and
event through the call
\code{tkbind(widget,event,callback)}. (Although, callbacks for the
widget associated with classes or toplevel windows can differ.)
Calling \code{tkbind} another time will replace the callback. To
remove a callback, simply assign a new callback which does
nothing.\footnote{This event handling can prevent one being able to port
  some \Tk\/ code into \pkg{tcltk}. In those cases, one may consider
  sourcing in \Tcl\/ code directly.}



\subsection{\% Substitutions}
\label{sec:tcltk-percent-substitutions}

One can not pass arbitrary user data to a callback, rather such values
must be found through \R's usual scoping rules. However, \TK\/
provides a mechanism called \defn{percent substitution} to pass
information about the event to callbacks bound to the event. The basic
idea is that in the \TCL\/ callback expressions of the type
\code{\%X}, for different characters \code{X}, will be replaced by values
coming from the event. In \pkg{tcltk}, if the callback function has an
argument \code{X}, then that variable will correspond to the value
specified by \code{\%X}. The complete list of substitutions is in the
\code{bind} man page. Some useful ones are \code{x} and \code{X} to
specify the relative or absolute $x$-postion of a mouse click (the
difference can be found through the \code{rootx} property of a
widget), \code{y} and \code{Y} for the $y$-position, \code{k} and
\code{K} for the keycode (ASCII) and key symbol of a
\code{\Event{KeyPress}} event, and \code{W} to refer to the ID of the
widget that signaled the event the callback is bound
to. 

The following trivial example illustrates, whereas
Example~\ref{ex-tcltk-dnd} will put these to use.

<<>>=
window <- tktoplevel()
button <- 
  ttkbutton(window, text = "Click me for the x,y position")
tkpack(button)
tkbind(button, "<ButtonPress-1>", function(W, x, y, X, Y) {
  print(W)                              # an ID
  print(c(x, X))                        # character class
  print(c(y, Y))
  })
@ 


<<ReturnValueDoesNotStopPropogation, eval=FALSE, echo=FALSE>>=
## This example illustrates how handlers are different in tcltk than Tk
## In this case we can't break out of the chain of handlers called in tcltk
library(tcltk)
window <- tktoplevel()
button <- ttkbutton(window, text = "click me", command = function() {
  ## default command: bind Button <1> {tk::ButtonDown %W}
  print("hi")
})

tkpack(button)

tkbind(button, "<Button-1>", function() {
  print("hello")
  .Tcl("return -code break") ## doesn't suppress call of other
})

## in Tcl returning -code break suppresses call to next handler
.Tcl("toplevel .w")
.Tcl("wm title .w {title}")
.Tcl("button .w.b -text {Click me} -command {puts hi}")
.Tcl("pack .w.b")
#.Tcl("bind .w.b <Button-1> {puts hello}")
.Tcl("bind .w.b <Button-1> {puts hello; return -code break}") ## no hi
@ 


%% After
\paragraph{The after command}
The \TCL\/ command \iprogram{timers}\code{after} will execute a command after a certain
delay (specified in milliseconds as an integer) while not interrupting
the control flow while it waits for its delay. The function is called
in a manner like:
\begin{Schunk}
  \begin{Sinput}
ID <- tcl("after", 1000, function() print("1 second passed"))    
  \end{Sinput}
\end{Schunk}
The ID returned by \code{after} may be used to \code{cancel} the
command before it executes. To execute a command repeatedly, can be
done along the lines of:
<<eval=FALSE>>=
after_ID <- ""
some_flag <- TRUE
repeat_call <- function(ms = 100, f) {
  after_ID <<- tcl("after", ms, function() {
    if(someFlag) {                      
      f()
      after_ID <<- repeat_call(ms, f)
    }  else {
      tcl("after", "cancel", after_ID)
    }
  })
}
repeat_call(2000, function() {
  print("Running. Set someFlag <- FALSE to stop.")
})
@ 
%


\begin{example}{Drag and drop}{ex-tcltk-dnd}
  \SweaveInput{ex-tcltk-dnd.Rnw}
\end{example}


