\XXX{Where to put loading in external TCL source, packages, ...}
\XXX{tcl("update","idletasks")}
\XXX{use svMisc -- atleast comment on Parse, Complete, CompletePlus}

\section{Interacting with \TCL}
\label{sec:tcltk:interacting-with-tcl}


%% Tclk
The basic syntax of \TCL\/ is a bit unlike \R. For
example a simple string assignment would be made at tclsh, the \TCL\/
shell with (using \code{\%} as a prompt)
\begin{verbatim}
% set x {hello world}
hello world
\end{verbatim}
Unlike \R\/ where braces are used to form blocks, this example shows
how \TCL\/ uses braces instead of quotes to group the words as a
single string. The use of braces, instead of quotes, in this example
is optional, but in general isn't, as expressions within braces are
not evaluated.  

The example above assigns to the variable \code{x} the
value of \code{hello world}. Once assignment has been made, one can
call commands on the value stored in \code{x} using the \code{\$}
prefix:
\begin{verbatim}
% puts $x
hello world
\end{verbatim}
The \code{puts} command, in this usage, simply writes back its argument to the terminal. Had
we used braces the argument would not have been substituted:
\begin{verbatim}
% puts {$x}
$x
\end{verbatim}

More typical within the \pkg{tcltk} package is the idea of a subcommand. For
example, the \code{string} command provides the subcommand
\code{length} to return the number of characters in the string.
\begin{verbatim}
% string length $x
11
\end{verbatim}

%% .Tcl
The \pkg{tcltk} package provides the low-level function \function{.Tcl} for direct
access to the \TCL\/ interpreter:
<<>>=
library(tcltk)
.Tcl("set x {some text}")               # assignment
.Tcl("puts $x")                         # print
.Tcl("string length $x")                # call a command
@ 

the \dfn{\function{.Tcl}} function simply sends a command as a text
string to the \TCL\/ interpreter and returns the result as an object
of class \dfn{\class{tclObj}} (cf. \code{?.Tcl}).
The \function{.Tcl} function can be used to read in \TCL\/ scripts as
with \code{.Tcl("source filename")}. This can be used to run arbitrary
\TCL\/ scripts within an \R\/ session.



The \class{tclObj} objects print with the leading \code{<Tcl>} (which
we suppress here when there is no output). The string representation
of objects of class \class{tclObj} is returned by \function{tclvalue}
or by coercion through the \function{as.character} function. They
differ in how they treat spaces and new lines.  Conversion to numeric
values is also possible through \code{as.numeric}, but conversion to
logical requires two steps as only modes \code{character},
\code{double} or \code{integer} are stored. In general though,
conversion of complicated \TCL\/ expressions is not supported.


The \TK\/ extensions to \TCL\/ have a complicated command structure,
and thankfully, \pkg{tcltk} provides some more conveniently named
functions. To illustrate, the \TCL\/ command to set the text value for
a label object (\code{.label}) would look like
\begin{verbatim}
% .label configure -text "new text"
\end{verbatim}
The \pkg{tcltk} provides a corresponding function
\code{tkconfigure}. The above would be done as (assuming \code{l} is a
label object):

<<echo=FALSE>>=
## set up label for sweave below. Not shown
w <- tktoplevel()
l <- ttklabel(w)
tkpack(l)
@ 

<<>>=
tkconfigure(l, text="new text")
@ 


Although the \TCL\/ statement appears to have the object-oriented form
of ``object method arguments,'' behind the scenes \TCL\/ creates a
command with the same name as the widget with \code{configure} as a
subcommand. This is followed by options passed in using the form
\texttt{-key value}.  The \TK\/ API for \code{ttklabel}'s
\code{configure} subcommand is

\begin{quotation}
  \textit{pathName} \textbf{configure} \textit{?option? ?value option value ...?}
\end{quotation}

The \textit{pathName} is the ID of the label widget. This can be found
from the object \code{l} above, in \code{l\$ID}, or in some cases is a
return value of some other command call.  In the \TK\/ documentation
paired question marks indicate optional values. In this case, one can
specify nothing, returning a list of all options; just an option, to
query the configured value; the option with a value, to modify the
option; and possibly do more than one at at time.  For commands such
as \code{configure}, there will usually correspond a function in
\R\/ of the same name with a \code{tk} prefix, as in this case
\function{tkconfigure}.  (The package \pkg{tcltk} was written before
namespaces were implemented in \R, so the ``tk'' prefix serves that role.) 

To make consulting the \TK\/ manual pages easier in the text we would
describe the configure subcommand as
\subcommanda{configure}{ttklabel}{[options]}. (The \R\/ manual pages
simply redirect you to the original \TK\/ documentation, so
understanding this is important for reading the API.) However, if such
a function is present, we will use the \R\/ function equivalent when
we illustrate code. Some subcommands have further subcommands. An
example is to set the selection. In the \R\/ function, the second
command is appended with a dot, as in \code{tkselection.set}. (There
are a few necessary exceptions to this.)

\paragraph{The tcl function} Within \pkg{tcltk}, the \function{tkconfigure} function is defined by

\begin{Sinput}
function(widget, ...) tcl(widget, "configure", ...)
\end{Sinput}

The \dfn{\function{tcl}} function is the workhorse used to piece
together \TCL\/ commands, call the interpreter, and then return an
object of class \code{tclObj}.  Behind the scenes it turns an \R\/
object, \code{widget}, into the \textit{pathName} above (using its ID
component). It converts \R\/ \code{key=value} pairs into \code{-key
  value} options for \TCL. As named arguments are only for the
\code{-key value} expansion, we follow the \TCL\/ language and call
the arguments ``options'' in the following. Finally, it adjusts any
callback functions. The \function{tcl} function uses position to
create its command, the order of the subcommands needs to match that
of the \TK\/ API, so although it is true that often the \R\/ object is
first, this is not always the case.

\begin{figure}
  \centering
\begin{verbatim}
          tcl(widget, subcommand, key=value, callback)
             /            |           |           \
          widget$ID  subcommand   -key value   makeCallback
\end{verbatim}
  \caption{How the \code{tcl} function maps its arguments}
  \label{fig:tcl-function-map}
\end{figure}






%% constructors

\section{Constructors}
\label{sec:tcltk:constructors}

In this Chapter, we will stick to a few basic widgets: labels and
buttons; and top-level containers to illustrate the basic usage of
\pkg{tcltk}, leaving for later more detail on containers and widgets.

Unlike \GTK, say, the construction of widgets in \pkg{tcltk} is linked
to the widget heirarchy. \TK\/ widgets are constructed as children of
a parent container with the parent specified to the constructor. When
the \TK\/ shell, wish, is used or the \TK\/ package is loaded through
the \TCL\/ command \code{package require Tk}, a top level window named
``\code{.}'' is created. In the variable name \code{.label}, from
above, the dot refers to the top level window.  In \pkg{tcltk} a
top-level window is created separately through the
\constructor{tktoplevel} constructor, as with
<<>>=
w <- tktoplevel()
@ 

Top-level windows will be explained in more detail in
Section~\ref{sec:tcltk:basic-containers}. For now, we just use one to
construct a label widget. Like all constructors, but a toplevel window
one, the label constructor (\constructor{ttklabel}) requires a
specification of the parent container (\code{w}) and any other options
that are desired. A typical usage would look like:
<<>>=
l <- ttklabel(w, text="label text")
@ 

To see the label, we can pack it into the toplevel window, which was
used as its parent at construction.
<<>>=
tkpack(l)
@ 

\paragraph{Options}
The first argument of a constructor is the parent container,
subsequent arguments are used to specify the options for the
constructor given as \code{key=value} pairs. The \TK\/ API lists these
options along with their description.

For a simple label, the following options are possible: \code{anchor},
\code{background}, \code{font}, \code{foreground}, \code{justify},
\code{padding}, \code{relief}, \code{text}, and \code{wraplength}.
This is in addition to the standard options \code{class},
\code{compound}, \code{cursor}, \code{image}, \code{state},
\code{style}, \code{takefocus}, \code{text}, \code{textvariable},
\code{underline}, and \code{width}. (Although clearly lengthy, this
list is significantly reduced from the options for \code{tklabel}
where options for the many style properties are also included.)

Many of the options are clear from their name.  The
\argument{padding}{ttklabel} argument allows the specification of
space in pixels between the text of the label and the widget
boundary. This may be set as four values \code{c(left, top, right,
  bottom)}, or fewer, with \code{bottom} defaulting to \code{top},
\code{right} to \code{left} and \code{top} to \code{left}. The
\argument{relief}{ttklabel} argument specifies how a 3-d effect around
the label should look, if specified. Possible values are \qcode{flat},
\qcode{groove}, \qcode{raised}, \qcode{ridge}, \qcode{solid}, or
\qcode{sunken}.

\paragraph{The functions tkcget, tkconfigure}

Option values may be set through the constructor, or adjusted
afterwards by \function{tkconfigure}. A listing (in \TCL\/ code) of possible options
that can be adjusted may be seen by calling \function{tkconfigure}
with just the widget as an argument.

<<>>=
head(as.character(tkconfigure(l)))      # first 6 only
@ 

The \function{tkcget} function returns the value of an
option (again as a \code{tclObj} object). The option can be specified
two different ways. Either using the \TK\/ style of a leading dash or
using the \R{} convention that \code{NULL} values mean to return the value,
and not set it.


<<>>=
tkcget(l, "-text")                      # retrieve text property
tkcget(l, text=NULL)                    # alternate syntax
@ 

\paragraph{Coercion to character}
As mentioned, the \code{tclObj} objects can be coerced to character class two ways.
The conversion through \code{as.character} breaks the return value along whitespace:
<<>>=
as.character(tkcget(l, text=NULL))
@ 
%
Whereas, conversion by the \function{tclvalue} function does not break along white
space.
<<>>=
tclvalue(tkcget(l, text=NULL))
@ 
%


\paragraph{Buttons}
Buttons are constructed using the \constructor{ttkbutton} constructor.
<<>>=
b <- ttkbutton(w, text="click me", 
               command=function() print("thanks"))
@ 

Buttons and labels share many of the same options. However, in addition, buttons
have a \argument{command}{ttkbutton} option to specify a callback for
when the button is clicked. The above callback prints a simple message. Callbacks
will be explained in Section~\ref{sec:tcltk:callbacks}. 

Furthermore, buttons have the option \argument{default}{ttkbutton} to
specify which button of a dialog, by default, will get the
\texttt{Return} signal when the \kbd{enter} key is pressed. A callback
can then be set to respond to this signal. This value for
\code{default} may be \qcode{active}, indicating the button will get
the signal; \qcode{normal}; or \qcode{disabled}, to draw the button
without space to indicate it


\paragraph{tkwidget}
Constructors call the \function{tkwidget} function which returns an
object of class \code{tkwin}. (In \TK\/ the term ``window'' is used to
refer to the drawn widget and not just a top-level window)

<<str>>=
str(b)
@ 

The returned widget objects are lists with two components: an ID and an
environment. The \code{ID} component keeps a unique ID of the
constructed widget. This is a character string, such as ``.1.2.1''
coming from the the widget heirarchy of the object. This value is
generated behind the scenes by the \pkg{tcltk} package using numeric
values to keep track of the heirarchy. The \code{env} component
contains an environment that keeps a count of the subwindows, the parent
window and any callback functions. This helps ensure that any copies
of the widget refer to the same object~\citep{Dalgaard-DSC}. As the
construction of a new widget requires the \code{ID} and environment of
its parent, the first argument to \function{tkwidget}, \code{parent},
must be an \R\/ \TK\/ object, not simply its character ID, as is
possible for the \function{tcl} function.

%%The latter is useful in
%%a callback, as only the ID may be known to the callback function.


\subsection{Geometry managers}
\label{sec:tcltk:overview:geometry-managers}

As with \Qt, when a new widget is constructed it is not automatically
mapped. \TK\/ uses geometry managers to specify how the widget will be
drawn within the parent container. We will discuss two such geometry
managers in Chapter~\ref{sec:tcltk:basic-containers}, but for now, we note
that the simplest way to view a widget in its parent window is through
\function{tkpack}, as in:
<<>>=
tkpack(b)
@ 

This command packs the widgets into the top-level window (the parent
in this case) in a box-like manner. Unlike \GTK\/ more than one child
can be packed into a top-level window, although we don't demonstrate
this further, as later we will use an intermediate \function{ttkframe}
box container so that themes are properly displayed.

\subsection{\TCL\/ variables}
\label{sec:tcltk:overview:textvariables}


%% textvariables
For several \TK\/ widgets, there is an option \code{textvariable} to specify
a \TCL\/ variable. These variables are dynamically bound to the
widget, so that changes to the variable are propogated to the
GUI. (The \TCL\/ variable is a model and the widget a view of the
model.)  The basic functions involved are \function{tclVar} to create
a \TCL\/ variable, \function{tclvalue} to get the assigned value and
\function{tclvalue\ASSIGN} to modify the value.

<<>>=
textvar <- tclVar("another label")
l2 <- ttklabel(w, textvariable=textvar)
tkpack(l2)
tclvalue(textvar)
tclvalue(textvar) <- "new text"         
@ 

\TCL\/ variables have a unique identifier, returned by \function{as.character}:
<<>>=
as.character(textvar)
@ 

The advantages of \TCL\/ variables are like those of the MVC paradigm
-- a single data source can have its changes propogated to several
widgets automatically. If the same text is to appear in different
places, their usage is recommended.  One disadvantage, is that in a
callback, the variable is not passed to the callback and must be found
through \R's scoping rules.

The package also provides the function \dfn{\function{tclArray}} to
store an array of \TCL\/ variables. The usual list methods \code{[[}
and \code{\$} and their forms for assignment are available for arrays,
but values are only referred to by name, not index:

<<tclVarExample, echo=FALSE, eval=FALSE>>=
x <- tclVar(1)
print(x)                                # a tclVar object
tclvalue(x)                             # internal name
as.numeric(tclvalue(x))                 # get value then coerce
@ 


<<tclArrayExample>>=
x <- tclArray()                         # no init
x$one <- 1; x[[2]] <- 2                 # $<- and [[<-
x[[1]]                                  # no match by index
names(x)                                # the stored names
x[['2']]                                # match by name, not index
@ 


\subsection{Window properties and state: \code{tkwinfo}}
\label{sec:tcltk:overview:widget-properties}

Widgets have options which can be set through \code{tkconfigure} and
additionally, when mapped, the ``window'' they are rendered to has
properties, such as a class or size. These properties are queried
through the \function{tkwinfo} function.  There are several such
properties, and they may take different forms. If the API is of the form

\begin{quotation}
\texttt{winfo} \textbf{subcommand\_name} \textit{window}  
\end{quotation}
the specification to \function{tkwinfo} is in the same order (the
widget is not the first argument). For instance, the class of a label
is returned by the \texttt{class} subcommand as

<<WindowClass>>=
tkwinfo("class", l)
@ 

The window, in this example, \texttt{l}, can be specified as an \R\/
object, or by its character ID. This is useful, as the return value of
some functions is the ID. For instance, the \texttt{children}
subcommand returns IDs. Below the \code{as.character} function will
coerce these into a vector of IDs.

<<classOfChildren>>=
(children <- tkwinfo("children",f))
sapply(as.character(children), function(i) tkwinfo("class", i))
@ 

There are several possible subcommands, here we list a few. The
\subcommand{geometry}{tkwinfo} sub command returns the location and
size of the widgets' window in the form \code{width x height + x + y};
the sub commands \subcommand{height}{tkwinfo},
\subcommand{width}{tkwinfo}, \subcommand{x}{tkwinfo}, or
\subcommand{y}{tkwinfo} can be used to return just those parts. The
\subcommand{exists}{tkwinfo} command returns 1 (\code{TRUE}) if the
window exists and 0 otherwise; the \subcommand{ismapped}{tkwinfo} sub
command returns 1 or 0 if the window is currently mapped (drawn); the
\subcommand{viewable}{tkwinfo} sub command is similar, only it checks
that all parent windows are also mapped.  For traversing the widget
heirarchy, one has available the \subcommand{parent}{tkwinfo} sub
command which returns the immediate parent of the component,
\subcommand{toplevel}{tkwinfo} which returns the ID of the top-level
window, and \subcommand{children}{tkwinfo} which returns the IDs of
all the immediate child components, if the object is a container, such
as a top-level window.




\subsection{Colors and fonts}
\label{sec:tcltk:overview:colors-fonts}

The label color can be set through its \code{foreground}
property. Colors can be specified by name -- for common colors -- or
by hex RGB values which are common in web programming.
<<>>=
tkconfigure(l, foreground="red")
tkconfigure(l, foreground="#00aa00")
@ 

To find the hex RGB value, one can use the \code{rgb} function to
create RGB values from intensities in $[0,1]$.  The \R\/ function
\function{col2rgb} can translate a named color into RGB values. The
\code{as.hexmode} function will display an integer in hexadecimal
notation.

%% fonts
\paragraph{Fonts}
Fonts are more involved than colors. \TK\/ version 8.5 made it more
difficult to change style properties of individual widgets. This
following the practice of centralizing style options for consistency,
ease of maintaining code and ease of theming.  To set a font for a
label, rather than specify the font properties, one configures the
\code{font} attribute using a pre-defined font name, such as
<<>>=
tkconfigure(l, font="TkFixedFont")
@ 

The \qcode{TkFixedFont} value is one of the standard font names, in
this case to use a fixed-width font. A complete list of the standard
names is provided in Table~\ref{tab:tcltk-std-fonts}. Each theme sets
these defaults accordingly.
<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\code{TkDefaultFont}","Default font for all GUI items not otherwise specified"),
            c("\\code{TkTextFont}","Font for text widgets"),
            c("\\code{TkFixedFont}","Fixed-width font"),
            c("\\code{TkMenuFont}","Menu bar fonts"),
            c("\\code{TkHeadingFont}","Font for column headings"),
            c("\\code{TkCaptionFont}","Caption font (dialogs)"),
            c("\\code{TkSmallCaptionFont}","Smaller caption font"),
            c("\\code{TkIconFont}","Icon and text font")
            )
colnames(df) <- c("Standard font name", "Description")
cat(booktabs(df, 
             caption="Standard font names defined by a theme.",
             label="tab:tcltk-std-fonts"))
@ 

The \function{tkfont.create} function can be used to create a new font, as with the following commands:
<<>>=
tkfont.create("ourFont", family="Helvetica", size=12, 
              weight="bold")
tkconfigure(l, font="ourFont")
@ 

As font families are system dependent, only \qcode{Courier},
\qcode{Times} and \qcode{Helvetica} are guaranteed to be there. A list
of an installation's available font families is returned by the
function \function{tkfont.families}.
Figure~\ref{fig:fig-tcltk-all-fonts} shows a display of some available
font families on a Mac OS X machine.  See
Example~\ref{ex:tcltk-scrollable-frame} for details.

The arguments for \function{tkfont.create} are optional. The
\argument{size}{tkfont.create} argument specifies the pixel size. The
\argument{weight}{tkfont.create} argument can be used to specify
\qcode{bold} or \qcode{normal}.  Additionally, a
\argument{slant}{tkfont.create} argument can be used to specify either
\qcode{roman} (normal) or \qcode{italic}. Finally,
\argument{underline}{tkfont.create} and
\argument{overstrike}{tkfont.create} can be set with a \code{TRUE} or
\code{FALSE} value.


\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-tcltk-all-fonts.png}
  \caption{A scrollable frame widget (cf. Example~\ref{ex:tcltk-scrollable-frame}) showing the available fonts on a system.}
  \label{fig:fig-tcltk-all-fonts}
\end{figure}


\paragraph{Font metrics}
The average character size is important in setting the width and
height of some components. The can be found through the
\function{tkfont.measure} and \function{tkfont.metrics} functions as
follows:
<<fontSizes>>=
tmp <- tkfont.measure("TkTextFont",paste(c(0:9,LETTERS),collapse=""))
fontWidth <- ceiling(as.numeric(tclvalue(tmp))/36)
tmp <- tkfont.metrics("TkTextFont","linespace"=NULL)
fontHeight <- as.numeric(tclvalue(tmp))
c(width=fontWidth, height=fontHeight)
@ 


\subsection{Images}
\label{sec:tcltk:overview:images}


Many \pkg{tcltk} widgets, including both labels and buttons, can show
images. In these cases, either with or without an accompanying text
label. Constructing images to display is similar to constructing new
fonts, in that a new image object is created and can be reused by
various widgets. Images are created by the \function{tkimage.create}
function. 

The following command shows how an image object can be made from the
file \code{tclp.gif} in the current directory:

<<>>=
tkimage.create("photo", "::img::tclLogo", file = "tclp.gif")
@ 


The first argument, \qcode{photo} specifies that a full color image is
being used. (This option could also be \qcode{bitmap} but that is more
a legacy option.) The second argument specifies the name of the
object. We follow the advice of the \TK\/ manual and preface the name
with \code{::img::} so that we don't inadvertently overwrite any
existing \TCL\/ commands. The third argument
\argument{file}{tkimage.create} specifies the graphic file. The basic
\TK\/ \code{image} command can only show GIF and PPM/PNM
images. Unfortunately, not many \R\/ devices output in these
formats. (The \code{GDD} device driver can.) One may need system
utilities to convert to the allowable formats or install add-on \TCL\/
packages that can display other formats.

To use the image, one can specify the name for the \option{image}{ttklabel} option.
<<>>=
l <- ttklabel(w, image="::img::tclLogo", text="logo text", 
              compound = "top")
@ 
<<echo=FALSE>>=
tkpack(l)
@ 

By default the text will not show. The \argument{compound}{ttklabel}
argument takes a value of either \qcode{text}, \qcode{image}
(default), \qcode{center}, \qcode{top}, \qcode{left}, \qcode{bottom},
or \qcode{right} specifying where the label is in relation to the
text.

\paragraph{Image manipulation}
Once an image is created, there are several options to manipulate the
image. These are found in the \TK\/ man page for \code{photo}, not
\code{image}. For instance, to change the palette so that instead of
\code{fullcolor} only 16 shades of gray are used to display the icon,
one could issue the command
<<>>=
tkconfigure("::img::tclLogo", palette=16)
@ 
<<echo=FALSE>>=
## redo changing of palette
tkconfigure("::img::tclLogo", palette="fullcolor")
@ 

Another useful manipulation to draw attention to an image is to change
the \code{gamma} value when something happens, such as a mouse-over
event (cf. Example~\ref{ex-tcltk-toolbar}).


\subsection{Themes}
\label{sec:tcltk:overview:themes}


%% themes -- ttkframe
The themed widgets have a style that determines how they are
drawn. The separation of style properties from the widget, as opposed
to having these set for each construction of a widget, makes it much
easier to change the look of a GUI and easier to maintain the code. A
collection of styles makes up a theme. The available themes depend on
the system. The default theme should enable a GUI to have the native
look and feel of the operating system. (This was definitely not the
case for the older \TK\/ widgets.) There is no built in command to
return the theme, so we use \code{.Tcl} to call the appropriate \TCL\/
command. The \code{names} sub command will return the available themes
and the \code{use} sub command can be used to set the theme.

<<>>=
.Tcl("ttk::style theme names")
.Tcl("ttk::style theme use classic")
@ 

The writing of themes will not be covered, but in
Example~\ref{ex-tcltk-toolbar} we show how to create a new style for a
button.

The example we have shown so far, would not look quite right, as the
toplevel window is not a themed widget. To work around that, a
\function{ttkframe} widget is usually used to hold the child
components of the top-level window. The following shows how to place a
frame inside the window, with some arguments to be explained later
that allow it to act reasonably if the window is resized.

<<UseFrameToTheme>>=
w <- tktoplevel()
f <- ttkframe(w, padding=c(3,3,12,12))  # Some breathing room
tkpack(f, expand=TRUE, fill="both")     # For window expansion
l <- ttklabel(f, image="::img::tclLogo", text="label", 
              compound="top")
tkpack(l)
@ 

\section{Events and Callbacks}
\label{sec:tcltk:overview:events-callbacks}

The button widget has the \code{command} option for assigning a
callback for when the user clicks the mouse button on the button. In
addition to this, one can specify callbacks for many other events that
the user may initiate.


\subsection{Callbacks}
\label{sec:tcltk:callbacks}
%% \XXX{ use of tcl(``eval'',''break'') to avoid calling subsequent callbacks} -- doesn't work
%% See PD's comments here on callbacks http://article.gmane.org/gmane.comp.lang.r.general/136705

The \pkg{tcltk} package implements callbacks in a manner different
from \TK, as the callback functions are \R\/ functions, not \TK\/
procedures. This is much more convenient, but introduces some slight
differences.  In \pkg{tcltk} these callbacks can be expressions
(unevaluated calls) or functions. We use only the latter, for more
clarity. The basic callback function need not have any arguments. For
instance, earlier we showed how to print a message when the user clicks a
button:
<<>>=
w <- tktoplevel()
callback <- function() print("thanks")
b <- ttkbutton(w, text="Click me", command = callback)
tkpack(b)
@ 


%% scope of callback?
The callback's return value is generally not important, although we
shall see with the validation framework, discussed in
Section~\ref{sec:tcltk:entry-widgets}, it can matter.~\footnote{The
  difference in processing of return values can make porting some
  \Tk\/ code to \pkg{tcltk} difficult} As well, in \Tk\/ callbacks are
evaluated in the global environment, but this is not so in
\pkg{tcltk}, which respects the callback's scope.



In \pkg{tcltk} only one callback can be associated with a widget and
event through the call
\code{tkbind(widget,event,callback)}. (Although, callbacks for the
widget associated with classes or toplevel windows can differ.)
Calling \code{tkbind} another time will replace the callback. To
remove a callback, simply assign a new callback which does
nothing.~\footnote{This event handling can prevent being able to port
  some \Tk\/ code into \pkg{tcltk}. In those cases, one may consider
  sourcing in \Tcl\/ code directly.}



\subsection{\% Substitutions}
\label{sec:tcltk-percent-substitutions}
\TK\/ provides a mechanism called \defn{percent substitution} to pass
information about the event to callbacks bound to the event. The basic
idea is that in the \TCL\/ callback expressions of the type
\code{\%X}, for different characters \code{X}, will replaced by values
coming from the event. In \pkg{tcltk}, if the callback function has an
argument \code{X}, then that variable will correspond to the value
specified by \code{\%X}. The complete list of substitutions is in the
\code{bind} man page. Some useful ones are \code{x} and \code{X} to
specify the relative or absolute $x$-postion of a mouse click (the
difference can be found through the \code{rootx} property of a
widget), \code{y} and \code{Y} for the $y$-position, \code{k} and
\code{K} for the keycode (ASCII) and key symbol of a \code{\Event{KeyPress}}
event, and \code{W} to refer to the ID of the widget that signaled the
event the callback is bound to. Example~\ref{ex-tcltk-dnd} will
illustrate some of these.

<<ReturnValueDoesNotStopPropogation, eval=FALSE, echo=FALSE>>=
## This example illustrates how handlers are different in tcltk than Tk
## In this case we can't break out of the chain of handlers called in tcltk
library(tcltk)
w <- tktoplevel()
b <- ttkbutton(w, text="click me", command = function() {
  ## default command: bind Button <1> {tk::ButtonDown %W}
  print("hi")
})

tkpack(b)

tkbind(b, "<Button-1>", function() {
  print("hello")
  .Tcl("return -code break") ## doesn't suppress call of other
})

## in Tcl returning -code break suppresses call to next handler
.Tcl("toplevel .w")
.Tcl("wm title .w {title}")
.Tcl("button .w.b -text {Click me} -command {puts hi}")
.Tcl("pack .w.b")
#.Tcl("bind .w.b <Button-1> {puts hello}")
.Tcl("bind .w.b <Button-1> {puts hello; return -code break}") ## no hi
@ 


\subsection{Events}
\label{sec:tcltk:events}

%% (Unlike \pkg{RGtk2}, that the event triggers a widget to emit a signal that a callback listens for is notneeded)

When a user interacts with a GUI, they initiate events. The
\pkg{tcltk} package allows the programmer to bind callbacks to these
events, through the \function{tkbind} function. This function is
called as \code{tkbind(tag, events, command)}. The \code{command} is a
callback, as described above.

The \code{tag} argument allows for quite a bit of flexibility. It can be:

\begin{description}
\item[the name of a widget,] in which case the command will be bound to that widget;
\item[a top-level window,] in which case the command will be be bound
  to the event for the window and all its internal widgets;
\item[a class of widget,] such as \qcode{TButton}, in which case all
  such widgets will get the binding; or
\item[the value \qcode{all},] in which case all widgets in the
  application will get the binding.
\end{description}
%% possible events
%% keys
The possible events (or sequences of events) vary from widget to
widget. The events can be specified in a few ways. A single keypress
event can be assigned by specifying the ASCII character
generated. For instance, to bind to \kbd{C} for the ``Click me''
button above using the same callback could be done with
<<>>=
 tkbind(b, "C", callback)
 tkfocus(b)
@ 
%
The \function{tkfocus} function is used to set the focus to the button so that it will receive the keypress.

%% tkbind(widget,''<modifier-modifier-type-detail'>'', command)
\paragraph{Events with modifiers}
More complicated events can be described with the pattern

\begin{quotation}
\code{\Event{modifier-modifier-type-detail}}.   
\end{quotation}

Examples of a ``type'' are \code{\Event{KeyPress}} or
\code{\Event{ButtonPress}}. The event \code{\Event{Control-c}} has the
type \code{c} and modifier \code{Control}. Whereas
\code{\Event{Double-Button-1}} also has the detail \code{1}. The full
list of modifiers and types are described in the man page for
\code{bind}. Some familiar modifiers are \code{Control}, \code{Alt},
\code{Button1} (also \code{B1}), \code{Double} and
\code{Triple}. The event types are the standard X event types along
with some abbreviations. These are also listed in the \code{bind} man
page. Some commonly used ones are \code{ButtonPress},
\code{ButtonRelease}, \code{KeyPress}, \code{KeyRelease},
\code{FocusIn}, and \code{FocusOut}.

\paragraph{Window manager events}
Some events are based on window manager events. The \code{\Event{Configure}}
event happens when a component is resized. The \code{\Event{Map}} and
\code{\Event{Unmap}} events happen when a component is drawn or undrawn.

\paragraph{Virtual events}
Finally, the event may be a ``virtual event.'' These are represented
with \code{\VirtualEvent{EventName}}. There are predefined virtual
events listed in the \code{event} man page. These include
\code{\VirtualEvent{MenuSelect}} when working with menus,
\code{\VirtualEvent{Modified}} for text widgets,
\code{\VirtualEvent{Selection}} for text widgets, and
\code{\VirtualEvent{Cut}}, \code{\VirtualEvent{Copy}} and
\code{\VirtualEvent{Paste}} for working with the clipboard. New
virtual events can be produced with the \code{tkevent.add}
function. This takes atleast two arguments, an event name and a
sequence that will initiate that event. The \code{event} man page has
these examples coming from the Emacs world:
<<>>=
 tkevent.add("<<Paste>>", "<Control-y>")
 tkevent.add("<<Save>>", "<Control-x><Control-s>")
@ 
%
In addition to virtual events occuring when the sequence is performed,
the \function{tkevent.generate} can be used to force an event for a
widget. This function requires a widget (or its ID) and the event
name. Other options can be used to specify substitution values,
described below. To illustrate, this command will generate the
\code{\VirtualEvent{Save}} event for the button \code{b}:
<<>>=
tkevent.generate(b, "<<Save>>")
@ 
%


%% After
\paragraph{The after command}
The \TCL\/ command \code{after} will execute a command after a certain
delay (specified in milliseconds as an integer) while not interupting
the control flow while it waits for its delay. The function is called
in a manner like:
\begin{Schunk}
  \begin{Sinput}
    ID <- tcl("after", 1000, function() print("1 second passed"))    
  \end{Sinput}
\end{Schunk}
The ID returned by \code{after} may be used to \code{cancel} the
command before it executes. To execute a command repeatedly, can be
done along the lines of:
<<eval=FALSE>>=
afterID <- ""
someFlag <- TRUE
repeatCall <- function(ms=10000, f, w) {
  afterID <<- tcl("after", ms, function() {
    if(someFlag) {                      
      f()
      afterID <<- repeatCall(ms, f, w)
    }  else {
      tcl("after", "cancel", afterID)
    }
  })
}
repeatCall(100, function() print("running"), w)
@ 
%


\begin{example}{Drag and Drop}{ex-tcltk-dnd}
  \SweaveInput{ex-tcltk-dnd.Rnw}
\end{example}


