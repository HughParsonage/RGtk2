\XXX{Where to put loading in external TCL source, packages, ...}
\XXX{tcl("update","idletasks")}
\XXX{use svMisc -- atleast comment on Parse, Complete, CompletePlus}

\section{Interacting with \TCL}
\label{sec:tcltk:interacting-with-tcl}


%% Tclk
Although both are scripting languages, the basic syntax of \TCL\/ is a bit unlike \R. For
example a simple string assignment would be made at tclsh, the \TCL\/
shell with (using \code{\%} as a prompt)
\begin{verbatim}
% set x {hello world}
hello world
\end{verbatim}
Unlike \R\/ where braces are used to form blocks, this example shows
how \TCL\/ uses braces instead of quotes to group the words as a
single string. The use of braces, instead of quotes, in this example
is optional, but in general isn't, as expressions within braces are
not evaluated.  

The example above assigns to the variable \code{x} the
value of \code{hello world}. Once assignment has been made, one can
call commands on the value stored in \code{x} using the \code{\$}
prefix:
\begin{verbatim}
% puts $x
hello world
\end{verbatim}
The \code{puts} command, in this usage, simply writes back its argument to the terminal. Had
we used braces the argument would not have been substituted:
\begin{verbatim}
% puts {$x}
$x
\end{verbatim}

More typical within the \pkg{tcltk} package is the idea of a subcommand. For
example, the \code{string} command provides the subcommand
\code{length} to return the number of characters in the string.
\begin{verbatim}
% string length $x
11
\end{verbatim}

%% .Tcl
The \pkg{tcltk} package provides the low-level function \function{.Tcl} for direct
access to the \TCL\/ interpreter:
<<>>=
library(tcltk)
.Tcl("set x {some text}")               # assignment
.Tcl("puts $x")                         # prints to stdout
@ 

%% must hard code this, as output isn't printed
\begin{Soutput}
some text
\end{Soutput}

<<>>=
.Tcl("string length $x")                # call a command
@ 

the \dfn{\function{.Tcl}} function simply sends a command as a text
string to the \TCL\/ interpreter and returns the result as an object
of class \dfn{\class{tclObj}} (cf. \code{?.Tcl}).  The \function{.Tcl}
function can be used to read in \TCL\/ scripts as with
\code{.Tcl("source filename")}. This allowing arbitrary \TCL\/ scripts
to run within an \R\/ session. \TCL\/ packages may be read in with
\function{tclRequire}.



The \class{tclObj} objects print with the leading \code{<Tcl>}. The string representation
of objects of class \class{tclObj} is returned by \function{tclvalue}
or by coercion through the \function{as.character} function. They
differ in how they treat spaces and new lines.  Conversion to numeric
values is also possible through \code{as.numeric}, but conversion to
logical requires two steps as only modes \code{character},
\code{double} or \code{integer} are stored. In general though,
conversion of complicated \TCL\/ expressions is not supported.

To simplify coercion to logical, we define a new method:
<<>>=
as.logical.tclObj <- function(x, ...) as.logical(as.numeric(x))
@ 


The \TK\/ extensions to \TCL\/ have a complicated command structure,
and thankfully, \pkg{tcltk} provides some more conveniently named
functions. To illustrate, the \TCL\/ command to set the text value for
a label object (\code{.label}) would look like
\begin{verbatim}
% .label configure -text "new text"
\end{verbatim}
The \pkg{tcltk} provides a corresponding function
\code{tkconfigure}. The above would be done as (assuming \code{l} is a
label object):

<<echo=FALSE>>=
## set up label for Sweave below. Not shown
w <- tktoplevel()
l <- ttklabel(w)
tkpack(l)
@ 

<<>>=
tkconfigure(l, text="new text")
@ 


% Although the \TCL\/ statement appears to have the object-oriented form
% of ``object method arguments,'' behind the scenes \TCL\/ creates a
% command with the same name as the widget with \code{configure} as a
% subcommand. This is followed by options passed in using the form
% \texttt{-key value}.  


The \TK\/ API for \code{ttklabel}'s \code{configure} subcommand is

\begin{quotation}
  \textit{pathName} \textbf{configure} \textit{?option? ?value option value ...?}
\end{quotation}

The \textit{pathName} is the ID of the label widget. This can be found
from the object \code{l} above, in \code{l\$ID}, or in some cases is a
return value of some other command call.  In the \TK\/ documentation
paired question marks indicate optional values. In this case, one can
specify nothing, returning a list of all options; just an option, to
query the configured value; the option with a value, to modify the
option; and possibly do more than one at at time.  For commands such
as \code{configure}, there will usually correspond a function in
\R\/ of the same name with a \code{tk} prefix, as in this case
\function{tkconfigure}.~\footnote{The package \pkg{tcltk} was written before
namespaces were implemented in \R, so the ``tk'' prefix serves that role.}

To make consulting the \TK\/ manual pages easier in the text we would
describe the configure subcommand as
\subcommanda{configure}{ttklabel}{[options]}. (The \R\/ manual pages
simply redirect you to the original \TK\/ documentation, so
understanding this is important for reading the API.) However, if such
a function shortcut is present, we will use the shortcut when we
illustrate code. 

Some subcommands have further subcommands. An example
is to set the selection. In the \R\/ function, the second command is
appended with a dot, as in \code{tkselection.set}. (There are a few
necessary exceptions to this.)

\paragraph{The tcl function} Within \pkg{tcltk}, the \function{tkconfigure} function is defined by

\begin{Sinput}
function(widget, ...) tcl(widget, "configure", ...)
\end{Sinput}

The \dfn{\function{tcl}} function is the workhorse used to piece
together \TCL\/ commands, call the interpreter, and then return an
object of class \code{tclObj}.  Behind the scenes it turns an \R\/
object, \code{widget}, into the \textit{pathName} above (using its ID
component). It converts \R\/ \code{key=value} pairs into \code{-key
  value} options for \TCL. As named arguments are only for the
\code{-key value} expansion, we follow the \TCL\/ language and call
the arguments ``options'' in the following. Finally, it adjusts any
callback functions. The \function{tcl} function uses position to
create its command. The order of the subcommands needs to match that
of the \TK\/ API, so although it is true that often the \R\/ object is
first, this is not always the case.

\begin{figure}
  \centering
\begin{verbatim}
          tcl(widget, subcommand, key=value, callback)
             /            |           |           \
          widget$ID  subcommand   -key value   makeCallback
\end{verbatim}
  \caption{How the \code{tcl} function maps its arguments}
  \label{fig:tcl-function-map}
\end{figure}






%% constructors

\section{Constructors}
\label{sec:tcltk:constructors}

In this Chapter, we will stick to a few basic widgets: labels and
buttons; and top-level containers to illustrate the basic usage of
\pkg{tcltk}, leaving for later more detail on containers and widgets.

Unlike \GTK, say, the construction of widgets in \pkg{tcltk} is linked
to the widget hierarchy. \TK\/ widgets are constructed as children of
a parent container with the parent specified to the constructor. When
the \TK\/ shell, wish, is used or the \TK\/ package is loaded through
the \TCL\/ command \code{package require Tk}, a top level window named
``\code{.}'' is created. In the variable name \code{.label}, from
above, the dot refers to the top level window.  In \pkg{tcltk} a
top-level window is created separately through the
\constructor{tktoplevel} constructor, as with
<<>>=
w <- tktoplevel()
@ 

Top-level windows will be explained in more detail in
Chapter~\ref{sec:tcltk:basic-containers}. For now, we just use one to
be a parent container for a label widget. Like all constructors but
the one for toplevel windows, the label constructor
(\constructor{ttklabel}) requires a specification of the parent
container followed by any other options that are desired. A typical
invocation would look like:
<<>>=
l <- ttklabel(w, text="label text")
@ 

To see the label, we can pack it into the toplevel window, which was
used as its parent at construction.
<<>>=
tkpack(l)
@ 

\paragraph{Options}
The first argument of a widget constructor is the parent container,
subsequent arguments are used to specify the options for the
constructor given as \code{key=value} pairs. The \TK\/ API lists these
options along with their description.

For a simple label, the following options are possible: \code{anchor},
\code{background}, \code{font}, \code{foreground}, \code{justify},
\code{padding}, \code{relief}, \code{text}, and \code{wraplength}.
This is in addition to the standard options \code{class},
\code{compound}, \code{cursor}, \code{image}, \code{state},
\code{style}, \code{takefocus}, \code{text}, \code{textvariable},
\code{underline}, and \code{width}. (Although clearly lengthy, this
list is significantly reduced from the options for \code{tklabel}
where options for the many style properties are also included.)

Many of the options are clear from their name.  The main option,
\code{text}, takes a character string. The label will be multiline if
this contains new line characters.  The \argument{padding}{ttklabel}
argument allows the specification of space in pixels between the text
of the label and the widget boundary. This may be set as four values
\code{c(left, top, right, bottom)}, or fewer, with \code{bottom}
defaulting to \code{top}, \code{right} to \code{left} and \code{top}
to \code{left}. The \argument{relief}{ttklabel} argument specifies how
a 3-d effect around the label should look, if specified. Possible
values are \qcode{flat}, \qcode{groove}, \qcode{raised},
\qcode{ridge}, \qcode{solid}, or \qcode{sunken}.

\paragraph{The functions tkconfigure, tkcget}

Option values may be set through the constructor, or adjusted
afterwards by \function{tkconfigure}. A listing (in \TCL\/ code) of possible options
that can be adjusted may be seen by calling \function{tkconfigure}
with just the widget as an argument.

<<>>=
head(as.character(tkconfigure(l)))      # first 6 only
@ 

The \function{tkcget} function returns the value of an
option (again as a \code{tclObj} object). The option can be specified
two different ways. Either using the \TK\/ style of a leading dash or
using the \R{} convention that \code{NULL} values mean to return the value,
and not set it.


<<>>=
tkcget(l, "-text")                      # retrieve text property
tkcget(l, text=NULL)                    # alternate syntax
@ 

\paragraph{Coercion to character}
As mentioned, the \code{tclObj} objects can be coerced to character class two ways.
The conversion through \code{as.character} breaks the return value along whitespace:
<<>>=
as.character(tkcget(l, text=NULL))
@ 
%
Whereas, conversion by the \function{tclvalue} function does not:
<<>>=
tclvalue(tkcget(l, text=NULL))
@ 
%


\paragraph{Buttons}
Buttons are constructed using the \constructor{ttkbutton} constructor.
<<>>=
b <- ttkbutton(w, text="click me", 
               command=function() print("thanks"))
@ 

Buttons and labels share many of the same options. However, in
addition, buttons have a \argument{command}{ttkbutton} option to
specify a callback for when the button is invoked. Buttons may be
invoked by clicking and releasing the mouse on the button, by pressing
the space bar when the button has the focus or by calling the
\subcommand{invoke} subcommand. In the above example, clicking on the
button will call the function causing a simple message to be printed. More on callbacks in \pkg{tcltk}
will be explained in Section~\ref{sec:tcltk:callbacks}.

\paragraph{tkwidget}
Constructors call the \function{tkwidget} function which returns an
object of class \code{tkwin}. (In \TK\/ the term ``window'' is used to
refer to the drawn widget and not just a top-level window)

<<str>>=
str(b)
@ 

The returned widget objects are lists with two components: an ID and an
environment. The \code{ID} component keeps a unique ID of the
constructed widget. This is a character string, such as ``.1.2.1''
coming from the the widget hierarchy of the object. This value is
generated behind the scenes by the \pkg{tcltk} package using numeric
values to keep track of the hierarchy. The \code{env} component
contains an environment that keeps a count of the subwindows, the parent
window and any callback functions. This helps ensure that any copies
of the widget refer to the same object~\citep{Dalgaard-DSC}. As the
construction of a new widget requires the \code{ID} and environment of
its parent, the first argument to \function{tkwidget}, \code{parent},
must be an \R\/ \TK\/ object, not simply its character ID, as is
possible for the \function{tcl} function.

%%The latter is useful in
%%a callback, as only the ID may be known to the callback function.


\paragraph{State of themed widgets}

The themed widgets (those with a \code{ttk} constructor) have a state
to determine which style is to be applied when painting the
widget. These states can be adjusted through the \code{state} command
and queried with the \code{instate} command. For example, to see if
button widget \code{b} has the focus we have:
<<has-focus>>=
as.logical(tcl(b, "instate", "focus"))
@ 
To set a widget to be not sensitive to user input we have:
<<>>=
tcl(b, "state", "disabled")             # not sensitive
@ 
The states are bits and can be negated by prefacing the value with \code{!}:
<<>>=
tcl(b, "state", "!disabled")            # sensitive again
@ 

The full list of states is in the manual page for \code{ttk::widget}.

\subsection{Geometry managers}
\label{sec:tcltk:overview:geometry-managers}

As with \Qt, when a new widget is constructed it is not automatically
mapped. \TK\/ uses geometry managers to specify how the widget will be
drawn within the parent container. We will discuss two such geometry
managers in Chapter~\ref{sec:tcltk:basic-containers}, but for now, we note
that the simplest way to view a widget in its parent window is through
\function{tkpack}, as in:
<<>>=
tkpack(b)
@ 

This command packs the widgets into the top-level window (the parent
in this case) in a box-like manner. Unlike \GTK\/ more than one child
can be packed into a top-level window, although we don't demonstrate
this further, as later we will use an intermediate \function{ttkframe}
box container so that themes are properly displayed.

\subsection{\TCL\/ variables}
\label{sec:tcltk:overview:textvariables}


%% textvariables
For the button and label widgets, there is an option
\code{textvariable} to specify a \TCL\/ variable to store the text
property. These variables are dynamically bound to the widget, so that
changes to the variable are propagated to the GUI. (The \TCL\/
variable is a model and the widget a view of the model.)  Other
widgets allow for tcl variables to be used for this and other purposes
The basic functions involved are \function{tclVar} to create a \TCL\/
variable, \function{tclvalue} to get the assigned value and
\function{tclvalue\ASSIGN} to modify the value.

<<>>=
textvar <- tclVar("another label")
l2 <- ttklabel(w, textvariable=textvar)
tkpack(l2)
tclvalue(textvar)
tclvalue(textvar) <- "new text"         
@ 

\TCL\/ variables have a unique identifier, returned by \function{as.character}:
<<>>=
as.character(textvar)
@ 

The advantages of \TCL\/ variables are like those of the MVC paradigm
-- a single data source can have its changes propagated to several
widgets automatically. If the same text is to appear in different
places, their usage is recommended.  One disadvantage, is that in a
callback, the variable is not passed to the callback and must be found
through \R's scoping rules. (In Section~\ref{sec:tcltk:checkboxes} we
show a workaround.)

The package also provides the function \dfn{\function{tclArray}} to
store an array of \TCL\/ variables. The usual list methods \code{[[}
and \code{\$} and their forms for assignment are available for arrays,
but values are only referred to by name, not index:

<<tclVarExample, echo=FALSE, eval=FALSE>>=
x <- tclVar(1)
print(x)                                # a tclVar object
tclvalue(x)                             # internal name
as.numeric(tclvalue(x))                 # get value then coerce
@ 


<<tclArrayExample>>=
x <- tclArray()                         # no init
x$one <- 1; x[[2]] <- 2                 # $<- and [[<-
x[[1]]                                  # no match by index
names(x)                                # the stored names
x[['2']]                                # match by name, not index
@ 


\subsection{Window properties and state: \code{tkwinfo}}
\label{sec:tcltk:overview:widget-properties}

For a widget, the function \function{tkcget} is used to get the values
of its options. If it is a themed widget, the \code{instate} command
returns its state values. Finally, there is also \function{tkwinfo} to
return the properties of the containing window of the widget.  When
widgets are mapped, the ``window'' they are rendered to has properties,
such as a class or size. If the API is of the form

\begin{quotation}
\texttt{winfo} \textbf{subcommand\_name} \textit{window}  
\end{quotation}
the specification to \function{tkwinfo} is in the same order (the
widget is not the first argument). For instance, the
class~\footnote{The class of a widget is more like a attribute and should
  not be confused with class in the object oriented sense. The class
  is used internally for bindings and styles.} of a label
is returned by the \texttt{class} subcommand:

<<WindowClass>>=
tkwinfo("class", l)
@ 
%

The window, in this example \texttt{l}, can be specified as an \R\/
object, or by its character ID. This is useful, as the return value of
some functions is the ID. For instance, the \texttt{children}
subcommand returns IDs. Below the \code{as.character} function will
coerce these into a vector of IDs.

<<classOfChildren>>=
(children <- tkwinfo("children", w))
sapply(as.character(children), function(i) tkwinfo("class", i))
@ 

There are several possible subcommands, here we list a few. The
\subcommand{geometry}{tkwinfo} sub command returns the location and
size of the widgets' window in the form \code{width x height + x + y};
the sub commands \subcommand{height}{tkwinfo},
\subcommand{width}{tkwinfo}, \subcommand{x}{tkwinfo}, or
\subcommand{y}{tkwinfo} can be used to return just those parts. The
\subcommand{exists}{tkwinfo} command returns 1 (\code{TRUE}) if the
window exists and 0 otherwise; the \subcommand{ismapped}{tkwinfo} sub
command returns 1 or 0 if the window is currently mapped (drawn); the
\subcommand{viewable}{tkwinfo} sub command is similar, only it checks
that all parent windows are also mapped.  For traversing the widget
hierarchy, one has available the \subcommand{parent}{tkwinfo} sub
command which returns the immediate parent of the component,
\subcommand{toplevel}{tkwinfo} which returns the ID of the top-level
window, and \subcommand{children}{tkwinfo} which returns the IDs of
all the immediate child components, if the object is a container, such
as a top-level window.


\subsection{Themes}
\label{sec:tcltk:overview:themes}


%% themes -- ttkframe
As mentioned, the newer themed widgets have a style that determines
how they are drawn based on the state of the widget. The separation of
style properties from the widget, as opposed to having these set for
each construction of a widget, makes it much easier to change the look
of a GUI and easier to maintain the code. A collection of styles makes
up a theme. The available themes depend on the system. The default
theme allows the GUI to have the native look and feel of the operating
system. (This was definitely not the case for the older \TK\/
widgets.) There is no built in command to return the theme, so we use
\code{.Tcl} to call the appropriate \TCL\/ command. The \code{names}
sub command will return the available theme:

<<>>=
.Tcl("ttk::style theme names")
@ 
%
The \code{use} sub command is used to set the theme:
<<>>=
@ 
.Tcl("ttk::style theme use clam")
@ 

The writing of themes will not be covered, but in
Example~\ref{ex-tcltk-toolbar} we show how to create a new style for a
button. This topic is covered in some detail in the \Tk\/ tutorial by Roseman.
\\

The example we have shown so far, would not look quite right for some
operating systems, as the toplevel window is not a themed widget
(Figure~\ref{fig:tcltk-frame-noframe-example}). To work around that, a
\function{ttkframe} widget is usually used to hold the child
components of the top-level window. The following shows how to place a
frame inside the window, with some arguments to be explained later
that allow it to act reasonably if the window is resized.

\begin{figure}
  \centering
  \includegraphics[width=.4\textwidth]{fig-tcltk-no-frame}
  \includegraphics[width=.4\textwidth]{fig-tcltk-with-frame}
  \caption{Similar GUIs, one using a frame within the toplevel window
    (right one) and one without. The one without has widgets whose background does not match the toplevel window.}
  \label{fig:tcltk-frame-noframe-example}
\end{figure}


<<no-frame, echo=FALSE>>=
w <- tktoplevel()
tkwm.title(w, "No frame")
l <- ttklabel(w, text="new text")
tkpack(l)

b <- ttkbutton(w, text="click me", 
               command=function() print("thanks"))
tkpack(b)

textvar <- tclVar("another label")
l2 <- ttklabel(w, textvariable=textvar)
tkpack(l2)
@ 

<<with-frame, echo=FALSE>>=
w <- tktoplevel()
tkwm.title(w, "With frame")
w <- ttkframe(w, padding=c(3,3,12,12))  # Some breathing room
tkpack(w, expand=TRUE, fill="both")     # For window expansion
l <- ttklabel(w, text="new text")
tkpack(l)

b <- ttkbutton(w, text="click me", 
               command=function() print("thanks"))
tkpack(b)

textvar <- tclVar("another label")
l2 <- ttklabel(w, textvariable=textvar)
tkpack(l2)
@ 

<<UseFrameToTheme>>=
w <- tktoplevel()
f <- ttkframe(w, padding=c(3,3,12,12))  # Some breathing room
tkpack(f, expand=TRUE, fill="both")     # For window expansion
l <- ttklabel(f,  text="label")         # some widget
tkpack(l)
@ 


\subsection{Colors and fonts}
\label{sec:tcltk:overview:colors-fonts}
Colors and fonts are typically specified through a theme, but at times
it is desirable to customize the preset ones.

The label color can be set through its \code{foreground}
property. Colors can be specified by name -- for common colors -- or
by hex RGB values which are common in web programming.
<<>>=
tkconfigure(l, foreground="red")
tkconfigure(l, foreground="#00aa00")
@ 

To find the hex RGB value, one can use the \code{rgb} function to
create RGB values from intensities in $[0,1]$.  The \R\/ function
\function{col2rgb} can translate a named color into RGB values. The
\code{as.hexmode} function will display an integer in hexadecimal
notation.

Not all widgets have a \code{foreground} option.  In
Example~\ref{ex:tcltk-entry-initial-message} we show how to modify a
style to change the text color in an entry widget.

%% fonts
\paragraph{Fonts}
Fonts are more involved than colors. \TK\/ version 8.5 made it more
difficult to change font properties of individual widgets. This
following the practice of centralizing style options for consistency,
ease of maintaining code and ease of theming.  To set a font for a
label, rather than specifying the font properties, one configures the
\code{font} attribute using a pre-defined font name, such as
<<>>=
tkconfigure(l, font="TkFixedFont")
@ 

The \qcode{TkFixedFont} value is one of the standard font names, in
this case to use a fixed-width font. A complete list of the standard
names is provided in Table~\ref{tab:tcltk-std-fonts}. Each theme sets
these defaults accordingly.
<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\code{TkDefaultFont}","Default font for all GUI items not otherwise specified"),
            c("\\code{TkTextFont}","Font for text widgets"),
            c("\\code{TkFixedFont}","Fixed-width font"),
            c("\\code{TkMenuFont}","Menu bar fonts"),
            c("\\code{TkHeadingFont}","Font for column headings"),
            c("\\code{TkCaptionFont}","Caption font (dialogs)"),
            c("\\code{TkSmallCaptionFont}","Smaller caption font"),
            c("\\code{TkIconFont}","Icon and text font")
            )
colnames(df) <- c("Standard font name", "Description")
cat(booktabs(df, 
             caption="Standard font names defined by a theme.",
             label="tab:tcltk-std-fonts"))
@ 
%
\paragraph{tkfont.create}
The \function{tkfont.create} function can be used to create a new font, as with the following commands:
<<>>=
tkfont.create("ourFont", family="Helvetica", size=12, 
              weight="bold")
tkconfigure(l, font="ourFont")
@ 

As font families are system dependent, only \qcode{Courier},
\qcode{Times} and \qcode{Helvetica} are guaranteed to be there. A list
of an installation's available font families is returned by the
function \function{tkfont.families}.
Figure~\ref{fig:fig-tcltk-all-fonts} shows a display of some available
font families on a Mac OS X machine.  See
Example~\ref{ex:tcltk-scrollable-frame} for details.

The arguments for \function{tkfont.create} are optional. The
\argument{size}{tkfont.create} argument specifies the pixel size. The
\argument{weight}{tkfont.create} argument can be used to specify
\qcode{bold} or \qcode{normal}.  Additionally, a
\argument{slant}{tkfont.create} argument can be used to specify either
\qcode{roman} (normal) or \qcode{italic}. Finally,
\argument{underline}{tkfont.create} and
\argument{overstrike}{tkfont.create} can be set with a \code{TRUE} or
\code{FALSE} value.


\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-tcltk-all-fonts.png}
  \caption{A scrollable frame widget (cf. Example~\ref{ex:tcltk-scrollable-frame}) showing the available fonts on a system.}
  \label{fig:fig-tcltk-all-fonts}
\end{figure}


\paragraph{Font metrics}
The average character size is important in setting the width and
height of some components. (For example the text widget specifies its
height in lines, not pixels.) These sizes can be found using the
\function{tkfont.measure} and \function{tkfont.metrics} functions as
follows:
<<fontSizes>>=
chars <- c(0:9,LETTERS, letters)
tmp <- tkfont.measure("TkTextFont",paste(chars,collapse=""))
fontWidth <- ceiling(as.numeric(tclvalue(tmp))/length(chars))
tmp <- tkfont.metrics("TkTextFont","linespace"=NULL)
fontHeight <- as.numeric(tclvalue(tmp))
c(width=fontWidth, height=fontHeight)
@ 


\subsection{Images}
\label{sec:tcltk:overview:images}


Many \pkg{tcltk} widgets, including both labels and buttons, can show
images. In these cases, either with or without an accompanying text
label. Constructing images to display is similar to constructing new
fonts, in that a new image object is created and can be reused by
various widgets. Images are created by the \function{tkimage.create}
function. 

The following command shows how an image object can be made from the
file \code{tclp.gif} in the current directory:

<<>>=
tkimage.create("photo", "::img::tclLogo", file = "tclp.gif")
@ 


The first argument, \qcode{photo} specifies that a full color image is
being used. (This option could also be \qcode{bitmap} but that is more
a legacy option.) The second argument specifies the name of the
object. We follow the advice of the \TK\/ manual and preface the name
with \code{::img::} so that we don't inadvertently overwrite any
existing \TCL\/ commands. (The command \code{tcl("image", "names")}
will return all defined image names.) The third argument
\argument{file}{tkimage.create} specifies the graphic file. The basic
\TK\/ \code{image} command can only show GIF and PPM/PNM
images. Unfortunately, not many \R\/ devices output in these
formats. (The \code{GDD} device driver can.) One may need system
utilities to convert to the allowable formats or install add-on \TCL\/
packages that can display other formats.

To use the image, one specified the image name to the
\option{image}{ttklabel} option:
<<>>=
l <- ttklabel(w, image="::img::tclLogo", text="logo text", 
              compound = "top")
@ 
<<echo=FALSE>>=
tkpack(l)
@ 

By default the text will not show. The \argument{compound}{ttklabel}
argument takes a value of either \qcode{text}, \qcode{image}
(default), \qcode{center}, \qcode{top}, \qcode{left}, \qcode{bottom},
or \qcode{right} specifying where the label is in relation to the
text.

\paragraph{Image manipulation}
Once an image is created, there are several options to manipulate the
image. These are found in the \TK\/ man page for \code{photo}, not
\code{image}. For instance, to change the palette so that instead of
\code{fullcolor} only 16 shades of gray are used to display the icon,
one could issue the command
<<>>=
tkconfigure("::img::tclLogo", palette=16)
@ 
<<echo=FALSE>>=
## redo changing of palette
tkconfigure("::img::tclLogo", palette="fullcolor")
@ 

%% changed to active, !active
% Another useful manipulation to draw attention to an image is to change
% the \code{gamma} value when something happens, such as a mouse-over
% event (cf. Example~\ref{ex-tcltk-toolbar}).



\section{Events and Callbacks}
\label{sec:tcltk:overview:events-callbacks}

The button widget has the \code{command} option for assigning a
callback which is invoked (among other ways) when the user clicks the
mouse on the button. In addition to such commands, one may use
\function{tkbind} to invoke callbacks in response to many other events
that the user may initiate.

The basic call is \code{tkbind(tag, event, script)}. 

%% (Unlike \pkg{RGtk2}, that the event triggers a widget to emit a signal that a callback listens for is notneeded)

\subsection{The tag}

The \code{tag} object is more general than just a widget, or its
id. It can be:

\begin{description}
\item[the name of a widget,] in which case the command will be bound to that widget;
\item[a top-level window,] in which case the command will be be bound
  to the event for the window and all its internal widgets;
\item[a class of widget,] such as \qcode{TButton}, in which case all
  such widgets will get the binding; or
\item[the value \qcode{all},] in which case all widgets in the
  application will get the binding.
\end{description}

This flexibility makes it easy to create keyboard accelerators. For
example, the following mimics the linux shortcut \code{Control-q} to
close a window.
<<>>=
w <- tktoplevel()
l <- ttkbutton(w, text="Some widget with the focus"); tkpack(l)
tkbind(w, "<Control-q>", function() tkdestroy(w))
@ 

By binding to the top-level window, we ensure that no matter which
widget has the focus the command will be invoked by the keyboard shortcut.


\subsection{Events}
\label{sec:tcltk:events}

%% possible events
%% keys
The possible events (or sequences of events) vary from widget to
widget. The events can be specified in a few ways. 

The example below uses two types of events. A single key press event, such as
``C'' or ``O'' can invoke a command and is specified by just its
character. Whereas, the event of pressing the return key is specified
using \code{\event{Return}}. In the following we bind the key presses to the
top-level window and the return event to any button with the default
class \code{TButton}.

<<>>=
w <- tktoplevel()
l <- ttklabel(w, text="Click Ok for a message")
b1 <- ttkbutton(w, text="Cancel", command=function() tkdestroy(w))
b2 <- ttkbutton(w, text="Ok", command=function() print("initiate an action"))
sapply(list(l,b1,b2), tkpack)
tkbind(w, "C", function() tcl(b1, "invoke"))
tkconfigure(b1, underline=0)
#
tkbind(w, "O", function() tcl(b1, "invoke"))
tkconfigure(b2, underline=0)
tkfocus(b2)
#
tkbind("TButton", "<Return>", function(W) {
  tcl(W, "invoke")
})

@ 
%
We modified our buttons using the \code{underline} option to give the
user an indication that the ``C'' and ``O'' keys will initiate some
action. Out callbacks simply cause the appropriate button to
\code{invoke} their command. The latter one uses a percent
substitution (below), which is how \TK\/ passes along information
about the event to the callback. 

%% tkbind(widget,''<modifier-modifier-type-detail'>'', command)
\paragraph{Events with modifiers}
More complicated events can be described with the pattern

\begin{quotation}
\code{\Event{modifier-modifier-type-detail}}.   
\end{quotation}

Examples of a ``type'' are \code{\Event{KeyPress}} or
\code{\Event{ButtonPress}}. The event \code{\Event{Control-q}}, used
above, has the type \code{q} and modifier \code{Control}. Whereas
\code{\Event{Double-Button-1}} also has the detail \code{1}. The full
list of modifiers and types are described in the man page for
\code{bind}. Some familiar modifiers are \code{Control}, \code{Alt},
\code{Button1} (also \code{B1}), \code{Double} and \code{Triple}. The
event types are the standard X event types along with some
abbreviations. These are also listed in the \code{bind} man page. Some
commonly used ones are \code{Return} (as above), \code{ButtonPress},
\code{ButtonRelease}, \code{KeyPress}, \code{KeyRelease},
\code{FocusIn}, and \code{FocusOut}.

\paragraph{Window manager events}
Some events are based on window manager events. The \code{\Event{Configure}}
event happens when a component is resized. The \code{\Event{Map}} and
\code{\Event{Unmap}} events happen when a component is drawn or undrawn.

\paragraph{Virtual events}
Finally, the event may be a ``virtual event.'' These are represented
with \code{\VirtualEvent{EventName}}. There are predefined virtual
events listed in the \code{event} man page. These include
\code{\VirtualEvent{MenuSelect}} when working with menus,
\code{\VirtualEvent{Modified}} for text widgets,
\code{\VirtualEvent{Selection}} for text widgets, and
\code{\VirtualEvent{Cut}}, \code{\VirtualEvent{Copy}} and
\code{\VirtualEvent{Paste}} for working with the clipboard. New
virtual events can be produced with the \code{tkevent.add}
function. This takes at least two arguments, an event name and a
sequence that will initiate that event. The \code{event} man page has
these examples coming from the Emacs world:
<<>>=
 tkevent.add("<<Paste>>", "<Control-y>")
 tkevent.add("<<Save>>", "<Control-x><Control-s>")
@ 
%
In addition to virtual events occurring when the sequence is performed,
the \function{tkevent.generate} can be used to force an event for a
widget. This function requires a widget (or its ID) and the event
name. Other options can be used to specify substitution values,
described below. To illustrate, this command will generate the
\code{\VirtualEvent{Save}} event for the button \code{b}:
<<>>=
tkevent.generate(b, "<<Save>>")
@ 
%



\subsection{Callbacks}
\label{sec:tcltk:callbacks}
%% \XXX{ use of tcl(``eval'',''break'') to avoid calling subsequent callbacks} -- doesn't work
%% See PD's comments here on callbacks http://article.gmane.org/gmane.comp.lang.r.general/136705

The \pkg{tcltk} package implements callbacks in a manner different
from \TK, as the callback functions are \R\/ functions, not \TK\/
procedures. This is much more convenient, but introduces some slight
differences.  In \pkg{tcltk} these callbacks can be expressions
(unevaluated calls) or functions. We use only the latter, for more
clarity. The basic callback function need not have any arguments and
those that do only have percent substitutions passed in.


%% scope of callback?
The callback's return value is generally not important, although we
shall see that within the validation framework of entry widgets
(Section~\ref{sec:tcltk:entry-widgets}) it can matter.~\footnote{The
  difference in processing of return values can make porting some
  \Tk\/ code to \pkg{tcltk} difficult. For example, the \code{break}
  command to stop a chain of call backs does not work.}



In \pkg{tcltk} only one callback can be associated with a widget and
event through the call
\code{tkbind(widget,event,callback)}. (Although, callbacks for the
widget associated with classes or toplevel windows can differ.)
Calling \code{tkbind} another time will replace the callback. To
remove a callback, simply assign a new callback which does
nothing.~\footnote{This event handling can prevent being able to port
  some \Tk\/ code into \pkg{tcltk}. In those cases, one may consider
  sourcing in \Tcl\/ code directly.}



\subsection{\% Substitutions}
\label{sec:tcltk-percent-substitutions}

One can not pass arbitrary user data to a callback, rather such values
must be found through \R's usual scoping rules. However, \TK\/
provides a mechanism called \defn{percent substitution} to pass
information about the event to callbacks bound to the event. The basic
idea is that in the \TCL\/ callback expressions of the type
\code{\%X}, for different characters \code{X}, will be replaced by values
coming from the event. In \pkg{tcltk}, if the callback function has an
argument \code{X}, then that variable will correspond to the value
specified by \code{\%X}. The complete list of substitutions is in the
\code{bind} man page. Some useful ones are \code{x} and \code{X} to
specify the relative or absolute $x$-postion of a mouse click (the
difference can be found through the \code{rootx} property of a
widget), \code{y} and \code{Y} for the $y$-position, \code{k} and
\code{K} for the keycode (ASCII) and key symbol of a
\code{\Event{KeyPress}} event, and \code{W} to refer to the ID of the
widget that signaled the event the callback is bound
to. 

The following trivial example illustrates, whereas
Example~\ref{ex-tcltk-dnd} will put these to use.

<<>>=
w <- tktoplevel()
b <- ttkbutton(w, text="Click me to record the x,y position")
tkpack(b)
tkbind(b, "<ButtonPress-1>", function(W, x,y, X, Y) {
  print(W)                              # an ID
  print(c(x, X))                        # character class
  print(c(y, Y))
  })
@ 


<<ReturnValueDoesNotStopPropogation, eval=FALSE, echo=FALSE>>=
## This example illustrates how handlers are different in tcltk than Tk
## In this case we can't break out of the chain of handlers called in tcltk
library(tcltk)
w <- tktoplevel()
b <- ttkbutton(w, text="click me", command = function() {
  ## default command: bind Button <1> {tk::ButtonDown %W}
  print("hi")
})

tkpack(b)

tkbind(b, "<Button-1>", function() {
  print("hello")
  .Tcl("return -code break") ## doesn't suppress call of other
})

## in Tcl returning -code break suppresses call to next handler
.Tcl("toplevel .w")
.Tcl("wm title .w {title}")
.Tcl("button .w.b -text {Click me} -command {puts hi}")
.Tcl("pack .w.b")
#.Tcl("bind .w.b <Button-1> {puts hello}")
.Tcl("bind .w.b <Button-1> {puts hello; return -code break}") ## no hi
@ 


%% After
\paragraph{The after command}
The \TCL\/ command \code{after} will execute a command after a certain
delay (specified in milliseconds as an integer) while not interrupting
the control flow while it waits for its delay. The function is called
in a manner like:
\begin{Schunk}
  \begin{Sinput}
    ID <- tcl("after", 1000, function() print("1 second passed"))    
  \end{Sinput}
\end{Schunk}
The ID returned by \code{after} may be used to \code{cancel} the
command before it executes. To execute a command repeatedly, can be
done along the lines of:
<<eval=FALSE>>=
afterID <- ""
someFlag <- TRUE
repeatCall <- function(ms=100, f, w) {
  afterID <<- tcl("after", ms, function() {
    if(someFlag) {                      
      f()
      afterID <<- repeatCall(ms, f, w)
    }  else {
      tcl("after", "cancel", afterID)
    }
  })
}
repeatCall(100, function() print("Running. Set someFlag <- FALSE to stop."), w)
@ 
%


\begin{example}{Drag and Drop}{ex-tcltk-dnd}
  \SweaveInput{ex-tcltk-dnd.Rnw}
\end{example}


