This example shows how to use  a window, frames,  labels, buttons,
icons, packing and bindings to create a non-modal dialog. 

\begin{figure}
  \centering
  \includegraphics[width=.4\textwidth]{fig-tcltk-simple-dialog.png}
  \caption{Example of a simple dialog}
  \label{fig:fig-tcltk-simple-dialog}
\end{figure}

<<echo=FALSE>>=
## example of  simple non-modal dialog
## much taken from msgbox.tcl in tk source

library(tcltk)
@
Although not written as a function, we set aside the values that would
be passed in were it.
<<results=hide>>=
title <- "message dialog"
message <- "Do you like tcltk so far?"
parent <- NULL
tkimage.create("photo", "::img::tclLogo", 
               file = system.file("images","tclp.gif",
                 package="ProgGUIinR"))
@ 

The main top-level window is given a title, then withdrawn while
the GUI is created. 
<<>>=
w <- tktoplevel(); tkwm.title(w, title)
tkwm.state(w, "withdrawn")
f <- ttkframe(w,  padding=c(3, 3, 12, 12))
tkpack(f, expand=TRUE, fill="both")
@ 
As usual, we added a frame so that any themes are respected.

If the parent is non-null and is viewable, then the dialog is made
transient to a parent, The parent need not be a top-level window, so
\function{tkwinfo} if used to find the parent's top-level window. For
Mac OS X, we use the \code{notify} attribute to bounce the dock icon
until the mouse enters the window area.

<<>>=
if(!is.null(parent)) {
  parentWin <- tkwinfo("toplevel", parent)
  if(as.logical(tkwinfo("viewable", parentWin))) {
    tkwm.transient(w, parent)
    if(as.character(tcl("tk", "windowingsystem")) == "aqua") {
      tcl("wm","attributes",parentWin, notify=TRUE) # bounce
      tkbind(parentWin,"<Enter>", function() 
             tcl("wm","attributes",parentWin, notify=FALSE)) #stop
    }
  }
}
@ 

We will use a standard layout for our dialog with an icon on the left,
a message and buttons on the right. We pack the icon into the left side of the frame,
<<>>=
l <- ttklabel(f, image="::img::tclLogo", padding=5) # recycle
tkpack(l,side="left")
@ 

A nested frame will be used to layout the message area and button area. Since the \function{tkpack} default is to pack in top to bottom, no \code{side} specification is made.
<<>>=
f1 <- ttkframe(f)
tkpack(f1, expand=TRUE, fill="both")
#
m <- ttklabel(f1, text=message)
tkpack(m, expand=TRUE, fill="both")
@ 

The buttons have their own frame, as they are layed out horizontally. 
<<>>=
f2 <- ttkframe(f1)
tkpack(f2)
@ 
%
The callback function for the OK button prints a message then destroys the window.
<<>>=
okCB <- function() {
  print("That's great")
  tkdestroy(w)
}
okButton <- ttkbutton(f2, text="OK", command=okCB)
cancelButton <- ttkbutton(f2, text="Cancel", 
                          command=function() tkdestroy(w))
#
tkpack(okButton, side="left", padx=12)  # give some space
tkpack(cancelButton)
@ 
%

As our interactive behaviour is consistent for both buttons, we make a
binding to the \code{TButton} class, not indidually. The first will
invoke the button command when the \kbd{return} key is pressed, the
latter two will highlight a button when the focus is on it.
<<>>=
tkbind("TButton", "<Return>", function(W) tcl(W, "invoke"))
tkbind("TButton", "<FocusIn>", function(W) tcl(W, "state", "active"))
tkbind("TButton", "<FocusOut>", function(W) tcl(W, "state", "!active"))
@ 
%
Now we bring the dialog back from its withdrawn state, fix the size
and set the initial focus on the OK button.
<<>>=
tkwm.state(w, "normal")
tkwm.resizable(w, FALSE, FALSE)
tkfocus(okButton)
@ 
