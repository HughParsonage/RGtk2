This example illustrates how the basic widgets can be combined to make
a dialog for gathering information to run a $t$-test. A realization is
shown in Figure~\ref{fig:fig-tcltk-t-test}.

%% Moved earlier in text
% \begin{figure}
%   \centering
%   \includegraphics[width=.75\textwidth]{fig-tcltk-t-test.png}
%   \caption{A dialog to collect values for a $t$ test. This shows
%     several of the selection widgets discussed in the chapter: a check
%     button, radio button, combo boxes, an entry widget, a scale widget
%     and a spinbox.}
%   \label{fig:fig-tcltk-t-test}
% \end{figure}

<<echo=FALSE>>=
## t.test dialog
## using basic widgets -- no entry widgets yet
library(tcltk)
@ 

<<echo=FALSE>>=
## helper functions
## not shown

getNumericVars <- function(df) {
  if(missing(df))
    return(c(""))
  ProgGUIinR:::find_vars(df, is.numeric)
}
getTwoLevelFactor <- function(df) {
  if(missing(df))
    return(c(""))
  nms <- names(df)
  ind <- sapply(df, function(i) length(levels(as.factor(i))) == 2)
  if(length(ind) > 0)
    nms[ind]
  else
    c("")
}
@ 



We will use a data store to hold the values to be passed to
\code{t.test}. For the data store, we  use an environment to hold \Tcl\/ variables.

<<dataModel>>=
### Data model
e <- new.env()
e$x <- tclVar(""); e$f <- tclVar(""); e$data <- tclVar("")
e$mu <- tclVar(0); e$alternative <- tclVar("two.sided")
e$conf.level <- tclVar(95); e$var.equal <- tclVar(FALSE)
@ 

This allows us to write a function to evaluate a $t$-test easily
enough, although we don't illustrate that.

<<echo=FALSE>>=
## We don't show the function runTTest.
## It is a bit long, as care must be taken as it isn't clear if a formula should be used.  
runTTest <- function() {
  l <- lapply(e, tclvalue)
  
  ## ugly function to run t test
  if(l$data == "" || l$x == "")
    return()

  l$data <- get(l$data, envir=.GlobalEnv)

  if(l$f != "") {
    l$formula <- formula(paste(l$x,l$f, sep="~"))
    l$x <- l$f <- NULL
    l$mu <- NULL
    l$var.equal <- as.logical(as.numeric(l$var.equal))

    TTest <- stats:::t.test.formula
  } else {
    l$x <- l$data[, l$x]
    l$f <- NULL
    l$mu = as.numeric(l$mu)
    l$var.equal <- NULL
    
    TTest <- stats:::t.test.default
  }
  l$conf.level <- as.numeric(l$conf.level)/100
  ret <- capture.output(do.call("TTest", l))
  cat(paste(ret, collapse="\n"))
}
@ 



@ 

<<notShown, echo=FALSE>>=
### GUI Our standard setup
w <- tktoplevel()
tkwm.title(w, "t-test Dialog")
f <- ttkframe(w, padding=c(3,3,12,12))
tkpack(f, expand=TRUE, fill="both")
@ 

Our layout is basic. Here we pack a label frame into the window to give the dialog a nicer look.
We will use the \code{tkgrid} geometry manager below.
<<layout>>=
lf <- ttklabelframe(f, text="t.test()", padding=10)
tkpack(lf, expand=TRUE, fill="both", padx=5, pady=5)
@ 

The grid will have four columns, with columns 0 and 2 being for labels.
We don't want the labels to expand the same way we want the widget columns to do, so we
assign different weights:
<<>>=
tkgrid.columnconfigure(lf, 0, weight=1)
tkgrid.columnconfigure(lf, 1, weight=10)
tkgrid.columnconfigure(lf, 2, weight=1)
tkgrid.columnconfigure(lf, 1, weight=10)
@ 


This helper function simplifies the task of adding a label.
<<tkgridHelper>>=
putLabel <- function(parent, text, row, column) {
  label <- ttklabel(parent, text=text)
  tkgrid(label, row=row, column=column, sticky="e")
}
@ 
%

Our first widget will be one to select a data frame. For this, a
combo box is used, although if a large number of data frames are a
possibility, a different widget may be better suited. Also not shown are two
similar calls to create combo boxes \code{xCombo} and \code{fCombo}
which allow the user to specify parts of a formula.

<<>>=
putLabel(lf, "data:",0,0)
dataCombo <- ttkcombobox(lf, state="readonly", 
                         values=ProgGUIinR:::avail_dfs(), 
                         textvariable=e$data)
tkgrid(dataCombo, row=0, column=1, sticky="ew", padx=2)
tkfocus(dataCombo)                      # give focus
@ 

<<notShown, echo=FALSE>>=
## not shown
putLabel(lf, "x:",1,0)
xCombo <-  ttkcombobox(lf, 
                       values=getNumericVars(), textvariable=e$x)
tkgrid(xCombo, row=1, column=1, sticky="ew", padx=2)
@ 

<<notShown, echo=FALSE>>=
## not shown
putLabel(lf, "~ f:",1,2)
fCombo <-  ttkcombobox(lf, values=getTwoLevelFactor(), textvariable=e$f)
tkgrid(fCombo, row=1, column=3, sticky="ew", padx=2)
@ 

We use a \constructor{ttkentry} widget for the user to specify
a mean. For this purpose, the use is straightforward.
<<mu>>=
putLabel(lf, "mu:", 2, 0)
muCombo <-  ttkentry(lf,  textvariable=e$mu)
tkgrid(muCombo, row=2, column=1, sticky="ew", padx=2)
@ 

The selection of an alternative hypothesis is a natural choice for a
combo box or a radio button group, we use the latter.
<<echo=FALSE>>=
ttkscale <- function(parent, ...) tkwidget(parent, "ttk::scale", ...)
tkspinbox <- function(parent, ...) tkwidget(parent, "tk::spinbox", ...)
@ 
<<results=hide>>=
putLabel(lf, "alternative:", 3, 0)
rbFrame <- ttkframe(lf)
sapply(c("two.sided","less","greater"), function(i) {
  rb <- ttkradiobutton(rbFrame, variable=e$alternative, 
                       text=i, value=i)
  tkpack(rb, side="left")
})
tkgrid(rbFrame, row=3, column=1, sticky="ew", padx=2)
@ 

Here we use two widgets to specify the confidence level. The slider
is quicker to use, but less precise than the spinbox. By sharing a
text variable, the widgets are automatically synchronized.
<<>>=
putLabel(lf, "conf.level:", 3, 2)
confFrame <- ttkframe(lf)
tkgrid(confFrame, row=3, column=3, columnspan=2, 
       sticky="ew", padx=2)
##
confScale <- ttkscale(confFrame, from=75, to=100, 
                     variable=e$conf.level)
confSpin <- tkspinbox(confFrame, from=75, to=100, increment=1, 
                     textvariable=e$conf.level, width=5)
##
tkpack(confScale, expand=TRUE, fill="y", side="left")
tkpack(confSpin, side="left")
@ 

A checkbox is used to collect the logical value for \code{var.equal}:
<<>>=
putLabel(lf, "var.equal:", 4, 0)
veCheck <- ttkcheckbutton(lf, variable=e$var.equal)
tkgrid(veCheck, row=4, column=1, stick="w", padx=2)
@ 


The dialog has standard cancel and ok buttons.
<<results=hide>>=
bf <- ttkframe(f)
cancel <- ttkbutton(bf, text="cancel")
ok <- ttkbutton(bf, text="ok")
#
tkpack(bf, fill="x", padx=5, pady=5)
tkpack(ttklabel(bf, text=" "), expand=TRUE, fill="y", 
       side="left")                     # add a spring
sapply(list(cancel, ok), tkpack, side="left", padx=6)
@ 
%

For the \code{ok} button we want to gather the values and run the
function. The \code{runTTest} function does this.  We configure both
buttons, then add to the default button bindings to invoke either of the button's commands
when they have the focus and \kbd{return} is pressed.
<<>>=
tkconfigure(ok, command=runTTest)
tkconfigure(cancel, command=function() tkdestroy(w))
tkbind("TButton", "<Return>", function(W) tcl(W, "invoke"))
@ 

At this point, our GUI is complete, but we would like to have it
reflect any changes to the underlying \R\/ environment that effect its
display. A such, we define
a function, \code{updateUI}, which does two basic things: it searches for
new data frames and it adjusts the controls depending on the current
state.
<<results=hide>>=
updateUI <- function() {
  dfName <- tclvalue(e$data)
  curDfs <- ProgGUIinR:::avail_dfs()
  tkconfigure(dataCombo, values=curDfs)
  if(!dfName %in% curDfs) {
    dfName <- ""
    tclvalue(e$data) <- ""
  }

  if(dfName == "") {
    ## 3 ways to disable needed!!
    x <- list(xCombo, fCombo, muCombo,  confScale, veCheck, ok)
    sapply(x, function(W) tcl(W, "state", "disabled"))
    sapply(as.character(tkwinfo("children", rbFrame)), 
           function(W) tcl(W, "state", "disabled"))
    tkconfigure(confSpin, state="disabled")
  } else {
    ## enable univariate, ok
    sapply(list(xCombo,  muCombo, confScale, ok),
           function(W) tcl(W, "state", "!disabled"))
    sapply(as.character(tkwinfo("children", rbFrame)), 
           function(W) tcl(W, "state", "!disabled"))
    tkconfigure(confSpin, state="normal")
    
    df <- get(dfName, envir=.GlobalEnv)
    numVars <- getNumericVars(df)
    tkconfigure(xCombo, values=numVars)
    if(! tclvalue(e$x) %in% numVars)
      tclvalue(e$x) <- ""

    ## bivariate
    availFactors <- getTwoLevelFactor(df)
    sapply(list(fCombo, veCheck),
           function(W) {
             val <- if(length(availFactors)) "!" else ""
             tcl(W, "state", sprintf("%sdisabled", val))
           })
    tkconfigure(fCombo, values=availFactors)
    if(!tclvalue(e$f) %in% availFactors)
      tclvalue(e$f) <- ""
      
         }
}
updateUI()
tkbind(dataCombo, "<<ComboboxSelected>>", updateUI)
@ 

This function could be bound to a ``refresh'' button or we could
arrange to have it called in the background. Using the \code{after}
command we could periodically check for new data frames, using a
\iprogram{task callback}task callback we can call this every time a
new command is issued.  As the call could potentially be costly, we
only call if the available data frames have been changed. Here is one
way to arrange that:
<<>>=
require(digest)
create_function <- function() {
  .dfs <- digest(ProgGUIinR:::avail_dfs())
  f <- function(...) {
    if((val <- digest(ProgGUIinR:::avail_dfs())) != .dfs) {
      .dfs <<- val
      updateUI()
    }
    return(TRUE)
  }
}
@ 
Then to create a task callback we have
<<>>=
id <- addTaskCallback(create_function())
@ 

% <<>>=
% updateUI()                              # run once
% tkbind("TCombobox","<<ComboboxSelected>>", updateUI) ## misses update on new data
% @ 
