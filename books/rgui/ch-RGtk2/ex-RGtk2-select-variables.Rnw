<<VariableSelectionExample, echo=FALSE, results=hide>>=
## Example showing implementation of variable selection widget where two tables show possible selections
## and selection. Similar to SPSS widget
## Illustrates filtered models, icons in view column
library(RGtk2)
library(MASS)
@ 

This example will show how to create a means to select variables from
a data frame using two tables. The left one indicating the variables
that can be selected, the right the variables that have been
selected. A similar mechanism is part of the SPSS model specification
GUI of Figure~\ref{fig:GUI:spss-11-term-selection}. For illustration purposes we use the
\code{Cars93} data set.
<<>>=
df <- Cars93
@ 
%
To indicate to the user the type of variables we use an icon. The
following function will create a pixmap holding an icon that depends
on the class of the variable. The \code{make\_icon} function from the
\pkg{ProgGUIinR} package will be used to draw the icon.
<<echo=FALSE>>=
#require(ProgGUIinR)                     # for make_icon
source("~/GUI/ProgGUIInR/R/misc.R")     # for make_icon
@ 
%
<<make_icon>>=
make_icon_pixmap <- function(x, ...) {
  require(grid); require(cairoDevice)
  pixmap <- gdkPixmap(drawable=NULL, width=16, height=16, 
                      depth=24)
  asCairoDevice(pixmap)
  grid.newpage()
  grid.draw(make_icon(x))
  dev.off()
  gdkPixbufGetFromDrawable(NULL, pixmap, NULL, 0,0,0,0,-1,-1)
}
@ 
%
We will use a filtered tree model for our two tables. Here we define a
data frame, a corresponding \code{rGtkDataFrame} object and from that
a filtered tree model. The filtering is done at the model level -- not
the view level -- by specifying a column in the model to indicate if a
row should be shown.  As such, we need two similar models.
<<models, results=hide>>=
mdf <- data.frame(Variables=sort(names(df)),
                  visible = rep(TRUE, ncol(df)),
                  stringsAsFactors=FALSE
                 )
mdf$pixmap <- sapply(names(df), function(i) 
                     make_icon_pixmap(df[,i, drop=TRUE]))
#
models <- list()
models[[1]] <- rGtkDataFrame(mdf)
mdf$visible <- !mdf$visible
models[[2]] <- rGtkDataFrame(mdf)
@ 
%
Here we create our filtered models and set the second column as the
visible column.
<<filterModels, results=hide>>=
filterModels <- sapply(models, function(i)
                       gtkTreeModelFilterNew(i))
sapply(filterModels, function(i) i$setVisibleColumn(1)) 
@ 
%
We now layout our GUI using a horizontal box. We pack in the views and
a box container to hold the selection buttons. The views will be
scrollable, so we construct \class{GtkScrolledWindow} instances.
<<guiLayout, results=hide>>=
w <- gtkWindow(show=FALSE)
g <- gtkHBox()
w$add(g)

## scrollbars
scrollbars <- sapply(1:2, function(i) gtkScrolledWindow())
sapply(scrollbars, function(i) i$setPolicy("automatic", "automatic"))
#
buttonBox <- gtkVBox();
#
g$packStart(scrollbars[[1]], expand=TRUE)
g$packStart(buttonBox, expand=FALSE)
g$packStart(scrollbars[[2]], expand=TRUE)
#
views <- sapply(1:2, function(i) gtkTreeView())
sapply(1:2, function(i) scrollbars[[i]]$add(views[[i]]))
@ 
%
Now we configure the views, first by setting the model and then the
selection mode.
<<configureView, results=hide>>=
sapply(1:2, function(i) views[[i]]$setModel(filterModels[[i]]))
sapply(1:2, function(i)
       views[[i]]$getSelection()$setMode('multiple'))
@ 
%
We use a single column to display our data (a list box) but that
column will hold both an icon and the text label. This is done by
packing in two cell renderers below:
<<viewColumns, results=hide>>=
make_view_column <- function() {
  vc <- gtkTreeViewColumn()
  vc$setTitle("Variable")
  cr <- gtkCellRendererPixbuf()
  vc$packStart(cr)
  vc$addAttribute(cr, "pixbuf", 2)
  cr <- gtkCellRendererText()
  vc$packStart(cr)
  vc$addAttribute(cr, "text", 0)
  vc
}
sapply(views, function(view) 
  view$insertColumn(make_view_column(), 0))
@ 
%
For later use we extend the API for a tree view -- one method to find
the selected indices ($1$-based) and one to indicate if there is a
selection. 
<<extendAPI>>=
## add to the gtkTreeView API for convenience
gtkTreeViewSelectedIndices <- function(object) {
  paths <- object$getSelection()$getSelectedRows()$retval
  out <- sapply(paths, function(i) {
    model <- object$getModel()          # Filtered!
    model$ConvertPathToChildPath(i)$toString()
  })
  if(length(out) == 0)
    integer(0)
  else
    as.numeric(out) + 1                             # 1-based
}
#
gtkTreeViewHasSelection <- 
  function(obj) length(obj$selectedIndices()) > 0
@ 
%
Now we create the buttons and add in a callback for the \code{clicked}
signal that moves the selected values to the other list. This is
simply by adjusting the Boolean value that instructs the filtered view
to show a row or not.
<<buttons, results=hide>>=
## do buttons
buttons <- lapply(c(">", "<"), gtkButton)
#
move <- function(i, ...) {
  ind <- views[[i]]$selectedIndices()
  models[[3-i]][ind,2] <- TRUE
  models[[i]][ind,2] <- FALSE
}
sapply(1:2, function(i) 
  gSignalConnect(buttons[[i]], "clicked", move, data=i, 
                 user.data.first=TRUE))
@ 
%
We only want our buttons sensitive if there is a possible move. This
is determined by the presence of a selection.
<<sensitiveButtons, results=hide>>=
sapply(buttons, gtkWidgetSetSensitive, FALSE) 
sapply(1:2, function(i) 
       gSignalConnect(views[[i]]$getSelection(), "changed", 
                      function(...) {
                        has <- views[[i]]$hasSelection()
                        buttons[[i]]['sensitive'] <- has
                      }))
@ 
%
Finally we add the buttons using some extra boxes to center them
vertically and call the \meth{show} method of the toplevel window.
<<packButtons, results=hide>>=
buttonBox$packStart(gtkVBox(), expand=TRUE) # align in center
sapply(buttons, gtkBoxPackStart, object=buttonBox, 
       expand=FALSE, padding=6)
buttonBox$packStart(gtkVBox(), expand=TRUE)
#
w$show()
@ 


