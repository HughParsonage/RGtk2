<<echo=FALSE>>=
library(RGtk2)
@ 

%% Possible outline:
%% - Displaying tabular data (GtkTreeView)
%%   - Loading data frame
%%   - Displaying data frame
%%   - Accessing GtkTreeModel (to set up selection, and hierarchical data)
%%   - Selection (an important concept, but common to hierarchical, below)
%%   - Sorting/filtering
%%   - Cell renderer details
%% - Displaying hierarchical data (GtkTreeView)
%%   - Loading hierarchical data
%%   - Displaying data as a tree
%% - Model-based combo boxes
%% - Text entry completion
%% - Icon views (currently omitted, probably OK)
%% - Text views

%% TODO: we need a unified example in the main text that spans loading
%% a data frame to sorting a model, at least.

Many widgets in \GTK\/ use the model-view-controller \iprogram{model-view-controller}(MVC)
paradigm. For most, like the button, the MVC pattern is implicit;
however, widgets that primarily display data explicitly incorporate
the MVC pattern into their design. The data model is factored out as a
separate object, while the widget plays the role of the view and
controller. The MVC approach adds a layer of complexity but
facilitates the display of the dynamic data in multiple, coordinated
views.

\section{Display of tabular data}
\label{sec:RGtk2:tabular-heirarchical-data}

Widgets that display lists, tables and trees are all based on the same
basic data model, \class{GtkTreeModel}. Although its name suggests a
hierarchical structure, \class{GtkTreeModel} is also tabular. We first
describe the display of an \R\/ data frame in a list or table
view. The display of hierarchical data, as well as further details of
the \class{GtkTreeModel} framework, are treated subsequently.

\igui{data frame model}
\subsection{Loading a data frame}
\label{sec:tabular-stores-tree}

As an interface, \class{GtkTreeModel} may be implemented in any number
of ways. \GTK\/ provides simple in-memory implementations for
hierarchical and non-hierarchical data.  \R\/ uses data frames to hold
tabular data, where each column is of a certain class, and each row is
related to some observational unit. This fits the structure of
\class{GtkTreeModel} when there is no hierarchy.  The
\class{RGtkDataFrame} class implements \class{GtkTreeModel} on top of
an \R\/ data frame. Compared to the model implementations built into
\GTK, \Rclass{RGtkDataFrame} affords the \R\/ programmer the benefits
of improved speed, convenience and familiarity.

For non-hierarchical data, this is
usually the model of choice, so we discuss it first. Populating a
\class{RGtkDataFrame} is far faster than for a \GTK\/ model, because
data is retrieved from the data frame on demand. There is no need to
copy the data row by row into a separate data structure. Such an
approach would be especially slow if implemented as a loop in
\R.~\footnote{As is proved with \pkg{tcltk}, where this is needed.} The constructor
\constructor{rGtkDataFrame} takes a
data frame as an argument. The column classes are important, so even
if this data frame is empty, the user should specify the desired
column classes upon construction.

An object of class \class{RGtkDataFrame} supports the familiar S3
methods \method{[}{RGtkDataFrame}, \method{[\ASSIGN}{RGtkDataFrame},
\method{dim}{RGtkDataFrame}, and
\method{as.data.frame}{RGtkDataFrame}. The \code{[$<$-} method does
not have quite the same functionality as it does for a data
frame. Columns can not be removed by assigning values to \code{NULL},
and column types should not be changed. These limitations are inherent
in the design of \GTK: columns may not be removed from
\class{GtkTreeModel}, and views expect the data type to remain the
same.

\begin{example}{Defining and manipulating a \class{RGtkDataFrame}}{eg-RGtk2-manipulate-rGtkDataframe}
  The basic data frame methods are similar.
<<>>=  
data(Cars93, package="MASS")             # mix of classes
model <- rGtkDataFrame(Cars93)
model[1, 4] <- 12
model[1, 4]                              # get value
@
%
As with a data frame, assignment to a factor must be from one of the
possible levels.

\end{example}

The data frame combination functions \function{rbind} and
\function{cbind} are unsupported, as they would create a new data
model, rather than modify the model in place. Thus, one should add
rows with \method{appendRows}{RGtkDataFrame} and add columns with
\method{appendColumns}{RGtkDataFrame} (or sub-assignment, 
\method{[\ASSIGN}{RGtkDataFrame}).

The \method{setFrame}{RGtkDataFrame} method replaces the underlying
data frame.
<<results=hide>>=
model$setFrame(Cars93[1:5, 1:5])
@ 
%
Replacing the data frame is the only way to remove rows, as this is
not possible with the conventional data frame sub-assignment
interface. Removing columns or changing their types remains
impossible. The new data frame cannot contain more columns and rows
than the current one. If the new data frame has more rows or columns,
then the appropriate \code{append} method should be used first.

\subsection{Displaying data as a list or table}
\label{sec:RGtk2:mvc:GtkTreeView}

%% intro
\class{GtkTreeView} is the primary view of \class{GtkTreeModel}.  It
serves as the list, table and tree widget in \GTK. A tree view is
essentially a container of columns, where every column has the same
number of rows. If the view has a single column, it is essentially a
list. If there are multiple columns, it is a table. If the rows are
nested, it is a tree table, where every node has values on the same
columns.

%% constructor
A tree view is constructed by \constructor{gtkTreeView}:
<<rgtk2-mvc-treeview-construc>>=
view <- gtkTreeView(model)
@ 
Usually, as in the above, the model is passed to the
constructor. Otherwise, the model may be accessed with
\method{setModel}{GtkTreeView} and \method{getModel}{GtkTreeView}.

A newly created tree view displays zero columns, regardless of the
number of columns in the model. Each column, an instance of
\class{GtkTreeViewColumn}, must be constructed, inserted into the view and
instructed to render content based on one or more columns in the data
model:
<<rgtk2-mvc-insert-column-hardway, results=hide>>=
column <- gtkTreeViewColumn()
column$setTitle("Manufacturer")
cell_renderer <- gtkCellRendererText()
column$packStart(cell_renderer)
column$addAttribute(cell_renderer, "text", 0)
view$insertColumn(column, 0)
@ 
%
A column with the title ``Manufacturer'' is inserted at the first,
$0$-based, position. For displaying a simple data frame, we only need
to render text. Each row in a column consists of one or more cells,
managed in a layout. The number of cells and how each cell is rendered
is uniform down a column. As an implementation of
\class{GtkCellLayout}, \class{GtkTreeViewColumn} delegates the
responsibility of rendering to one or more \class{GtkCellRenderer}
objects. The cell renderers are packed into the column, which behaves
much like a box container. Rendering of text cells is the role of the
\class{GtkCellRendererText} class. There are several properties that
control how the text is rendered. A so-called \textit{attribute} links
a model column to a renderer property. The most important property is
\code{text}, the text itself. In the example, we bind the \code{text}
property to the first ($0$-indexed) column in the model.

\class{GtkTreeView} provides the
\method{insertColumnWithAttributes}{GtkTreeView} convenience method to
perform all of these steps with a single call. We invoke it to add a
second column in our view:
<<rgtk2-mvc-insert-column-easyway, results=hide>>=
view$insertColumnWithAttributes(position = -1, 
                                title = "Model", 
                                cell = gtkCellRendererText(), 
                                text = 2 - 1) # second column
@ 
% 
The $-1$ passed as the first argument indicates that the column should
be appended. Next, we specify the column title, a cell renderer, and
an attribute that links the \code{text} renderer property to the
second column in the model. In general, any number of attributes may
be defined after the third argument.  We will use the above idiom in
all of the following examples, as it is much more concise than
performing each step separately.

Displaying the entire Cars93 data frame is not much different. Here,
we reconstruct the view, inserting a view column for every column in
the data frame, i.e., the model.
<<rgtk2-mvc-insert-all-columns, results=hide>>=
view <- gtkTreeView(model)
mapply(view$insertColumnWithAttributes,  
       position = -1, 
       title = colnames(model), 
       cell = list(gtkCellRendererText()), 
       text = seq_len(ncol(model)) - 1
       )
@

\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-RGtk2-scrollable-treeview}
  \caption{A \class{GtkTreeView} instance shown with a scrolled window}
  \label{fig:RGtk2-scrollable-treeview}
\end{figure}

Figure~\ref{fig:RGtk2-scrollable-treeview} shows the view within a scrollable window:
<<scrollView>>=
window <- gtkWindow()
window$setTitle("Tabular view of data frame")
scrolled_window <- gtkScrolledWindow()
window$add(scrolled_window)
scrolled_window$add(view)
@ 
%
%% JV cut this out
% Although it was relatively easy to create a \class{GtkTreeModel} for
% the data frame using \class{RGtkDataFrame}, the complexity of
% \class{GtkTreeView} complicates the task of displaying the data frame
% in a simple, textual table. When this is all that is necessary, one
% might consider \function{gtable} from \pkg{gWidgets}. For those
% who wish to render text in each row differently (e.g., in a different
% color) or fill cells with images, check boxes, progress bars and the
% like, direct use of the \class{GtkTreeView} API is required.

\paragraph{Manipulating view columns}
The \class{GtkTreeView} widget is essentially a collection of
columns. Columns are added to the tree view with the methods
\method{insertColumn}{GtkTreeView} or, as shown above,
\method{insertColumnWithAttributes}{GtkTreeView}.  A column can be
moved with the \method{moveColumnAfter}{GtkTreeView} method, and
removed with the \method{removeColumn}{GtkTreeView} method. The
\method{getColumns}{GtkTreeView} method returns a list containing all
of the tree view columns.

There are several properties for controlling the behavior and
dimensions of a \class{GtkTreeViewColumn} instance. The property
\qcode{resizable} determines whether the user can resize a column, by
dragging with the mouse. The size properties \qcode{width},
\qcode{min-width}, and \qcode{fixed-width} control the size. The
visibility of the column can be adjusted through the
\method{setVisible}{GtkTreeViewColumn} method.

\paragraph{Additional features}
Tree views have several special features, including sorting,
incremental search and drag-n-drop reordering. Sorting is discussed in
Section~\ref{sec:RGtk2:mvc:proxies}. To turn on searching,
\code{enable-search} should be \code{TRUE} (the default) and the
\code{search-column} property should be set to the column to be
searched. The tree view will popup a search box when the user types
\kbd{control-f}. To designate an arbitrary text entry widget as the
search box, call \method{setSearchEntry}{GtkTreeView}. The entry can
be placed anywhere in the GUI. Columns are always reorderable by drag
and drop. Reordering rows through drag-and-drop is enabled by the
\code{reorderable} property.

\paragraph{Aesthetic properties}

\class{GtkTreeView} is capable of rendering some visual guides. The
\code{rules-hint}, if \code{TRUE}, will instruct the theme to draw
rows in alternating colors. To show grid lines, set
\code{enable-grid-lines} to \code{TRUE}.

\subsection{Accessing \class{GtkTreeModel}}
\label{sec:RGtk2:mvc:iterators}

Although \class{RGtkDataFrame} provides a familiar interface for
manipulating the data in a \class{GtkTreeModel}, it is often necessary
to directly interact with the \GTK\/ API, such as when using another
type of data model or interpreting user selections. There are two
primary ways to index into the rows of a tree model: paths and
iterators.

To index directly into an arbitrary row, a \class{GtkTreePath} is
appropriate. For a table, a tree path is essentially the row number,
$0$-based; for a tree it is a sequence of integers referring to the
offspring index at each level. The sequence of integers may be
expressed as either a numeric vector or a string, using
\constructor{gtkTreePathNewFromIndices} or
\constructor{gtkTreePathNewFromString}, respectively. For a flat table
model, there is only one integer in the sequence:
<<rgtk2-mvc-path-constructor-list>>=
second_row <- gtkTreePathNewFromIndices(2)
@
%
Referring to a row in a hierarchy is slightly more complex:
<<rgtk2-mvc-path-constructor-tree>>=
abc_path <- gtkTreePathNewFromIndices(c(1, 3, 2))
abc_path <- gtkTreePathNewFromString("1:3:2")
@
%
In the above, both paths refer to the second child of the third child
of the first top-level node. To recover the integer or string
representation of the path, use \method{getIndices}{GtkTreePath} or
\method{toString}{GtkTreePath}, respectively.

%% iters
\paragraph{Iterators}
\iprogram{iterators} The second means of row indexing is through an
iterator, \class{GtkTreeIter}, which is better suited for traversing a
model.  An \dfn{iterator} is a programming object\iprogram{iterator
  pattern} used to traverse through some data, such as a text buffer
or table of values. Iterators are typically transient, in the sense
that they are invalidated when their source is modified. An iterator
is often updated by reference\iprogram{references}, behavior that is
atypical in \R\/ programming.


While a tree path is an intuitive, transparent row index, an iterator
is an opaque index that is efficiently incremented. It is
probably most common for a model to be accessed in an iterative
manner, so all of the data accessor methods for \class{GtkTreeModel}
expect \class{GtkTreeIter}, not \class{GtkTreePath}. The \GTK\/
designers imagined that the typical user would obtain an iterator for
the first row and visit each row in sequence:
<<rgtk2-mvc-iter-traverse>>=
iter <- model$getIterFirst()
manufacturer <- character()
while(iter$retval) {
  manufacturer <- c(manufacturer, model$get(iter$iter, 0)[[1]])
  iter$retval <- model$iterNext(iter$iter)
}
@ 
%
In the above, we recover the manufacturer column from the Cars93 data
frame. Whenever a \class{GtkTreeIter} is returned by a
\class{GtkTreeModel}, the return value in \R\/ is a list of two
components: \code{retval}, a logical indicating whether the iterator
is valid, and \code{iter}, the pointer to the underlying C data
structure. The call to \method{get}{GtkTreeModel} also returns a list,
with an element for each column index passed as an argument. The
method \method{iterNext}{GtkTreeStore} updates the passed iterator in
place, i.e., by reference, to point to the next row. Thus, no new
iterator is returned. This is unfamiliar behavior in \R. Instead, the
method returns a logical value indicating whether the iterator is
still valid, i.e. \code{FALSE} is returned if no next row exists.

It is clear that the above usage is designed for languages like C,
where multiple return values are conveniently passed by reference
parameters. This iterator design also prevents the use of the apply
functions (\R's iterators), which are generally preferred over the \code{while} loop
for reasons of performance and clarity. An improvement would be to
obtain the number of children, generate the sequence of row indices
and access the row for each index:
<<rgtk2-mvc-iter-apply>>=
nrows <- model$iterNChildren(NULL)
manufacturer <- sapply(seq(nrows) - 1L, function(i) {
  iter <- model$iterNthChild(NULL, i)
  model$get(iter$iter, 0)[[1]]
})
@
%
Here we use \code{NULL} to refer to the virtual root node that sits
above the rows in our table. Unfortunately, this usage too is
unintuitive and slow, so the benefits of \class{RGtkDataFrame} should
be obvious.

\paragraph{Converting between paths and iterators}
One can convert between paths and iterators. The method
\method{getIter}{GtkTreeModel} on \class{GtkTreeModel} returns an
iterator for a path. A shortcut from the string representation of the
path to an iterator is \method{getIterFromString}{GtkTreeModel}. The
path pointed to by an iterator is returned by
\method{getPath}{GtkTreeModel}.

One final point: \class{GtkTreeIter} is created and managed by the
model, while \class{GtkTreePath} is model independent. It is not
possible to use iterators across models or even across modifications
to a model. After a model changes, an iterator is invalid. A tree path
may still point to a valid row, though it will not in general be the
same row from before the change. To refer to the same row across tree
model changes, use a \class{GtkTreeRowReference}.

\subsection{Selection}
%% selection: none, single browse multiple, getSelected

There are multiple modes of user interaction with a tree view: if the
cells are not editable, then selection is the primary mode.  A single
click selects the value, and a double click is often used to initiate
an action. If the cells are editable, then a double click or a click
on an already selected row will initiate editing of the
content. Editing of cell values is a complex topic and is handled by
derivatives of \class{GtkCellRenderer}, see
%% FIXME: these references are just going to the top of this
%% section. Apparently, the subsections are not available for reference.
Section~\ref{sec:RGtk2:cellrenderers}. Here, we limit our discussion
to selection of rows.

\GTK\/ provides the class \class{GtkTreeSelection} to manage row
selection. Every tree view has a single instance of
\class{GtkTreeSelection}, returned by the
\method{getSelection}{GtkTreeView} method.

The usage of the selection object depends on the selection mode, i.e.,
whether multiple rows may be selected. The mode is configured with the
\method{setMode}{GtkTreeSelection} method, with values from
\code{GtkSelectionModel}, including \qcode{multiple} for allowing more
than one row to be selected and \qcode{single} for limiting selections
to a single row, or none. For example, we create a view and limit it
to single selection:
<<results=hide>>=
model <- rGtkDataFrame(mtcars)
view <- gtkTreeView(model)
selection <- view$getSelection()
selection$setMode("single")
@ 

When only a single selection is possible, the method
\method{getSelected}{GtkTreeSelection} returns the selected row as a
list, with components \code{retval} to indicate success, \code{model}
pointing to the tree model and \code{iter} representing an iterator to
the selected row in the model.
<<echo=FALSE, results=hide>>=
column <- gtkTreeViewColumn()
view$insertColumnWithAttributes(0, "title", gtkCellRendererText(), text = 0)
## pack in GUI
scrolled_window <- gtkScrolledWindow()
scrolled_window$add(view)
##
window <- gtkWindow(show=FALSE)
window['title'] <- "Multiple selection example"
window$add(scrolled_window)
window$show()
## some selection
selection$selectPath(gtkTreePathNewFromIndices(3)) # set 
# 
@
%
If our tree view is shown and a selection made, this code will
return the value in the first column:
<<>>=
selected <- selection$getSelected()
with(selected, model$getValue(iter, 0)$value)
@ 
%
When multiple selection is permitted, then the method
\method{getSelectedRows}{GtkTreeSelection} returns a list with
the \code{model} and \code{retval}, a list
of tree paths.

To respond to a selection, connect to the \signal{changed} signal on
\class{GtkTreeSelection}. Upon a selection, this handler will print
the selected values in the first column:
<<>>=
gSignalConnect(selection, "changed", function(selection) {
  selected_rows <- selection$getSelectedRows()
  if(length(selected_rows$retval)) {
    rows <- sapply(selected_rows$retval, 
                   gtkTreePathGetIndices) + 1L
    selected_rows$model[rows, 1]
  }
})
@ 

%% double click
When a row is not editable, then the double-click event or a keyboard
command triggers the \signal{row-activated} signal for the tree
view. The callback has arguments \code{tree.view} pointing to the
widget that emits the signal, \code{path} storing a tree path of the
selected row, and \code{column} containing the tree view column. The
column number is not returned. If that is of interest, it can be
passed in via the user data argument, or matched against the children
of the tree view through a command like
<<eval=FALSE>>=
sapply(view$getColumns(), function(i) i == column)
@ 

\subsection{Sorting}
\label{sec:RGtk2:mvc:proxies}

A common GUI feature is sorting a table widget by column. By
convention, the user clicks on the column header to toggle
sorting. \class{GtkTreeView} supports this interaction, although the
actual sorting occurs in the model. Any model that implements the
\class{GtkTreeSortable} interface supports
sorting. \class{RGtkDataFrame} falls into this category. When
\class{GtkTreeView} is directly attached to a sortable model, it is
only necessary to inform each view column of the model column to use
for sorting when the header is clicked:
<<rgtk2-mvc-sorting-clickable>>=
column <- view$getColumn(0)
column$setSortColumnId(0)
@ 
%
In the above, clicking on the header of the first view column,
\code{vc}, will sort by the first model column. Behind the scenes,
\class{GtkTreeViewColumn} will set its sort column as the sort column
on the model, i.e.:
<<rgtk2-mvc-sorting-sortable>>=
model$setSortColumnId(0, "ascending")
@ 

Some models, however, do not implement \class{GtkTreeSortable}, such
as \class{GtkTreeModelFilter}, introduced in the next section. Also,
sorting a model permanently changes the order of its rows, which may
be undesirable in some cases. The solution is to proxy the original
model with a sortable model. The proxy obtains all of its data from the
original model and reorders the rows according to the order of the
sort column. \GTK\/ provides \class{GtkTreeModelSort} for this:
<<echo=FALSE>>=
require(MASS)
@ 
<<basicSort, results=hide>>=
model <- rGtkDataFrame(Cars93)
sorted_model <- gtkTreeModelSortNewWithModel(model)
view <- gtkTreeView(sorted_model)
mapply(view$insertColumnWithAttributes,
       position = -1,
       title = colnames(model),
       cell = list(gtkCellRendererText()),
       text = seq_len(ncol(model)) - 1)
sapply(seq_len(ncol(model)), function(i)
       view$getColumn(i - 1)$setSortColumnId(i - 1))
@ 
%
When the user sorts the table, the underlying \code{store} will not be
modified. 

\begin{figure}
  \centering
  \includegraphics[width=.7\textwidth]{fig-RGtk2-sortable-treeview}
  \caption{When a sortable model is passed to the treeview, one can click on the column headers to sort the data. The "Type" column has a custom sort function applied.}
  \label{fig:RGtk2-sortable-treeview}
\end{figure}


The default sorting function can be changed by calling the method
\method{setSortFunc}{GtkTreeSortable} on a sortable model.  The
following function shows how a special sort for the \code{Type} of car
can be implemented (Figure~\ref{fig:RGtk2-sortable-treeview}).
<<sort-example, results=hide>>=
f <- function(model, iter1, iter2, user.data) {
  types <- c("Compact", "Small", "Sporty", "Midsize", 
             "Large", "Van")
  column <- user.data
  val1 <- model$getValue(iter1, column)$value
  val2 <- model$getValue(iter2, column)$value
  as.integer(match(val1, types) - match(val2, types))
}
sorted_model$setSortFunc(sort.column.id = 3 - 1, sort.func = f, 
                         user.data = 3 - 1)
@ 

<<notShown, echo=FALSE>>=
## basic GUI
sw <- gtkScrolledWindow()
sw$add(view)
w <- gtkWindow(show=FALSE)
w['title'] <- "Example of sortable tree view"
w$add(sw)
w$show()
@ 

\subsection{Filtering}
\label{sec:RGtk2:mvc:filtering}

The previous section introduced the concept of a proxy model in
\class{GtkTreeModelSort}. Another common application of proxying is
filtering.  For filtering via a proxy model, \GTK\/ provides the
\class{GtkTreeModelFilter} class. The basic idea is that an extra
column in the base model stores logical values to indicate if a row
should be visible. The index of that column is passed to the filter
model, which provides only those rows where the filter column is
\code{TRUE}.

This is the basic usage:
<<>>=
df <- Cars93
model <- rGtkDataFrame(cbind(df, .visible=rep(TRUE, nrow(df))))
filtered_model <- model$filter()
filtered_model$setVisibleColumn(length(df))          # 0-based
view <- gtkTreeView(filtered_model)
## Adjust filter
model[,".visible"] <- df$MPG.highway >= 30
@ 
%
The constructor of the filter model is \function{gtkTreeModelFilter},
which, somewhat coincidentally, also works as a method on the base
model, i.e., \code{model\$filter()}. To retrieve the original model
from the filter, call its \code{getModel} method. The method
\method{setVisibleColumn}{GtkTreeModelFilter} specifies which column
in the model holds the logical values.  To customize filtering, one
can register a function with \method{setVisibleFunc}{gtkTreeModelFilter}. The callback,
given a row pointer, should return \code{TRUE} if the row passes the
filter, see Example~\ref{ex:RGtk2-variable-selection}. A filter model
may be treated as any other tree model, including attachment to a
\class{GtkTreeView}.

<<notShown, echo=FALSE, results=hide>>=
mapply(view$insertColumnWithAttributes,  
       position=-1, 
       title=colnames(df), 
       cell=list(gtkCellRendererText()), 
       text = seq_len(length(df)) - 1
       )    
##
sw <- gtkScrolledWindow()
sw$add(view)
w <- gtkWindow(show=FALSE)
w$add(sw)
w$show()
@ 

%% filter


\begin{example}{Using filtering}{ex:RGtk2-filtered}
  \SweaveInput{ex-RGtk2-filtered}
\end{example}

\subsection{Cell renderer details}
\label{sec:RGtk2:cellrenderers}

The values in a tree model are rendered in a rectangular cell by the
derivatives of \class{GtkCellRenderer}. Cell renderers are
interactive, in that they also manage editing and activation of cells.

A cell renderer is independent of any data model. Its rendering role
is limited to drawing into a specified rectangular region according to
its current property values. An object that implements the
\class{GtkCellLayout} interface, like \class{GtkTreeViewColumn} and
\class{GtkComboBox} (see Section~\ref{sec:RGtk2:mvc:combobox}),
associates a set of \emph{attributes} with a cell renderer. An
attribute is a link between an aesthetic property of a cell renderer
and a column in the data model. When the \class{GtkCellLayout} object
needs to render a particular cell, it configures the properties of the
renderer with the values from the current model row, according to the
attributes. Thus, the mapping from data to visualization depends on
the class of the renderer instance, its explicit property settings,
and the attributes associated with the renderer in the cell layout.

For example, to render text, a \class{GtkCellRendererText} is
appropriate. The \code{text} property is usually linked via an
attribute to a text column in the model, as the text would vary from
row to row. However, the background color (the \code{cell-background}
property) might be common to all rows in the column and thus is set
explicitly, without use of an attribute:
<<gtk-mvc-cell-explicit>>=
cell_renderer <- gtkCellRendererText()
cell_renderer['cell-background'] <- "gray"
@ 

The base class \class{GtkCellRenderer} defines a number of properties
that are common to all rendering tasks. The \code{xalign} and
\code{yalign} properties specify the alignment, i.e., how to position
the rendered region when it does not fill the entire cell. The
\code{cell-background} property indicates the color for the entire
cell background.

The rest of this section describes each type of cell renderer, as well
as some advanced features.

%% text/ numbers
\paragraph{Text cell renderers}

\constructor{GtkCellRendererText} displays text and numeric
values. Numeric values in the model are shown as strings.  The most
important property is \code{text}, the actual text that is
displayed. Other properties control the display of the text, such as
the font \code{family} and \code{size}, the \code{foreground} and
\code{background} colors, and whether to \code{ellipsize} or
\code{wrap} the text if there is not enough space for display.  For
example, we display right-aligned text in a Helvetica font:
<<cr-right-aligned>>=
cell_renderer <- gtkCellRendererText()
cell_renderer['xalign'] <- 1          # default 0.5 = centered
cell_renderer['family'] <- "Helvetica"  
@ 

When an attribute links the \code{text} property to a numeric column
in the model, the property system automatically converts the number to
its string representation. This occurs according to the same logic
that \R\/ follows to print numeric values, so options like
\code{scipen} and \code{digits} are considered. See the ``Overriding
attribute mappings'' paragraph below for further customization.

\paragraph{Editable cells} When the \code{editable} property of a text
cell (or \code{activatable} property of a toggle cell) is set to
\code{TRUE}, then the cell contents can be changed. This allows the
user to make changes to the underlying model through the GUI. Although
the view automatically reflects changes made to the model, the reverse
is not true. A callback must be assigned to the \code{editable}
(\code{toggled}) signal for the cell renderer to implement the
change. The callback for the \qcode{edited} signal has arguments
\code{renderer}, \code{path} for the path of the selected row (as a
string), and \code{new.text} containing the value of the edited text
as a string. These arguments do not include the tree view object nor
the column index, so these should be provided by some other means,
e.g., from the enclosing environment of the handler.
For example, here is how one can update an \code{RGtkDataFrame} model
from within the callback:
<<echo=FALSE>>=
cell_renderer <- gtkCellRendererText()
store <- model
@ 
<<editedSignal>>=
cell_renderer['editable'] <- TRUE
gSignalConnect(cell_renderer, "edited", 
       f=function(cell_renderer, path, newtext, user.data) {
         i <- as.numeric(path) + 1
         j <- user.data$column
         model <- user.data$model
         model[i, j] <- newtext
       }, data=list(model=store, column=1))
@ 
% 
Before using editable cells to create a data frame editor, one should
see if the editor provided by the \function{gtkDfEdit} in the
\pkg{RGtk2Extras} package satisfies the requirements.

Users may expect that once a cell is edited, the next cell is then set
up to be edited. In order to do this, one must advance the cursor and
activate editing of the next cell. For \class{GtkTreeView}, this is
implemented by the \method{setCursor}{GtkTreeView} method.

\begin{example}{Using a table to gather arguments}{ex:RGtk2-options-in-table}
  \SweaveInput{ex-RGtk2-options-in-table}
\end{example}

%% XXX JV Add in an editable table example here, mention
%% RGtk2Extras:::gtkDfEdit

%% perhaps could be adapted to demonstrate the above
% \begin{example}{A basic usage of displaying a data frame using a tree view}{ex:RGtk2-minimal-rGtkDataFrame}
%   \SweaveInput{ex-RGtk2-minimal-rGtkDataFrame}
% \end{example}

%% combo
\paragraph{Combo and spin cell renderers}

\class{GtkCellRendererCombo} and \class{GtkCellRendererSpin} allow
editing a text cell with a combo box or spin button,
respectively. Populating the combo box menu requires specifying two
properties: \code{model} and \code{text-column}. The menu items are
retrieved from the \class{GtkTreeModel} given by \code{model} at the
column index given by \code{text-column}.  If \code{has-entry} is
\code{TRUE}, a combo box entry is displayed.
<<>>=
cell_renderer <- gtkCellRendererCombo()
model <- rGtkDataFrame(state.name)
cell_renderer['model'] <- model
cell_renderer['text-column'] <- 0
cell_renderer['editable'] <- TRUE                  # needed
@ 
%
The spin button editor is configured by setting a
\class{GtkAdjustment} on the \code{adjustment} property.


The \signal{changed} signal is emitted when an items is selected in
the combo box. The spin cell renderer inherits the \signal{edited}
signal from \class{GtkCellRendererText}.

%% pixbuf
\paragraph{Pixbuf cell renderers}

To display an image in a cell, \class{GtkCellRendererPixbuf} is
appropriate. The image is specified through one of these properties:
\code{stock-id}, a stock identifier; \code{icon-name}, the name of a
themed icon; or \code{pixbuf}, an actual \code{GdkPixbuf} object,
holding an image in memory. Using a \class{list}, one can store a
\class{GdkPixbuf} in a \class{data.frame}, and thus an
\class{RGtkDataFrame}. This is demonstrated in the next example.

% <<rgtk2-mvc-pixbuf-in-df>>=
% library(RGtk2)
% apple <- gdkPixbuf(filename = imagefile("apple-red.png"))[[1]]
% floppy <- gdkPixbuf(filename = imagefile("floppybuddy.gif"))[[1]]
% logo <- gdkPixbuf(filename = imagefile("rgtk-logo.gif"))[[1]]
% rdf <- rGtkDataFrame(data.frame(image = I(list(apple, floppy, logo))))
% view <- gtkTreeView(rdf)
% view$insertColumnWithAttributes(0, "image", gtkCellRendererPixbuf(), pixbuf = 0)
% win <- gtkWindow()
% win$add(view)
% @


%% JV redid, a tighter programmed
\begin{example}{A variable selection widget}{ex:RGtk2-variable-selection}
  \SweaveInput{ex-RGtk2-select-variables}
\end{example}

% %% ping pong
% \begin{example}{A widget for variable selection}{ex:RGtk2-pingpong}
%   \SweaveInput{ex-RGtk2-pingpong}
% \end{example}

\paragraph{Toggle cell renderers}

Binary data can be represented by a toggle. The
\constructor{gtkCellRendererToggle} will create a check box in the
cell that will appear checked if the \code{active} property is
\code{TRUE}. If an attribute is defined for the property, then changes
in the model will be reflected in the view. More work is required to
modify the model in response to user interaction with the view. The
\code{activatable} attribute for the cell must be \code{TRUE} in order
for it to receive user input. The programmer then needs to connect to the
\signal{toggled} to update the model in response to changes in the
active state.
<<cellRendererToggle>>=
cell_renderer <- gtkCellRendererToggle()
cell_renderer['activatable'] <- TRUE   # cell can be activated
cell_renderer['active'] <- TRUE
gSignalConnect(cell_renderer, "toggled", function(w, path) {
  model$active[as.numeric(path) + 1] <- w['active']
})
@ 

To render the toggle as a radio button instead of a check box, set the
\code{radio} property to \code{TRUE}. Again, the programmer is
responsible for implementing the radio button logic via the
\code{toggled} signal.

\begin{example}{Displaying a check box column in a tree
    view}{ex:RGtk2-add-toggle-to-df}
  \SweaveInput{ex-RGtk2-add-toggle-to-df}
\end{example}

%% progress bars
\paragraph{Progress cell renderers}

To visually communicate progress within a cell, both progress bars and
spinner animations are supported. These modes correspond to
\class{GtkCellRendererProgress} and \class{GtkCellRendererSpinner},
respectively.

In the case of \class{GtkCellRendererProgress}, its \code{value}
property takes a value between $0$ and $100$ indicating the amount
finished, with a default value of $0$. Values out of this range will
be signaled by an error message.  For example,
<<comboEditor>>=
cell_renderer <- gtkCellRendererProgress()
cell_renderer["value"] <- 50
@ 

For indicating progress in the absence of a definite end point,
\class{GtkCellRendererSpinner} is more appropriate. The spinner is
displayed when the \code{active} property is \code{TRUE}. Increment
the \code{pulse} property to drive the animation.

%% numbers
\paragraph{Overriding attribute mappings}

The default behavior for mapping model values to a renderer property
is simple: values are extracted from the model and passed directly to
the cell renderer property. If the data types are different, such as a
numeric value for a string property, the value is converted using
low-level routines defined by the property system. It is sometimes
desirable to override this mapping with more complex logic.

For example, conversion of numbers to strings is a non-trivial
task. Although the logic in the \R\/ print system often performs
acceptably, there is certainly room for customization. One example is
aligning floating point numbers by fixing the number of decimal
places. This could be done in the model (e.g., using
\function{sprintf} to format and coerce to character
data). Alternatively, one could preserve the integrity of the data and
perform the conversion during rendering. This requires intercepting
the model value before it is passed to the cell renderer. 

In the specific case of \class{GtkTreeView}, it is possible to specify a
callback that overrides this step.  The callback, of type
\class{GtkTreeCellDataFunc}, is passed arguments for the tree view
column, the cell renderer, the model, an iterator pointing to the row
in the model and, optionally, an argument for user data. The function
is tasked with setting the appropriate attributes of the cell
renderer. For example, this callback would format floating point
numbers:
<<>>=
func <- function(column, cell_renderer, model, iter, data) {
  val <- model$getValue(iter, 0)$value
  f_val <- sprintf("%.3f", val)
  cell_renderer['text'] <- f_val
  cell_renderer['xalign'] <- 1
}
@ 
%
The function then needs to be registered with a
\class{GtkTreeViewColumn} that is rendering a numeric column from the model:
<<results=hide>>=
view <- gtkTreeView(rGtkDataFrame(data.frame(rnorm(100))))
cell_renderer <- gtkCellRendererText()
view$insertColumnWithAttributes(0, "numbers", cell_renderer, 
                                text = 0)
column <- view$getColumn(0)
column$setCellDataFunc(cell_renderer, func)
@ 
%
The last line is the key: calling
\method{setCellDataFunc}{GtkTreeViewColumn} registers our custom
formatting function with the view column.

One drawback with the use of such functions is that \R\/ code is
executed every time a cell is rendered. If performance matters,
consider pre-converting the data in the model or tweaking the
\code{options} in \R\/ for printing real numbers, namely \code{scipen}
and \code{digits}.

For customizing rendering further, and in the general case beyond
\class{GtkTreeView}, one could implement a new type of
\class{GtkCellRenderer}.  See Chapter~\ref{sec:gtk:extending-classes}
for more details on extending \GTK\/ classes.

%% This function will be set for the tree view column and illustrated in Example~\ref{ex:RGtk2:rGtk2DataFrame}.
%% editable cells 

\section{Display of hierarchical data}
\label{sec:RGtk2:mvc:GtkTreeStore}

Although the \code{RGtkDataFrame} model is a convenient implementation
of \class{GtkTreeModel}, it has its limitations. Primary among them is
its lack of support for hierarchical data. \GTK\/ implements
\class{GtkTreeModel} with \class{GtkListStore} and
\class{GtkTreeStore}, which respectively store non-hierarchical and
hierarchical tabular data. \class{GtkListStore} is a flat table,
while \class{GtkTreeStore} organizes the table into a hierarchy. Here,
we discuss \class{GtkTreeStore}.

\subsection{Loading hierarchical data}
  
%% ML: I'm pretty sure that RGtkDataFrame will support the same types
%% of values as GtkListStore. It's just a little tricky to get a
%% column of GdkPixbuf externalptr's into a data.frame. Much easier to
%% use a character vector and associate it with the stock.id property
%% of GtkCellRendererPixbuf, as long as the images are registered icons.

%% construction
A tree store is constructed using \constructor{gtkTreeStore}. The
column types are specified through a character vector at the time of
construction. The specification uses ``GTypes'' such as
\code{gchararray} for character data, \code{gboolean} for logical
data, \code{gint} for integer data, \code{gdouble} for numeric data,
and \code{GObject} for \GTK\/ objects, such as pixbufs.

\begin{example}{Defining a tree}{eg:RGtk2:tree-store}
  Below, we create a tree based on the \code{Cars93} dataset, where
  the car models (\code{Model}) are organized by manufacturer
  (\code{Manufacturer}), i.e., each model row is the child of its
  manufacturer row:
<<results=hide>>=
model <- gtkTreeStore("gchararray")
by(Cars93, Cars93$Manufacturer, function(df) {
  parent_iter <- model$append()
  model$setValue(parent_iter$iter, column = 0, value = 
                 df$Manufacturer[1])
  sapply(df$Model, function(car_model) {
    child_iter <- model$append(parent = parent_iter$iter)
    if (is.null(child_iter$retval)) 
      model$setValue(child_iter$iter, column = 0, 
                     value = car_model)
  })
})
@ 
  To retrieve a value from the tree store using its path we have:
<<>>=
iter <- model$getIterFromString("0:0")
model$getValue(iter$iter, column = 0)$value
@ 
This obtains the first model from the first manufacturer (path \qcode{0:0}).
\end{example}



As shown in the above example, populating a tree store relies on two
functions: \method{append}{GtkTreeStore}, for appending rows, and
\method{setValue}{GtkTreeStore}, for setting row values. The iterator
to the parent row is passed to \method{append}{GtkTreeStore}. A parent
of \code{NULL}, the default, indicates that the row should be at the
top level. It would also be possible to insert rows using
\method{insert}{GtkTreeStore}, \method{insertBefore}{GtkTreeStore}, or
\method{insertAfter}{GtkTreeStore}. The
\method{setValue}{GtkTreeStore} method expects the row iterator and a
$0$-based, column index.  An entire row can be assigned through the
\method{set}{GtkTreeStore} method. The method uses positional
arguments to specify the column and the value, in alternating
fashion. The column index appears as an even argument (say $2k$) and
the corresponding value in the odd argument (say $2k+1$).  Values are
returned by the \method{getValue}{GtkListStore} method, in a list with
component \code{value} storing the value.

Traversing a tree store is most easily achieved through the use of
\class{GtkTreeIter}, introduced previously in the context of flat
tables. Here we perform a depth-first traversal of our \code{Cars93}
model to obtain the model values: 
<<rgtk2-mvc-tree-traverse>>=
iter <- model$getIterFirst()
models <- NULL
while(iter$retval) {
  child_iter <- model$iterChildren(iter$iter)
  while(child_iter$retval) {
    models <- c(models, model$get(child_iter$iter, 0)[[1]])
    child_iter$retval <- model$iterNext(child_iter$iter)
  }
  iter$retval <- model$iterNext(iter$iter)
}
@ 
%
The hierarchical structure introduces the method
\method{iterChildren}{GtkTreeModel} for obtaining an iterator to the
first child of a row. As with other methods returning iterators, the
return value is a list, with the \code{retval} component indicating
the validity of the iterator, stored in the \code{iter} component. The
method \method{iterParent}{GtkTreeModel} performs the reverse,
iterating from child to parent.

%% JV can add back in such a graphic. Took out for now.
% \begin{figure}
%   %% \centering
%   \includegraphics[width=.7\textwidth]{traverse-tree}
%   \caption{[REPLACEME!] Graphical illustration of the functions used
%     by iters to traverse a tree store. }
%   \label{fig:traverse-iter}
% \end{figure}

\paragraph{Row manipulations}
Rows within a store can be rearranged using several methods. Call the
\method{swap}{GtkTreeStore} method to swap rows referenced by their
iterators.  The methods \method{moveAfter}{GtkTreeStore} and
\method{moveBefore}{GtkTreeStore} move one row after or before
another, respectively.  The \method{reorder}{GtkTreeStore} method
totally reorders the rows under a specified parent given a vector of
row indices, like that returned by \function{order}.
%% clearing contents
Once added, rows may be removed using the
\method{remove}{GtkTreeStore} method. To remove every row, call the
\method{clear}{GtkTreeStore} method.

\subsection{Displaying data as a tree}
\label{sec:RGtk2:mvc:display-tree}

Once a hierarchical dataset has been loaded into a
\class{GtkTreeModel} implementation like \class{GtkTreeStore}, it can
be passed to a \class{GtkTreeView} widget for display as a
tree. Indeed, this is the same widget that displayed our flat data
frame in the previous section. As before, \class{GtkTreeView}
displays the \class{GtkTreeModel} as a table; however, it now adds
controls for expanding and collapsing nodes where rows are nested.

The user can click to expand or collapse a part of the tree. These
actions trigger the emission of the signals \code{row-expanded} and
\code{row-collapsed}, respectively.

\begin{example}{A simple tree display}{eg:RGtk2-simple-tree}
  \SweaveInput{ex-RGtk2-simple-tree}
\end{example}

%% ## dynamic. 
%% JV: Is this too much? Perhaps leave for the package?
%% ML: Probably should move this to the package.
% \begin{example}{Dynamically growing a tree}{eg:RGtk2:tree-dynamic}
%   \SweaveInput{ex-RGtk2-tree}
% \end{example}
%% % ## mapes a list, shows how to update text view
% \SweaveInput{ex-RGtk2-tree-show}

\section{Model-based combo boxes}
\label{sec:RGtk2:mvc:combobox}

Basic combo box usage was discussed in
Section~\ref{sec:RGtk2:basic-combobox}; here we discuss the more
flexible and complex approach of using an explicit data model for
storing the menu items. The item data is tabular, although it is
limited to a single column. Thus, \class{GtkTreeModel} is again the
appropriate model, and \class{RGtkDataFrame} is usually the
implementation of choice.

To construct a \class{GtkComboBox} based on a user-created model, one
should pass the model to the constructor
\constructor{gtkComboBox}. This model may be changed or set through
the \method{setModel}{GtkComboBox} method and is returned by
\method{getModel}{GtkComboBox}. Like \class{GtkTreeViewColumn},
\class{GtkComboBox} implements the \class{GtkCellLayout} interface and
thus delegates the rendering of model values to
\class{GtkCellRenderer} instances that are packed into the combo box.

The \method{getActiveIter}{GtkComboBox} returns a list containing the iterator
pointing to the currently selected row in the model.  If no row has been
selected, the \code{retval} component of the list is \code{FALSE}.
The \method{setActiveIter}{GtkComboBox} sets the currently selected
item by iterator. As discussed previously, the
\method{getActive}{GtkComboBox} and \method{setActive}{gtkComboBox}
methods behave analogously with $0$-based indices.

\begin{example}{A combo box with memory}{eg:RGtk2-combobox-entry}
  \SweaveInput{ex-RGtk2-combobox-entry}
\end{example}


%% JV, moved this to the first intro of comoboboxes
% \begin{example}{Modifying the values in a combobox}{eg-RGtk2-combobox-dynamic}
%   \SweaveInput{ex-RGtk2-combobox-dynamic}
% \end{example}

%% JV this is in the menu section, not really needed here
% \begin{example}{A color selection widget}{eg:RGtk2:combobox}
%   \SweaveInput{ex-RGtk2-combobox}
% \end{example}


\section{Text entry widgets with completion}
\label{sec:RGtk2:entry-completion}

Often, the number of possible choices is too large to list in a combo
box. One example is a web-based search engine: the possible search
terms, while known and finite in number, are too numerous to list. The
auto-completing text entry has emerged as an alternative to a combo
box and might be described as a sort of dynamic combo box entry widget. 
When a user enters a string, partial matches to the string are
displayed in a menu that drops down from the entry. 

The \class{GtkEntryCompletion} object implements text completion in
\GTK. An instance is constructed with
\constructor{gtkEntryCompletion}. The underlying database is a
\class{GtkTreeModel}, like \class{RGtkDataFrame}, set via the
\method{setModel}{GtkEntryCompletion} method. To connect a
\class{GtkEntryCompletion} to an actual \class{GtkEntry} widget, call
the \method{setCompletion}{GtkEntry} method on \class{GtkEntry}.  The
\code{text-column} property specifies the column containing the
completion candidates. 

There are several properties that can be adjusted to tailor the
completion feature; we mention some of them. Setting the property
\code{inline-selection} to \code{TRUE} will place the top completion
suggestion to the entry inline as the completions are scrolled
through; \code{inline-completion} will add the common prefix
automatically to the entry widget; \code{popup-single-match} is a
logical indicating if a popup is displayed on a single match;
\code{minimum-key-length} takes an integer specifying the number of
characters needed in the entry before completion is checked (the
default is $1$).

By default, the rows in the data model that match the current value of
the entry widget in a case insensitive manner are displayed. This
matching function can be overridden by setting a new \R\/ function through
the \method{setMatchFunc}{GtkEntryCompletion} method. The signature of
this function is the completion object, the string from the entry
widget (lower case), an iterator pointing to a row in the model and
optionally user data that is passed through the \code{func.data}
argument of the \code{setMatchFunc} method. This callback should
return \code{TRUE} or \code{FALSE} depending on whether that row
should be displayed in the set of completions.

%% TODO: work this example into the above
\begin{example}{Text entry with completion}{eg:RGtk2:text-entry-comletion}
  \SweaveInput{ex-RGtk2-entry-completion}
\end{example}

\section{Sharing buffers between text entries}
\label{sec:RGtk2:buffer-sharing}

As of \GTK\/ version $2.18$, multiple instances of \class{GtkEntry}
can synchronize their text through a shared buffer. Each entry obtains
its text from the same underlying model, a
\class{GtkEntryBuffer}. Here, we construct two entries, with a shared
buffer:
<<gtk-mvc-entry-buffer>>=
buffer <- gtkEntryBuffer()        
entry1 <- gtkEntry(buffer = buffer)
entry2 <- gtkEntry(buffer = buffer)
entry1$setText("echo")
entry2$getText()
@ 
%
The change of text in \qcode{entry1} has been reflected in
\qcode{entry2}.

\section{Text views} %% text buffer
\label{sec:RGtk2:textviews}

Multiline text areas are displayed through \class{GtkTextView}
instances. These provide a view of an accompanying
\class{GtkTextBuffer}, which is the model that stores the text and
other objects to be rendered. The view is responsible for the display
of the text in the buffer and has methods for adjusting tabs, margins,
indenting, etc. The text buffer stores the actual text, and its
methods are for adding and manipulating the text.

A text view is created with \constructor{gtkTextView}.  The underlying
text buffer can be passed to the constructor. Otherwise, a buffer is
automatically created.  This buffer is returned by the method
\method{getBuffer}{GtkTextView} and may be set with the
\method{setBuffer}{GtkTextView} method. Text views provide native
scrolling support and thus are easily added to a scrolled window
(Section~\ref{sec:RGtk2:scroll-windows}). 

\begin{example}{Basic \constructor{gtkTextView} usage}{eg:RGtk2:textview-basics}
  The steps to construct a text view consist of:
<<>>=
view <- gtkTextView()
scrolled_window <- gtkScrolledWindow()
scrolled_window$add(view)
scrolled_window$setPolicy("automatic", "automatic")
##
window <- gtkWindow()
window['border-width'] <- 15
window$add(scrolled_window)
@
%
To set all the text in the buffer requires accessing the underlying
buffer:
<<setText>>=
buffer <- view$getBuffer()
buffer$setText("Lorem ipsum dolor sit amet ...")
@ 

Manipulating the text requires an understanding of how positions are
referred to within the buffer (iterators or marks). As an indicator,
to get the contents of the buffer may be done as follows:
<<bufferGetText>>=
start <- buffer$getStartIter()$iter    
end <- buffer$getEndIter()$iter
buffer$getText(start, end)
@ 

\end{example}

%% simple use -- replace, Append, insert at cursor
\paragraph{Adding text}
Text may be added programmatically through various methods of the text
buffer. The most basic \method{setText}{GtkTextBuffer}, which simply
replaces the current text, is shown in the example above. The method
\method{insertAtCursor}{GtkTextBuffer} will add the text to the buffer
at the current position of the cursor.  Other means are described in
the following sections.

\paragraph{Properties}
By default, the text in a view is editable. This can be disabled
through the \property{editable}{GtkTextView} property. Typically, one
then sets the \property{cursor-visible}{GtkTextView} property to
\qcode{FALSE} so that the cursor is hidden:
<<gtk-mvc-text-noneditable>>=
view['editable'] <- FALSE
view['cursor-visible'] <- FALSE
@ 

%% properties: editable, ...
\paragraph{Formatting}
The text view supports several general formatting options. Automatic
line wrapping is enabled through \method{setWrapMode}{GtkTextView},
which takes values from \code{GtkWrapMode}: \qcode{none},
\qcode{char}, \qcode{word}, or \qcode{word\_char}. The justification
for the entire buffer is controlled by the \code{justification}
property which takes values of \qcode{left}, \qcode{right},
\qcode{center}, or \qcode{fill} from \code{GtkJustification}.  The
global value may be overridden for parts of the text buffer through
the use of text tags, see Section~\ref{sec:gtk-mvc-text-tags}. The
left and right margins are adjusted through the \code{left-margin} and
\code{right-margin} properties.

%% buffer - wide font
\paragraph{Fonts}
%% ML: do we need a general overview of Pango fonts?
The size and font can be globally set for a text view using the
\method{modifyFont}{GtkWidget} method. To set the font for specific
regions, use text tags (see Section~\ref{sec:gtk-mvc-text-tags}). The
font is specified as a Pango font description, which may be generated
from a string through \code{pangoFontDescriptionFromString}. These
strings may contain up to 3 parts: the first is a comma-separated list
of font families, the second a white-space separated list of style
options, and the third a size in points or pixels if the units ``px''
are included. A typical value might look like \code{"serif, monospace
  bold italic condensed 16"}. The various style options are enumerated
in \code{PangoStyle}, \code{PangoVariant}, \code{PangoWeight},
\code{PangoStretch}, and \code{PangoGravity}. The help page for
\code{PangoFontDescription} contains more information.

%% ML: stuff that could be described: automatic scrolling, and mapping
%% locations to text iterators. Already mentioned in the example though.

\section{Text buffers}
\label{sec:RGtk2:text-buffers}

Text buffer properties include \code{text} for the stored text and
\code{has-selection} to indicate if text is currently selected in a
view. The buffer also tracks if it has been modified. This information
is available through the buffer \method{getModified}{GtkTextBuffer}
method, which returns \code{TRUE} if the buffer has changed. To clear
this state, such as when a buffer has been saved to disk, one can pass
\code{FALSE} to \method{setModified}{GtkTextBuffer}.

In order to do more with a text buffer, such as retrieve a selection,
or modify text attributes, one needs to become familiar with the two
mechanism for referencing text in a buffer: iterators and marks.  A
text iterator is an opaque, transient pointer to a region of text,
whereas a text mark specifies a location that remains valid across
buffer modifications.

\subsection{Iterators}

%% text iters. GetStartIterm GetEndIter, GetSelectionBounds
%% transient

%% An iterator
In \GTK{} a \dfn{text iterator} is the primary means of specifying a
position in a buffer.  As mentioned in
Section~\ref{sec:RGtk2:mvc:iterators}, iterators are typically
transient, in the sense that they are invalidated or updated by
reference when their source is modified.

%% methods to return an iterator
Several methods of the text buffer return iterators marking positions
in the buffer.  Iterators are returned as lists with two components:
\code{iter}, which represents the actual C iterator object, and
\code{retval}, a logical value indicating whether the iterator is
valid.  The beginning and end of the buffer are returned by the
methods \method{getStartIter}{GtkTextBuffer} and
\method{getEndIter}{GtkTextBuffer}. Both of these iterators are
returned together in a list by the method
\method{getBounds}{GtkTextBuffer}.  For example:
<<gtk-mvc-buffer-iter-bounds>>=
bounds <- buffer$getBounds()
bounds
@ 
%
%% JV in the following I had to change bounds$start$iter to just
%% bounds$start. Not sure if this has changed in the newer RGtk2 -- I
%% had trouble installing the svn version due to a missing cairo
%% function. I'm stuck for now with the 2.18 from att.research.com package
The current selection is returned by the method
\method{getSelectionBounds}{GtkTextBuffer}, as a list of the same
structure. If there is no selection, then the component \code{retval}
will be \code{FALSE}, otherwise it is \code{TRUE}.

One can also obtain an iterator for a specific position in a
document. The method \method{getIterAtLine}{GtkTextBuffer} will return an
iterator pointing to the start of the line, which is specified by
$0$-based line number. The method
\method{getIterAtLineOffset}{GtkTextBuffer} has an additional argument
to specify the offset for a given line. An offset counts the number of
individual characters and keeps track of the fact that the text
encoding, UTF-8, may use more than one byte per character. For
example, we might request the seventh character of the first line:
<<gtk-mvc-buffer-iter-atLineOffset>>=
iter <- buffer$getIterAtLineOffset(0, 6)
iter$iter$getChar()                     # unicode, not text
@ 
%
In addition to the text buffer, a text view also has the method
\method{getIterAtLocation}{GtkTreeView} to return the iterator
indicating the between-word space in the buffer closest to the point
specified in $x$-$y$ coordinates.

Once we obtain an iterator, we typically enter a loop which performs
some operation on the text at the iterator position and updates the
iterator with each iteration. This requires retrieving the text to
which an iterator refers. The character at the iterator position is
returned by \method{getChar}{GtkTextIter}. We obtain the first
character in the buffer:
<<gtk-mvc-buffer-iter-getChar>>=
bounds$start$getChar()                  # unicode
@ 
%
To obtain the text between two text
iterators, call the \method{getText}{GtkTextIter} method on the left
iterator, passing the right iterator as an argument:
<<gtk-mvc-buffer-iter-getText>>=
bounds$start$getText(bounds$end)
@ 
%
The \method{insert}{GtkTextBuffer} method will insert
text at a specified iterator:
<<gtk-mvc-buffer-iter-insert>>=
buffer$insert(bounds$start, "prefix")
@ 
%
The \method{delete}{GtkTextBuffer} method will delete the text between
two iterators.  An important observation is that we always pass the
actual iterator, i.e., the \code{iter} component of the list, to the
above methods. Passing the original list would not work.

%% iter methods
Next, we introduce the methods for updating an iterator. One can move
an iterator forward or backward, stopping at a certain type of
landmark. Supported landmarks include characters
(\method{forwardChar}{GtkTextIter},
\method{forwardChars}{GtkTextIter},
\method{backwardChar}{GtkTextIter}, and
\method{backwordChars}{GtkTextIter}), words
(\method{forwardWordEnd}{GtkTextIter},
\method{backwardWordStart}{GtkTextIter}), and sentences
(\method{backwardSentenceStart}{GtkTextIter} and
\method{forwardSentenceEnd}{GtkTextIter}).  There are also various
methods, such as \method{insideWord}{GtkTextIter}, for determining the
textual context of the iterator. Example~\ref{eg:RGtk2-find-word}
shows how some of the above are used, in particular how these methods
update the iterator rather than return a new one.

\begin{example}{Finding the word that is clicked by the user}{eg:RGtk2-find-word}
<<echo=FALSE>>=
## setup example, not shown
w <- gtkWindow()
view <- gtkTextView()
w$add(view)
@ 
%%

This example shows how one can find the iterator corresponding to a
mouse click. In the callback we obtain the $X$ and $Y$ coordinates of
the mouse button press event, find the corresponding iterator, and
retrieve the surrounding word:
<<FindWordAtMouseClick>>=
gSignalConnect(view, "button-press-event", 
       f=function(view, event, ...) {
         start <- view$getIterAtLocation(event$getX(), 
                                         event$getY())$iter
         end <- start$copy()
         start$backwardWordStart()
         end$forwardWordEnd()
         val <- start$getText(end)
         print(val)
         return(FALSE) # call next handler
       })
@   
\end{example}

\subsection{Marks}

A text mark tracks a position in the document that is relative to
other text and is preserved across buffer modifications. One can think
of a mark as an invisible object stuck between two characters. An
example is the text cursor, the position of which is represented by a
mark.

Marks are identified by name. We retrieve the mark for the
cursor, which is called \qcode{insert}:
<<gtk-mvc-text-mark-insert>>=
insert <- buffer$getMark("insert")
@ 

To access the text at a mark, we need to find the corresponding iterator:
<<gtk-mvc-text-mark-getIter>>=
insert_iter <- buffer$getIterAtMark(insert)$iter
bounds$start$getText(insert_iter)
@ 

Marks have a gravity of \qcode{left} or \qcode{right}, with
\qcode{right} being the default. If text is inserted at a mark with
right gravity, then the mark is moved to the end of the insertion. A
mark with left gravity would not be moved. This is intuitive if one
relates it to the behavior of the text cursor, which has right
gravity. For obvious reasons, the cursor always advances as the user
inserts text by typing. We demonstrate this programmatically:
<<gtk-mvc-text-mark-gravity>>=
insert_iter$getOffset()
buffer$insert(insert_iter, "at insertion point")
buffer$getIterAtMark(insert)$iter$getOffset()
@ 

A custom mark is created with its name, gravity and position. We
create one for the start of the document:
<<gtk-mvc-text-mark-construct>>=
mark <- buffer$createMark(mark.name = "start", 
                          where = buffer$getStartIter()$iter, 
                          left.gravity = TRUE)
@ 
%
By setting \argument{left.gravity}{gtkTextBufferCreateMark} to \qcode{TRUE}, the
iterator will not move when text is inserted.

%% tag Table
\subsection{Tags}
\label{sec:gtk-mvc-text-tags}

Tags are annotations placed on specific regions of a text buffer. To
create a tag, we call the \method{createTag}{GtkTextBuffer} method,
which takes an argument for each attribute to apply to the text. Here,
we create three tags: one for bold text, one for italicized text and
one for large text:
<<gtk-mvc-text-tags-create>>=
tag_bold <- buffer$createTag(tag.name="bold", 
                             weight=PangoWeight["bold"])
tag_emph <- buffer$createTag(tag.name="emph", 
                             style=PangoStyle["italic"])
tag_large <- buffer$createTag(tag.name="large", 
                              font="Serif normal 18")
@ 
%
Next, we associate the tags with one or more regions of text:
<<gtk-mvc-text-tags-apply>>=
iter <- buffer$getBounds()
buffer$applyTag(tag_bold, iter$start, iter$end) # iters update
buffer$applyTagByName("emph", iter$start, iter$end)
@ 

\iprogram{clipboard}
\subsection{Selection and the clipboard}

The selection is defined by the text buffer as the region between the
\qcode{insert} and \qcode{selection\_bound} marks. While we could
directly move the marks around, calling
\method{selectRange}{GtkTextBuffer} is more efficient and
convenient. Here, we select the first word:
<<gtk-mvc-text-selectRange, results=hide>>=
start_iter <- buffer$getStartIter()$iter
end_iter <- start_iter$copy(); end_iter$forwardWordEnd()
buffer$selectRange(start_iter, end_iter)
@ 

\class{GtkTextBuffer} provides some convenience methods for
interaction with the clipboard: \method{copyCliboard}{GtkTextBuffer},
\method{cutClipboard}{GtkTextBuffer} and
\method{pasteClipboard}{GtkTextBuffer}. To use these, we first need a
clipboard object:
<<gtk-mvc-text-clipboard-get>>=
clipboard <- gtkClipboardGet()
@ 
%
We can then, for example, copy the selected text (the first word) and
paste it at the end:
<<gtk-mvc-text-clipboard-copy-paste>>=
buffer$copyClipboard(clipboard)
buffer$pasteClipboard(clipboard, 
            override.location = buffer$getEndIter()$iter, 
            default.editable = TRUE)
@ 
%
The \argument{default.editable}{pasteClipboard} indicates that the
pasted text should be editable. If we had passed \qcode{NULL}, to the
\argument{override.location}{pasteClipboard} argument, the insertion
would have occurred at the cursor.

% \begin{example}{Adding parentheses highlighting}{eg:RGtk2:paren-highlight}
%   \SweaveInput{ex-RGtk2-match-parentheses}
% \end{example}

%% insert images or widgets
\subsection{Inserting non-text items}

If desired, one can insert images and/or widgets into a text
buffer. The method \method{insertPixbuf}{GtkTextBuffer} will insert a
\class{GdkPixbuf} object. The buffer will count the image as a
character, although \method{getText}{GtkTextBuffer} will obviously not
return the image.

Arbitrary child widgets, like a button, can also be inserted. First,
one must create an anchor in the text buffer with
\method{createChildAnchor}{GtkTextBuffer}:
<<gtk-mvc-text-anchor>>=
anchor <- buffer$createChildAnchor(buffer$getEndIter()$iter)
@ 
%
To add the widget, we call the text view method
\method{addChildAtAnchor}{GtkTextView}:
<<gtk-mvc-text-addChild>>=
button <- gtkButton("click me")
view$addChildAtAnchor(button, anchor)
@ 

\begin{example}{A simple command line interface}{eg:RGtk2-command-line}
  \SweaveInput{ex-RGtk2-terminal}
\end{example}


% \begin{example}{Simple textview usage}{eg:RGtk2:simple-textview-usage}
%   \SweaveInput{ex-RGtk2-simple-textview}
% \end{example}



