<<echo=FALSE>>=
library(RGtk2)
@ 

Many widgets in \GTK\/ use the model, view, controller paradigm. While
many times the deatils are in the background, for the widgets in this chapter
one needs to be aware of the usage. This framework adds a layer of
complexity, in exchange for creating smarter components that can share
data more easily.



\section{Text views and text buffers} %% text buffer
\label{sec:RGtk2:textviews}

Multiline text areas are displayed through  \constructor{gtkTextView}
instances. These provide a view of an accompanying
\code{gtkTextBuffer}, which is the model that stores the text and
other objects to be rendered. The view is responsible for the display
of the text in the buffer, so has methods for adjusting tabs, margins,
indenting, etc. While the view stores the text so has methods for
adding and manipulating the text.

A text view is created with \constructor{gtkTextView}. The
\argument{buffer}{gtkTextView} argument is used to specify a text
buffer, otherwise one will be created. 
This buffer is returned by the
method \method{getBuffer}{gtkTextView} and may be set for a view with
the \method{setBuffer}{gtkTextView} method. Text views are typically
placed inside a scrolled window (Section~\ref{sec:RGtk2:scroll-windows}), and since a viewport is established,
this is done with the \method{add}{gtkBin} method for scrolled
windows.

%% simple use -- replace, Append, insert at cursor

Text may be added programmatically through various 
methods of the text buffer. The easiest to use are \method{setText}{gtkTextBuffer} which
simply replaces the current text with that specified by
\argument{text}{gtkTextBufferSetText}. The method
\method{insertAtCursor}{gtkTextBuffer} will add the text to the buffer
at the current position of the cursor. Other means are described after
the first example.

%% properties: editable, ...
\paragraph{Properties}
Key properties of the text view include \code{editable}, which if assigned
a value of \code{FALSE} will prevent users from editing the text. 
If the view is not editable, the cursor may be hidden by setting the
\code{cursor-visible} property to \code{FALSE}. 
The text in a buffer may be wrapped or not. The method \method{setWrapMode}{gtkTextView}
takes values from \code{GtkWrapMode} with default of \qcode{none}, but
options for \qcode{char}, \qcode{word}, or \qcode{word\_char}. The
justification for the entire buffer is controlled by the
\code{justification} property which takes values of \qcode{left},
\qcode{right}, \qcode{center}, or \qcode{fill} from \code{GtkJustification}.
The global value may be overwridden for parts of the text buffer
through the use of text tags. The left and right margins are adjusted
through the \code{left-margin} and \code{right-margin} properties. 

The text buffer has a few key properties, including \code{text} for
storing the text and \code{has-selection} to indicate if text is
currently selected in a view. The buffer also tracks if it has been
modified. This information is available through the buffer's
\method{getModified}{gtkTextBuffer} method, which returns \code{TRUE}
if the buffer has changes. The method
\method{setModifed}{gtkTextBuffer}, if given a value of \code{FALSE},
allows the programmer to change this state, say after saving a
buffer's contents.


%% buffer - wide font
\paragraph{Fonts}
The size and font can be globally set for a text view using the
\method{modifyFont}{gtkWidget} method. (Specifying fonts for parts of
the buffer requires the use of tags, described later.) The argument
\argument{font.desc}{gtkWidgetModifyFont} specifies the new font using
a Pango font description, which may be generated from a
string specifying the font through the function
\code{pangoFontDescriptionFromString}. These strings may contain up to
3 parts: the first is a comma-separated list of font families, the
second a white-space separated list of style options, and the third a
size in points or pixels if the units ``px'' are included. A typical
value might look like \code{"serif, monospace bold italic condensed
  16"}. The various style options are enumerated in \code{PangoStyle},
\code{PangoVariant}, \code{PangoWeight}, \code{PangoStretch}, and
\code{PangoGravity}. The help page for \code{PangoFontDescription}
contains more information.

\paragraph{Signals}
The text buffer emits many different types of signals detailed in the
help page for \function{gtkTextBuffer}. Most importantly, the
\signal{changed} signal is emitted when the content of the buffer
changes. The callback for a \signal{changed} signal has signature that
returns the text buffer and any user data.


\begin{example}{Simple textview usage}{eg:RGtk2:simple-textview-usage}
  \SweaveInput{ex-RGtk2-simple-textview}
\end{example}

\subsection{Tags, iterators, marks}
\label{sec:RGtk2:tags-iterators-marks}

In order to do more with a text buffer, such as retrieve the text, 
retrieve a selection, or modify attributes of just some of the text,
one needs to become familiar with how pieces of the buffer are
referred to within \GTK.

There are two methods: text iterators (iters) are a transient means to
mark begin and end boundaries within a buffer, whereas text marks
specify a location that remains when a buffer is modified. One can use
these with tags to modify attributes of pieces of the buffer.


\paragraph{Iterators}

%% text iters. GetStartIterm GetEndIter, GetSelectionBounds
%% transient

%% An iterator
An \dfn{iterator} is a programming object used to traverse through
some data, such as a text buffer or table of values. Iterators are
typically transient. They have
methods to indicate what they point to and often update these
values without an explicit function call. Such behaviour is unusual
for typical \R\/ programming.


In \GTK{} a \dfn{text iterator} is used to specify a position in a
buffer. Iterators become invalid as soon as a buffer changes, say
through the addition of text.  In \pkg{RGtk2}, iterators are stored as
lists with components \code{iter} to hold a pointer to the underlying
iterator and component \code{retval} to indicate whether the iterator
when it was returned is valid. Many methods of the text buffer will
update the iterator. This can happen inside a function call where the
iterator is passed as an argument -- basically a copy is not passed
in. The \method{copy}{gtkTextIter} method will create a copy of an
iterator, in case one is to be modifed but it is important to keep the original.

%% methods to return an iterator
Several methods of the text buffer return iterators marking positions
in the buffer.  The beginning and end of the buffer are returned by
the methods \method{getStartIter}{gtkTextBuffer} and
\method{getEndIter}{gtkTextBuffer}. Both of these iters are returned
at once by the method \method{getBounds}{gtkTextBuffer} again as
components of a list, in this case \code{start} and \code{end}.  The
current selection is returned by the method method
\method{getSelectionBounds}{gtkTextBuffer}. Again, as a list of
iterators specifying the start and end positions of the current
selection. If there is no selection, then the component \code{retval}
will be \code{FALSE}, otherwise it is \code{TRUE}.

The method \method{getIterAtLine}{gtkTextBuffer} will return an
iterator pointing to the start of the line, which is specifed by
$0$-based line number. The method
\method{getIterAtLineOffset}{gtkTextBuffer} has an additional argument
to specify the offset for a given line. An offset counts the number of
individual characters and keeps track of the fact that the text
encoding, UTF-8, may use more than one byte per character.  In
addition to the text buffer, a text view also has the method
\method{getIterAtLocation}{gtkTreeView} to return the iterator
indicating the between-word space in the buffer closest to the point
specified in $x$-$y$ coordinates.

%% iter methods
There are several methods for iterators that allow one to refer to
positions in the buffer relative to the iterator, for example, these
with obvious names to move a character or characters:
\method{forwardChar}{gtkTextIter}, \method{forwardChars}{gtkTextIter},
\method{backwardChar}{gtkTextIter}, and
\method{backwordChars}{gtkTextIter}. As well, there are methods to
move to the end or beginning of the word the iterator is in or the end
or beginning of the sentence (\method{forwardWordEnd}{gtkTextIter},
\method{backwardWordStart}{gtkTextIter},
\method{backwardSentenceStart}{gtkTextIter}, and
\method{forwardSentenceEnd}{gtkTextIter}).  There are also various methods,
such as \method{insideWord}{gtkTextIter}, returning logical values
indicating if the condition is met.
To use these methods, the iterator in the
\code{iter} component is used, not the value returned as a
list. Example~\ref{eg:RGtk2-find-word} shows how some of the above are
used, in particular how these methods update the iterator rather than
return a new one.

%% using iters: Insert, Delte, GetText
\paragraph{Modifying the buffer}
Iterators are specified as arguments to several methods to set and
retrieve text. The \method{insert}{gtkTextBuffer} method will insert
text at a specified iterator. The argument
\argument{len}{gtkTextBufferInsert} specifies how many bytes of the
\code{text} argument are to be inserted. The default value of $-1$
will insert the entire text. This
method, by default, will also update the iterator to indicate the end
of where the text is inserted. The \method{delete}{gtkTextBuffer}
method will delete the text between the iterators specified to the
arguments \argument{start}{gtkTextBufferDelete} and
\argument{start}{gtkTextBufferDelete}. The
\method{getText}{gtkTextBuffer} method will get the text between the
specified \argument{start}{gtkTextBufferDelete} and
\argument{end}{gtkTextBufferDelete} iters. A similar method
\method{getSlice}{gtkTextBuffer} will also do this, only it includes
offsets to indicate the presence of images and widgets in the text
buffer.

\begin{example}{Finding the word one clicks on}{eg:RGtk2-find-word}
This example shows how one can find the iterator corresponding to a
mouse-button-press event. The callback has an event argument which is
a \class{GdkEventButton} object with methods
\method{getX}{GdkEventButton} and \method{getY}{GdkEventButton} to
extract the \code{x} and \code{y} components of the event
object. These give the position relative to the widget.~\footnote{The methods
\method{getXRoot}{GdkEventButton} and
\method{getYRoot}{GdkEventButton} give the position relative to the
parent window the widget resides in.}

<<echo=FALSE>>=
## setup example, not shown
w <- gtkWindow()
tv <- gtkTextView()
w$add(tv)
@ 

<<FindWordAtMouseClick>>=
ID <- gSignalConnect(tv, "button-press-event", f=function(w, e, ...) {
  siter <- w$getIterAtLocation(e$getX(), e$getY())$iter
  niter <- siter$copy()                 # need copy
  siter$backwardWordStart()
  niter$forwardWordEnd()
  val <- w$getBuffer()$getText(siter, niter)
  print(val)                            # replace
  return(FALSE)                         # call next handler
  })
@   
\end{example}


\paragraph{Marks}
In addition to iterators, \GTK\/ provides marks to indicate positions
in the buffer that persist through changes. For instance, the mark
\qcode{insert} always refers to the position of the cursor. Marks have a
gravity of \qcode{left} or \qcode{right}, with \qcode{right} being the
default. When the text surrounding a mark is deleted, if the gravity
is \qcode{right} the mark will remain to the right af any added
text. 


Marks can be defined in two steps by calling \function{gtkTextMark},
specifying a name and a value for the gravity, and then 
positioned within a buffer, specified by an iterator, through the
buffer's \method{addMark}{gtkTextBuffer} method. The
\method{createMark}{gtkTextBuffer} method combines the two steps.

There are many text buffer methods to work with marks. The
\method{getMark}{gtkTextBuffer} method will return the mark object for
a given name. (There are functions which refer to the name of a mark,
and others requiring the mark object.) The method \method{getIterAtMark}{gtkTextBuffer} will return
an iterator for the given mark to be used when an iterator is needed.



%% tag Table
\paragraph{Tags}
Marks and iterators can be used to specify different properties for
different parts of the text buffer. \GTK\/ uses tags to specify how
pieces of text will differ from those of the textview overall. To
create a tag, the \method{createTag}{gtkTextBuffer} method is
used. This has optional argument
\argument{tag.name}{gtkTextBufferCreateTag} which can be used to refer to
the tag later, and otherwise uses named arguments so specify a properties
names and the corresponding values. These tags may be applied to the text between
two iters using the methods \method{applyTag}{gtkTextBuffer} or
\method{applyTagByName}{gtkTextBuffer}.

\begin{example}{Using text tags}{eg:RGtk2:using-text-tags}
We define two text tags to make text bold or italic and illustrate how
to apply them.
<<>>=
tv <- gtkTextView()
tb <- tv$getBuffer()
tb$setText("the quick brown fox jumped over the lazy dog")
##
tag.b <- tb$createTag(tag.name="bold", 
                      weight=PangoWeight["bold"])
tag.em <- tb$createTag(tag.name="em", 
                       style=PangoStyle["italic"])
tag.large <- tb$createTag(tag.name="large", 
                          font="Serif normal 18")
##
iter <- tb$getBounds()         # or get iters another way
tb$applyTag(tag.b, iter$start, iter$end)  # updates iters
tb$applyTagByName("em", iter$start, iter$end)
@ 
\end{example}


\paragraph{Interacting with the clipboard}
\GTK\/ can create clipboards and provides convenient access to the
default clipboard so that the standard cut, copy and paste actions can
be implemented. The function \function{gtkClipboardGet} returns the
default clipboard if given no arguments. The clipboard is the lone
argument for the method \method{copyCliboard}{gtkTextBuffer} to copy
the current selection to the clipboard. The method
\method{cutClipboard}{gtkTextBuffer} has an extra argmument,
\code{default.editable}, which is typically \code{TRUE}. The
\method{pasteClipboard}{gtkTextBuffer} method is used paste the
clipboard contents into the buffer, the second argument is \code{NULL}
to paste at the insert are, or an iterator specifying otherwise where
the text should be inserted. The third argument is \code{TRUE} if the
pasted text is to be editable.

\begin{example}{A simple command line interface}{eg:RGtk2-command-line}
  \SweaveInput{ex-RGtk2-terminal}
\end{example}


% \begin{example}{Adding parentheses highlighting}{eg:RGtk2:paren-highlight}
%   \SweaveInput{ex-RGtk2-match-parentheses}
% \end{example}

%% insert images or widgets
\paragraph{Inserting non-text items}
If desired, one can insert images and/or widgets into a text buffer,
although this isn't a common use within statistical GUIs. The method
\method{insertPixbuf}{gtkTextBuffer} will insert into a position
specified by an iter a \class{GdkPixbuf} object. In the buffer, this
will take up one character, but will not be returned by
\method{getText}{gtkTextBuffer}. 

Arbitrary child components can also be inserted. To do so an anchor
must first be created in the text buffer. The method
\method{createChildAnchor}{gtkTextBuffer} will return such an anchor, and
then the text view method \method{addChildAtAnchor}{gtkTextView} can
be used to add the child.

<<NotShown, echo=FALSE>>=
## Not shown, but this shows how to add a button to a text view widget
b <- gtkButton("click me")              # child
end <- tb$getEndIter()$iter             # get  an iter
anchor <- tb$createChildAnchor(end)     # make anchor
tv$addChildAtAnchor(b, anchor)          # set widget at anchor
@ 


\section{Views of tabular and heirarchical data}
\label{sec:RGtk2:tabular-heirarchical-data}

Widgets to create comboboxes, display tabular data values, and to
display tree-like data are treated similarly in \GTK. Each uses the
MVC paradigm and for these, the models are defined similarly.
We begin by discussing the models, then present the various
views. Each view is described by its column, which in turn have their
cells specifed by cell renderers.


\subsection{Tabular  stores and tree stores}
\label{sec:tabular-stores-tree}

\GTK\/ provides list stores and tree stores as models to hold tabular and
heirarchical data to be viewed through various widgets, such as the
combo box or tree view. Like a data frame, each row in these stores
contains data of varying types. The main difference between the two is
that tree stores also have information about about whether a row has
any offspring. The list store is just a tree store where there
are no children of the top-level offspring.

For speed, much greater convenience and familiarity purposes, \pkg{RGtk2} provides a third store
through \constructor{rGtkDataFrame} for storing data frames.

\paragraph{rGtkDataFrame}

\R\/ uses data frames to hold tabular data, where each column is of a
certain class, and each row is related to some observational
unit. This is also the way tree views are organized when no
heirarchical structure is needed. As such it is natural to have a
means to map a data frame into a store for a tree view. The
\constructor{rGtkDataFrame} constructor does this, producing an object
that can be used as the model for a view. This \R-specific
addition to \GTK\/ not only is more convenient, it has the added bonus
of being especially fast. The constructor takes a data frame as an
argument. The column classes are important, so even if this data frame
is empty, it should specify the desired column classes.

The constructor produces an object of class \class{RGtkDataFrame}
for which the familiar S3 methods
\method{[}{RGtkDataFrame}, \method{[\ASSIGN}{RGtkDataFrame},
\method{dim}{RGtkDataFrame}, and \method{as.data.frame}{RGtkDataFrame}
are defined. The \code{dimnames} attributes are kept, but have no
well-defined meaning
for this model. The \code{[$<$-} method does not have quite the same
functionality, as it does for a data frame. Columns can not be removed
by assigning values to \code{NULL}, column types
should not be changed which can be an issue with coercion to character from numeric
say, rows can not be dropped. To add a new column or row, the methods
\method{appendColumns}{rGtkDataFrame} and
\method{appendRows}{rGtkDataFrame} may be used, where the new column
or row may be given as the argument.

To remove rows from this model, the \method{setFrame}{rGktDataFrame}
method can be used to specify the new data. This method can also be used
to replace the existing data in the model with a new data
frame. There are few issues though. If the new data frame has more
rows or columns, then the appropriate \code{append} method should be
used first. As well, one should not change the column classes with the
new frame, as views of the model may be expecting a certain class of data.

\begin{example}{Defining and manipulating a data store}{eg-RGtk2-manipulate-rGtkDataframe}
  The basic data frame methods are similar.
<<>>=  
data(Cars93, package="MASS")            # mix of classes
model <- rGtkDataFrame(Cars93)
model[1, 4] <- 12
model[1, 4]                              # get value
@ 
Factors are treated differently from character values, as is done with
data frames, so assignment to a factor must be from one of the
possible levels.

To change the backend data, we can use the \code{SetFrame} method:
<<>>=
QT <- model$setFrame(Cars93[1:5, 1:5])
@ 
\end{example}


\paragraph{List stores and tree stores}
Although the \code{rGtkDataFrame} model is very useful, there are
times when it can't be employed. List stores can be used when the
underlying data contains values that can not be stored in a data frame
(such a images) and tree stores are used for heirarchical data. 

%% construction
A tree store or list store is constructed using
\constructor{gtkTreeStore} or  \constructor{gtkListStore}. Both are
interfaces for the abstract \class{GtkTreeModel} class. The
column types are specified through a character vector at the time of
construction. The specification uses ``GTypes'' such as
\code{gchararray} for character data, \code{gboolean} for logical data,
\code{gint} for integer data, \code{gdouble} for numeric data, and
\code{GObject} for \GTK\/ objects, such as pixbufs.

%% iters vs. paths
\paragraph{Iterators and tree paths}
Similar to a text buffer, a list store uses transient iterators to
refer to position -- in this case the row -- within a store. One can
also refer to position through a path, which for a list store is
essentially the row number, $0$-based, as a character; and for a tree
is a colon-separated set of values referring to the offspring
(\qcode{a:b:c} indicates the \code{c}th child of the \code{b}th child
of \code{a}).  A third way, through a row reference, is not discussed
here.

%% paths
A \class{GtkTreePath} object is created by the constructor
\code{gtkTreePathNewFromString} which takes a string specifying the
position. To retrieve this string from a path object, the
\method{toString}{gtkTreePath} method can be used.

%% iters
Paths are convenient, as they are human readable, but iterators are
empolyed by the various methods and more easily allow the programmer
to traverse the store. One can flip between the two
representations. The iterator referring to the path can be returned by
the method \method{getIterFromString}{gtkTreeModel}. The method
\method{getStringFromIter}{gtkTreeModel} will return the string. The
tree path object itself is returned by the method
\method{getPath}{gtkTreeModel}.  In \pkg{RGtk2} iterators are lists
with component \code{retval} indicating if this is a valid iterator
and a component \code{iter} holding the object of the
\class{GtkTreeIter} class.

%% adding to a storex
\paragraph{Adding values to a store}
Values are added to and returned from a store by specifying the row
and column for the value. The row is specified by an iterator and the
columns by its index, $0$-based.  The method
\method{setValue}{gtkListStore} is used to specify value by value,
whereas an entire row can be assigned through the
\method{set}{gtkTreeStore} method. The former has arguments
\code{iter}, \code{column}, \code{value}, in that order; the latter
has no \code{column} or \code{value} argument. Instead, \meth{set}
uses positional arguments to specify the column and the value. The
column index appears as an even argument (say $2k$) and the
corresponding value in the odd argument (say $2k+1$).  When calling
\code{setValue} or \code{set} the iterator updates to the next row.
Values are returned by the \method{getValue}{gtkListStore} method, in
a list with component \code{value} storing the value.

\paragraph{Finding iterators}
For a list or tree model, an iterator for the first child is returned
by \method{getIterFirst}{gtkTreeStore}. This iterator corresponds to
the path \qcode{0}.
The \method{append}{gtkStore}
method for the store returns an iterator indicating the next value at
the end of the store (this is slightly different from the \GTK\/ function which
modifies an iterator passed as an argument).  The
\method{prepend}{gtkTreeStore} method is similar, only returning an
iterator pointing to the initial row.  Other methods allow for
specifying postion relative to some row. The
\method{insert}{gtkListStore} method is used to return an iterator
that allows one to insert a row at a position specified to its
\code{position} argument. (The \code{Prepend} method is similar to
using \code{postion=0}). To avoid the two-step approach of getting the
iterator, then assigning the value, the method
\method{insertWithValues}{gtkListStore} can be used, where values are
specified as with the \code{Set} method.  The
\method{insertBefore}{gtkListStore}, and
\method{insertAfter}{gtkListStore}, methods take an iterator,
\code{sibling} and will return an iterator indicating the postion just
before or after the sibling.




\begin{example}{Appending to a list store}{eg:RGtk2:list-store}
  To illustrate, to create a simple list store to hold a column
of text we have:  
<<AppendListStore>>=
lstore <- gtkListStore("gchararray")
QT <- sapply(Cars93[,1], function(i) {
  iter <- lstore$append()
  if(is.null(iter$retval)) 
    lstore$setValue(iter$iter, 0, i)
})
@ 
To retrieve a value, we have this example to get the first one in the store:
<<>>=
iter <- lstore$getIterFirst()           # first row
lstore$getValue(iter$iter, column = 0)
@ 
\end{example}

\paragraph{Adding heirarchical information}

For a tree store, the methods \method{append}{gtkTreeStore},
\method{prepend}{gtkTreeStore} etc. are similar to that for a list
store with the difference being that a
\argument{parent}{gtkTreeStoreAppend} argument is used for tree stores
to specify in iterator for the parent of the new row, thereby creating
the heirarchical structure of a tree.


\begin{example}{Defining a tree}{eg:RGtk2:tree-store}
  As an application, we can create a tree with parents the car
  manufacturers in the \code{Cars93} data set, and children the makes
  of their cars, as follows:
<<>>=
tstore <- gtkTreeStore("gchararray")
Manufacturers <- Cars93$Manufacturer
Makes <- split(Cars93[,"Model"], Manufacturers)
for(i in unique(Manufacturers)) {
  piter <- tstore$append()              # parent
  tstore$setValue(piter$iter, column=0, value=i)
  for(j in Makes[[i]]) { 
    sibiter <- tstore$append(parent=piter$iter) # child
    if(is.null(sibiter$retval)) 
      tstore$setValue(sibiter$iter,column=0, value=j)
  }
}
@ 
To retrieve a value from the tree store using its path we have:
<<>>=
iter <- tstore$getIterFromString("0:0") #  the 1st child of root
tstore$getValue(iter$iter,column=0)$value
@ 
\end{example}


%% Manipulating rows
\paragraph{Manipulating rows}
Rows within a store can be rearranged using the methods
\method{swap}{gtkTreeStore} to swap rows referenced by their
iterators; \method{moveAfter}{gtkTreeStore} to move one row after
another, both referenced by iterators, although if the last is blank,
the end of the store is assumed; and
\method{moveBefore}{gtkTreeStore}, where if the second iterator is
blank the first position is assumed. To totally reorder the store, the
\method{reorder}{gtkTreeStore} method is available. Its
\argument{new.order}{gtkTreeStore} argument specifies the new
order as row indices. For tree stores, these rows are the children of the
\argument{parent}{gtkTreeStoreReorder} argument.

%% clearing contents
Once added, rows may be removed using the
\method{remove}{gtkTreeStore} method. The iterator for the row to
delete is given as an argument. The store's entire contents can be
removed by its \method{clear}{gtkTreeStore} method.


%% Traversing
\paragraph{Traversing the store}
An iterator points to a row in a tree or list store. For both lists
and trees, an interator pointing to the next row (at the same level
for trees) is produced by the method
\method{iterNext}{gtkTreeStore}. This method returns \code{FALSE} if
no next row exists. Otherwise, it updates the iterator in place. (That
is, calling \command{store\$iterNext(iter\$iter)} updates \code{iter},
despite it not being assigned to.) The path method \method{prev}{gtkTreePath}
will point to the previous child at the same depth in a tree, but no
such method is defined for iterators. One could be, for example the
following will do so for both list and tree stores.

<<PreviousIter>>=
gtkTreeModelIterPrev <- function(object, iter) {
  path <- object$getPath(iter)
  ret <- path$prev()
  if(ret)
    return(list(retval=NULL, iter=object$getIter(path)$iter))
  else
    return(list(retval=FALSE,iter=NA))
}
@ 

For trees, the method \method{iterParent}{gtkTreeModel} returns an
iterator to point to the parent row, if no parent is found. The
\code{retval} component is \code{FALSE}.
There are several methods when a row has children.  The
method \method{iterHasChild}{gtkTreeModel} returns a logical
indicating if a row has children. The method
\method{iterChildren}{gtkTreeModel} returns an iterator to point to
the first child of parent. If no child exists, the \code{retval}
component is \code{FALSE}. If an iterator for the $n$th child is desired, the
method \method{iterNthChild}{gtkTreeModel} can be used. Again, it returns
an iterator referring to the $n$th child, or has a \code{retval} of
\code{FALSE} if
none exists. To find the number of children, the method
\method{iterNChildren}{gtkTreeModel} is provided. This method returns
$0$ if there are no children.

\begin{figure}
%%  \centering
  \includegraphics[width=.7\textwidth]{traverse-tree}
  \caption{[REPLACEME!] Graphical illustration of the functions used by iters to traverse a tree store. }
  \label{fig:traverse-iter}
\end{figure}

\subsection{Cell renderers}
\label{sec:RGtk2:cellrenderers}
The various views ultimately display the information in the model
column by column (a combobox having one column). Within each column,
the display is controlled by cell renderers, which are used to specify
how each cell is layed out. Cell renderers are used whenever the 
\code{gtkCellLayout} interface is implemented, such as with comboboxes
and tree views, but also other widgets not discussed here.

A cell renderer is customized by adjusting its attributes. These
attributes are documented in the help pages for the corresponding
constructor. These attributes can be set to one value for all rows, or
can be set to depend on a corresponding row in the model. The latter
allows them to change from cell to cell. For example, the \code{text}
attribute of the text cell renderer would usually get its values from
the model, as that would vary from cell to cell, but a background
color (\code{background}) might be common to the column. The
\method{addAttribute}{gtkCellLayout} method is used to associate a
column in the store with a cell renderer's attribute.

There are many different cell renderers, we mention first the text and
pixbuf renderer, as they are commonly used in comboboxes. With the
discussion of tree views, we mention others.

%% text/ numbers
\paragraph{Text cell renderers}
The \constructor{gtkCellRendererText} constructor is used to display
text and numeric values. Numeric values are shown as strings, but are
not converted in the model.  For the text renderer, important
properties are \code{text} to indicate the column in the data store
that the text for the cell is to come from, \code{font} to specify the
font from a string, \code{size} for the font size, \code{background}
for the background color and \code{foreground} for the text color (as
strings).

To display right-aligned text in a Helvetica font, the following could be used:
<<cr-right-aligned>>=
cr <- gtkCellRendererText()
cr['xalign'] <- 1                       # default 0.5 = centered
cr['family'] <- "Helvetica"  
@ 
The \code{wrap} attribute can be specified as \code{TRUE}, if the
entries are expected to be long. There are several other attributes that can
changed. 

%% pixbuf
\paragraph{Pixbuf cell renderers}
Graphics can be added to the cell with the renderer
\constructor{gtkCellRendererPixbuf}. The graphic can be spepcified by
its \code{stock-id} attribute as a character string, or
\code{icon-name} for a themed icon. It can also be specifed as an
image object, through the \code{pixbuf} attribute. Pixbuf objects can
be placed in a list store using the \code{GObject} type. A simple use,
might be the following:
<<CellRendererPixbufExample>>=
cr <- gtkCellRendererPixbuf()
cr['stock.id'] <- "gtk-ok" ## or from a column in a model
@ 


% <<CellRendererExample>>=
% cr <- gtkCellRendererText()
% cr['family'] <- "Helvetica"             # font family for whole column
% cr['background'] <- "goldenrod"         # background color for column
% crp <- gtkCellRendererPixbuf();         # a pixbuf
% crp['xalign'] <- 0
% @

% Cellrenderers define how data is to be displayed. The binding of the
% data to the cell renderer is handled by the view, not the
% cellrenderer.

\subsection{Combo boxes}
\label{sec:RGtk2:combobox}

The basic combo box usage was discussed in
Section~\ref{sec:RGtk2:basic-combobox}, here we discuss more
complicated comboboxes that use an explicit model for the backend This data is
tabular and may be kept in a \function{rGtkDataFrame} instance or a
list store.  

The basic \constructor{gtkComboBoxEntryNewWithModel} constructor
allows one to specify the model, and a column where the values are
found. For this, the cell renderers (below) are not needed.

If some layout of the values in the combobox is desired, such as adding an image,
then the constructor
\constructor{gtkComboBox} is used. The model may be specified at the time of
construction through the optional \argument{model}{gtkComboBox}
argument.  This model may be changed or set through the
\method{setModel}{gtkComboBox} method and is returned by
\method{getModel}{gtkComboBox}.

The constructor \constructor{gtkComboBoxEntry} returns a combobox
widget that allows the user to add their own values. This constructor
does not allow the model to be specified, so the \code{SetModel}
method must be used. The editable combobox uses a \code{gtkEntry}
object, which can be accessed directly through the
\method{getChild}{gtkBin} method of the combobox.

\paragraph{Cellrenderers}
Comboboxes display rows of data, each row referred to as a cell. In \GTK\/ each cell is like a box
container and can show different bits of information, like an image or
text. Each bit of information is presented by a cellrenderer.
Cellrenderers are added to the combo box by its
\method{packStart}{gtkCellLayout} method. As with box containers, more
than one cell renderer can be added per row.

To specify the data from the model to be
displayed, the \method{addAttribute}{gtkCellLayout} method maps
columns of the model to attributes of the cellrenderer. 



%% get value from widget
\paragraph{Retrieving the selected value}
For a non-editable combobox, the selected value may be retrieved by
index or by iterator. The \method{getActive}{gtkComboBox} method
returns the index of the current selection, $0$-based. The value is $-1$
if no selection has been made. The
\method{getActiveIter}{gtkComboBox} method returns an iterator
pointing to the row in the data store. If no row has been selected,
the \code{retval} component of the iterator is \code{FALSE}. These may
be used with the data store to retrieve the value. The data store
itself is returned by the \method{getModel}{gtkComboBox} method.

To set the combobox to a certain index is done through the
\method{setActive}{gtkComboBox} method, using a $0$-based index to
specify the row.

For editable comboboxes, one can first get the entry widget then call
its \code{GetText} method. The \code{SetText} method of the entry
widget would be used to specify the text.


%% signals
\paragraph{Signals}
When a user selects a value with the mouse, the \code{changed} signal
is emitted. For editable combo boxes, the user may also make changes
by typing in the new value. The underlying widget is a \code{gtkEntry}
widget, so the signal \code{changed} is emitted each time the text is
changed and the signal \code{activate} is emitted by the
\code{gtkEntry} widget when the \kbd{enter} key is pressed. One binds to
the signal of the entry widget, not the combobox widget, to have a
callback for that event.


\begin{example}{Modifying the values in a combobox}{eg-RGtk2-combobox-dynamic}
  \SweaveInput{ex-RGtk2-combobox-dynamic}
\end{example}

\begin{example}{A color selection widget}{eg:RGtk2:combobox}
 \SweaveInput{ex-RGtk2-combobox}
\end{example}


\subsection{Text entry widgets with completion}
\label{sec:RGtk2:entry-completion}

A common alternative to a combobox, implemented on many websites, is to add the completion features to a
\constructor{gtkEntry} instance. When a user types a partial match,
all available matches are offered to select from. To implement completion, one creates
a completion object with the constructor
\constructor{gtkEntryCompletion}. The values to complete from are
stored in a model, the example uses an \code{rGtkDataFrame} instance,
which is assigned to the completion object through its
\method{setModel}{gtkEntryCompletion} method. To set the completion
for the entry widget, the entry widget's
\method{setCompletion}{gtkEntry} method is used. The
\code{text-column} property is used to specify which column in
the model is used to find the matches.


There are several properties that can be adjusted to tailor the
completion feature, we metion some of them. Setting the property
\code{inline-selection} to \code{TRUE} will place the completion
suggestion to the entry inline as the completions are scrolled
through; \code{inline-completion} will add the common prefix
automatically to the entry widget; \code{popup-single-match} is a
logical indicating if a popup is displayed on a single match;
\code{minimum-key-length} takes an integer specifying the number of
characters needed in the entry before completion is checked, the
default is $1$.

By default, the rows in the data model that match the
current value of the entry widget in a case insensitive manner are displayed. This
matching function can be overridden by setting a new function through
the \method{setMatchFunc}{gtkEntryCompletion} method. The signature of
this function is the completion object, the string from the entry
widget (lower case), an interator pointing to a row in the model and optionally
user data that is passed through the \code{func.data} argument of the
\code{SetMatchFunc} method. This method should return \code{TRUE} or
\code{FALSE} depending on whether that row should be displayed in the
set of completions.


\begin{example}{Text entry with completion}{eg:RGtk2:text-entry-comletion}
\SweaveInput{ex-RGtk2-entry-completion}
\end{example}



\subsection{Tree Views}
\label{sec:RGtk2-tree-view}

%% intro
Both tabular data and tree-like data are displayed through tree
views. The visual difference is that a trigger icon appears in rows which
represent parents with children. When these are expanded, the
children are indicated by indentation. The children are all displayed
in a consistent tabular format.

%% constructor
A tree view is constructed by \constructor{gtkTreeView}. The
\argument{model}{gtkTreeView} can be used to specify the underlying
model. If not specified at the time of construction, the
\method{setModel}{gtkTreeView} can be used. The accompanying
\method{getModel}{gtkTreeView} model returns the model from the view.

%% tree view properties
Tree views have several properties. The \code{headers-clickable}
property, when set to \code{TRUE}, allows the column headers to
receive mouse clicks. This is used for sorting, when the underlying
data store allows for that. The tree view widget can popup a search
box when the user types \kbd{control-f} if the property
\code{enable-search} is \code{TRUE} (the default). To turn on
searching, a column needs to be specified through the
\code{search-column} property. Rows may be rearranged through
drag-and-drop if the \code{reorderable} property is set to
\code{TRUE}. The \code{rules-hint}, if \code{TRUE}, will instruct the
theme that the rows hold associated data. Themes will typically use this
information to stripe alternating rows.


%% treeviewcolumns
\paragraph{Tree view columns}
For speed purposes, the rendering of a tree view centers around the
display of its columns. Each column is displayed through a tree view
column, given by the \constructor{gtkTreeViewColumn}.

%% basic properties
One can set basic properties of the column. Each column has an
optional header that can contain a title or even an arbitrary
widget. The \method{setTitle}{gtkTreeViewColumn} method is used to set
the title. This area can be \qcode{clickable}, in which case this area
receives mouse clicks. This is most commonly used to allow sorting of
the column by clicking on the headers, but can also be used to add
popup menus (with a bit of wizardry).

The property \qcode{resizable} determines wheter the user can resize
the column, by dragging with the mouse. The size properties
\qcode{width}, \qcode{min-width}, and \qcode{fixed-width} control the
size.

The visibility of the column can be adjusted through the
\method{setVisible}{gtkTreeViewColumn} method. 


Tree view columns are added to the tree view with the
method \method{insertColumn}{gtkTreeView}. The
\argument{column}{gtkTreeViewInsertColumn} argument specifies the tree
view column, and the \argument{position}{gtkTreeViewInsertColumn}
argument the column to insert into ($0$-based). A column can be moved
with the \method{moveColumnAfter}{gtkTreeView} method, and removed
with the \method{removeColumn}{gtkTreeView} method. The tree view's
\method{getChildren}{gtkTreeView} method returns a list containing all
of the tree view columns.

%% cell renderers
\paragraph{More on cell renderers}

In addition to the text and pixbuf cell renderers discussed in
Section~\ref{sec:RGtk2:combobox}, there are cell renderers that allow
one to display other types of data available for the tree view widget.
Some only make sense if the underlying data is to be edited the
\code{editable} (or sometimes \code{activatable}) attribute for the
cell renderer should be set to \code{TRUE}.


As with comboboxes, the mapping of fied values, or values in the data
store to the attributes of a cell render is done by the
\method{addAttribute}{gtkCellLayout} method of the tree view column.


\paragraph{Toggle cell renderers}
Binary data can be represented by a toggle. The
\constructor{gtkCellRendererToggle} will create a check box in the
cell, that  will look checked or not depending on the value of its
\code{active} attribute. If this value is found in a boolean column of
the model, then changes to the model will be reflected in the state of
the GUI. However, the programmer must propogate changes to the GUI (the
view) back to the model. The \signal{toggled} signal is emitted when
the state is changed. The \code{activatable} attribute for the cell
must be \code{TRUE} in order for it to receive user input.

<<cellRendererToggle>>=
cr <- gtkCellRendererToggle()
cr['activatable'] <- TRUE               # cell can be edited
cr['active'] <- TRUE
QT <- gSignalConnect(cr, "toggled", function(w, path) {
  print(as.numeric(path) + 1) ## modify model as needed
})
@ 

%% combo
\paragraph{Combobox cell renderers}
A cell can show a combobox for selection. The
\constructor{gtkCellRendererCombo} produces the object. Its
\code{model} attribute is set to give the values to choose from. The
attribute \code{has-entry} can be set to \code{TRUE} to allow a user
to enter values, if \code{FALSE} they can only select from the
available ones. 

<<>>=
cr <- gtkCellRendererCombo()
store <- rGtkDataFrame(state.name)
cr['model'] <- store
cr['text-column'] <- 0
cr['editable'] <- TRUE                  # needed
@ 

%% progress bars
\paragraph{Progress bar cell renderers}
A progress bar can be used to display the percentage of some task. The
\constructor{gtkCellRendererProgress} function returns the cell
renderer. Its \code{value} attribute takes a value between $0$ and
$100$ indicating the amount finished, with a default value of
$0$. Values out of this range will be signaled by an error message.  The
\code{orientation} property, with values from
\code{GtkProgressBarOrientation}, can adjust the direction that the
bar grows.  For example,

<<comboEditor>>=
cr <- gtkCellRendererProgress()
cr["value"] <- 50                       # fixed 50%
cr['orientation'] <- "right-to-left"
@ 

%% numbers
\paragraph{Cell data functions}
Formatting numbers is a bit trickier, as the cell renderer properties
are oriented around text values. For example, to align floating point
numbers one can do so in the model (e.g., using \function{sprintf} to
format and coerce to character data) and then displaying as
text. However, to do so through the cell rendererer requires one to
get the value from the model and modify it before the cell rendererer
gets it. For this, a cell data function (only with tree
views, not comboboxes). A cell data function passing in arguments for the
 tree view column, the cell renderer, the model, an iterator pointing
to the row in the model and a data argument for user data. The
function is tasked with setting the appropriate attributes of the cell
renderer. For example, this function could be used to format floating
point numbers:
<<>>=
func <- function(viewCol, cellRend, model, iter, data) {
  curVal <- model$GetValue(iter, 0)$value
  fVal <- sprintf("%.3f", curVal)
  cellRend['text'] <- fVal
  cellRend['xalign'] <- 1
}
@ 
One drawback with the use of such function is they are much
slower. However, if you are displaying numeric data with \code{NA}
values, they need to be used to get a sensible display.

%% This function will be set for the tree view column and illustrated in Example~\ref{ex:RGtk2:rGtk2DataFrame}.
%% editable cells 

\paragraph{Editable cells} When the \code{editable} property of a text
cell (or \code{activatable} property of a toggle cell) is set to
\code{TRUE}, then the cell contents can be changed. This allows the
user to make changes to the underlying model through the GUI. Although
the view automatically reflects changes made to the model, the reverse
is not true. A callback must be assigned to the \code{editable}
(\code{toggled}) signal for the cell renderer to implement the
change. The callback for the \qcode{editable} signal has arguments
\code{renderer}, \code{path} for the path of the selected row (as a
string), and \code{new.text} containing the value of the edited text
as a string. The tree view object and which column was edited are not
passed in by default. These can be passed through the user data
arugment, or set as data for the widget if needed within the callback.

For example, here is how one can update an \code{rGtk2DataFrame} model
from within the callback.
<<echo=FALSE>>=
cr <- gtkCellRendererText()
@ 
<<editedSignal>>=
cr['editable'] <- TRUE
ID <- gSignalConnect(cr, "edited", 
                     f=function(cr, path, newtext, user.data) {
                       curRow <- as.numeric(path) + 1
                       curCol <- user.data$column
                       model <- user.data$model
                       model[curRow, curCol] <- newtext
                     }, data=list(model=store, column=1))
@ 

\paragraph{Moving the cursor}
Users may expect that once a cell is edited, the next cell is then set
up to be edited. In order to do this, one must set the cursor to the
appropriate place and set the state to editing. This is done through
the tree view's \method{setCursor}{gtkTreeView} method. The
\code{path} argument takes a tree path instance, the \code{column}
argument is for a tree view column object, and the flag
\code{start.editing} should be set to \code{TRUE} to initiate
editing. The tree view method \method{getColumn}{gtkTreeView} can be
used to get the tree view column by index ($0$-based) and the path
object can be found from a string through \function{gtkTreePathNewFromString}.


% \begin{example}{A basic usage of displaying a data frame using a tree view}{ex:RGtk2-minimal-rGtkDataFrame}
%   \SweaveInput{ex-RGtk2-minimal-rGtkDataFrame}
% \end{example}

\begin{example}{Displaying text columns in a tree view}{ex:RGtk2-add-toggle-to-df}
  \SweaveInput{ex-RGtk2-add-toggle-to-df}
\end{example}

%% filtering
\paragraph{Using filtered models to restrict the displayed rows}
\GTK\/ provides a means to show a filtered selection of rows. The
basic idea is that an extra column in the store stores logical values
to indicate if a row should be visible. To implement this, a filtered
store must be made from the original store. The
\method{filterNew}{gtkTreeModel} method of a data store returns a
filtered data store. The original model is found from the filtered one
through its \code{getModel} method. The method
\method{setVisibleColumn}{gtkTreeModelFilter} specifies which column
in the model holds the logical values.  Finally, to use the filtered store, it is simply set as
the model for a tree view.

<<>>=
df <- data.frame(col=letters[1:3], vis=c(TRUE, TRUE, FALSE))
store <- rGtkDataFrame(df)
filtered <- store$filterNew()
filtered$setVisibleColumn(1)            # 0-based
view <- gtkTreeView(filtered)
@ 

<<notShown, echo=FALSE>>=
vc <- gtkTreeViewColumn()
QT <- view$insertColumn(vc, 0)
cr <- gtkCellRendererText()
vc$packStart(cr)
vc$addAttribute(cr, "text", 0)      

sw <- gtkScrolledWindow()
sw$add(view)
w <- gtkWindow(show=FALSE)
w$add(sw)
w$show()
@ 

%% searching
\paragraph{Sorting the display}
One can implement sorting of the display by clicking on the column
headers. This is done by creating a model that can be sorted from the
original store. The function \function{gtkTreeModelSortNewWithModel}
will produce a new store that is assigned as the model for the tree
view. Then to allow a column to be sorted, one specifies first the
\code{clickable} property of the view column, and then specifies a
column to sort by when the column header is clicked (it can be
different if desired). The following shows the basic steps:

<<basicSort>>=
store <- rGtkDataFrame(mtcars)
sorted <- gtkTreeModelSortNewWithModel(store)
#
view <- gtkTreeView(sorted)
vc <- gtkTreeViewColumn()
QT <- view$insertColumn(vc, 0)                  # first column
vc$setTitle("Click to sort")
vc$setClickable(TRUE)
vc$setSortColumnId(0)                   
#
cr <- gtkCellRendererText()
vc$packStart(cr)
vc$addAttribute(cr, "text", 0)
@ 
The default sorting function can be changed. The sortable store's
method \method{setSortFunc}{gtkTreeSortable} is used for this.
The following function -- which can easily be modified to taste -- shows
how the default sorting might be implemented.
<<sort-example>>=
f <- function(model, iter1, iter2, user.data) {
  column <- user.data
  val1 <- model$GetValue(iter1, column)$value
  val2 <- model$GetValue(iter2, column)$value
  val1 > val2
}
QT <- sorted$setSortFunc(sort.column.id=0, sort.func=f, 
                         user.data=0)   # column
@ 

<<notShown, echo=FALSE>>=
## basic GUI
sw <- gtkScrolledWindow()
sw$add(view)
w <- gtkWindow(show=FALSE)
w['title'] <- "Example of sortable tree view"
w$add(sw)
w$show()
@ 

\paragraph{Selection}
%% selection: none, single browse multiple, getSelected

\GTK\/ provides a class to handle the selection of rows that the user
makes. The selection object is returned from the tree view, through
its \method{getSelection}{gtkTreeView} method. 
To modify the selection possibilities, the selection object's method
\method{setMode}{gtkTreeSelection} method is used, with values from
\code{GtkSelectionMode}, including \qcode{multiple} for allowing more
than one row to be selected and \qcode{single} for no more than one row.
Additionally, the selection object has various
methods to interact with the selection.  

When only a single selection is possible, the method
\method{getSelected}{gtkTreeSelection} returns a list with components
\code{retval} to indicate success, \code{model} containing the model
and \code{iter} containing an iterator to the selected row in the
model.

<<>>=
store <- rGtkDataFrame(mtcars)
view <- gtkTreeView(store)
selection <- view$getSelection()
QT <- selection$setMode("single")
@ 

<<echo=FALSE>>=
## create some tree view columns and cell renderers
vc <- gtkTreeViewColumn()
QT <- view$insertColumn(vc, 0)
cr <- gtkCellRendererText()
vc$PackStart(cr)
vc$addAttribute(cr, "text", 0)
## pack in GUI
sw <- gtkScrolledWindow()
sw$add(view)
##
w <- gtkWindow(show=FALSE)
w['title'] <- "Multiple selection example"
w$Add(sw)
w$show()
@ 
If this tree view is shown and a selection made, this code will return the value in the first column:
<<>>=
selection$selectPath(gtkTreePathNewFromString("3")) # set 
# 
curSel <- selection$getSelected()       # retrieve selection
with(curSel, model$getValue(iter, 0)$value) # model, iter
@ 


When multiple selection is permitted, then the method
\method{getSelectedRows}{gtkTreeSelection} returns a list with
componets \code{model} pointing to the model, and \code{retval} a list
of tree paths. No column information is passed back by this method.

For example, we can change the selection mode as follows.
<<>>=
selection$setMode("multiple")
@ 

<<notShown, echo=FALSE>>=
selection$selectPath(gtkTreePathNewFromString("1")) # set for example
selection$selectPath(gtkTreePathNewFromString("2")) # set for example
selection$selectPath(gtkTreePathNewFromString("3")) # set for example
@ 
This code will print the selected values in the first column (we have
selected the first three rows):
<<>>=
curSel <- selection$getSelectedRows()
if(length(curSel$retval)) {
  rows <- sapply(curSel$retval, function(path) {
    as.numeric(path$toString()) + 1
  })
  curSel$model[rows, 1]
}
@ 
                 

%% signals, callback
%% row-activated -- double click
\paragraph{Signals}
Tree views can be used different ways: if the cells are not editable,
then they are basically list boxes which allow the user to select one of
several rows. A single click selects the value, and a double click is
often used to initiate an action. If the cells are editable, then this
action is to edit the content.

%% double click
When a row is not editable, then the double-click event or a keyboard
command triggers the \signal{row-activated} signal for the tree
view. The callback has arguments \code{tree.view} pointing to the
widget that emits the signal, \code{path} storing a tree path of the
selected row, and \code{column} containing the tree view column. The
column number is not returned. If that is of interest, it can be
passed in via the user data argument, or matched against the children
of the tree view through a command like

<<eval=FALSE>>=
sapply(tree.view$getColumns(), function(i) i == column)
@ 

%% selection
The selection object emits signals for various events, in particular, when a
selection is made or changed, the \signal{changed} signal is emitted.


%% tree stores
For tree stores, the user can click to expand or collapse a part of
the tree. The signals \code{row-expanded} and \code{row-collapsed} are
emitted respectively by the tree view. The signature of the callback is similar to
above with the view, a tree path and a view column.



%% filter
\begin{example}{Using filtering}{ex:RGtk2-filtered}
  \SweaveInput{ex-RGtk2-filtered}
\end{example}


%% ping pong
\begin{example}{A widget for variable selection}{ex:RGtk2-pingpong}
   \SweaveInput{ex-RGtk2-pingpong}
 \end{example}

%% editable
% \begin{example}{An editable data frame}{ex:RGtk2-editable-dataframe}
%   \SweaveInput{ex-RGtk2-editable-dataframe}
% \end{example}


%% Tree stores
The \constructor{gtkTreeView} widget displays either list stores or
tree  stores. The difference for the programmer is in the creation of
the data store, not the tree view.

\begin{example}{A simple tree display}{eg:RGtk2-simple-tree}
  \SweaveInput{ex-RGtk2-simple-tree}
\end{example}

%% ## dynagmic
\begin{example}{Dynamically growing a tree}{eg:RGtk2:tree-dynamic}
\SweaveInput{ex-RGtk2-tree}
\end{example}
%% % ## mapes a list, shows how to update text view
% \SweaveInput{ex-RGtk2-tree-show}




