<<echo=FALSE>>=
## a combobox that learns as you go.
## no tooltip per item, but here we add as detail
library(RGtk2)
@ 

This example uses an editable combobox as an simple interface to \R's
help system. We record the number of times a page is searched for. 

Our model fo the combobox will be a \class{rGtkDataFrame} instance
where 3 variables are kept a function name, a string describing the
number of visits and an integer to record the number of visits. We
create the combobox with this model using the first column for the text.
<<>>=
m <- rGtkDataFrame(data.frame(fname="", visits="", novisits=0,
                              stringsAsFactors=FALSE))
cb <- gtkComboBoxEntryNewWithModel(m, text.column=0)
@ 

It isn't possible to put tooltip information on the dropdown elements
of a combobox, rather here we borrow from popular web browser
interfaces and add to the standard appearance of the drop down
elements by adding in textual information about the number of
visits. To do so we pack in a new cell renderer to accompany that
provided by the \code{gtkComboBoxEntry} widget.
<<ConfigureCellRenderers>>=
cr <- gtkCellRendererText()
cb$packStart(cr)
cb$addAttribute(cr, "text", 1)
cr['foreground'] <- "gray50"
cr['ellipsize'] <- "end"
cr['style'] <- "italic"
cr['alignment'] <- "right"
@ 

We place this in a minimal GUI with just a label to inicate what is to
be done.
<<Layout>>=
w <- gtkWindow(show=FALSE)
w['border-width'] <- 15
g <- gtkHBox(); w$add(g)
g$packStart(gtkLabel("Help on:"))
g$packStart(cb, expand=TRUE, fill=TRUE)
#
w$show()
@ 

%% JV: This first point seems like a misunderstanding on my part, but
%% I tried:
%% > m =rGtkDataFrame(data.frame(a=character(0), b=character(0), stringsAsFactors=FALSE))
%% > sapply(m[,], class)          a           b 
%% "character" "character" 
%% > m$appendRows(list(a="a", b="b"))
%% <pointer: 0x11eda4e30>
%% attr(,"interfaces")
%% [1] "GtkTreeModel"    "GtkTreeSortable"
%% attr(,"class")
%% [1] "RGtkDataFrame" "GObject"       "RGtkObject"   
%% > sapply(m[,], class)
%%        a        b 
%% "factor" "factor" 


Now we configure the combobox. When a new value is typed in we need to
add it to the model. There are a few things to watch out for
here. First, if we define the model to have $0$ rows, then the
\code{appendRows} call will coerce the characters to factors. To avoid
that, we check to see if we are in the initial state in which case we
replace the first row. If not, then we update the model. In \GTK\/
there is no means to notify the views of a model of a change of
dimension, and in this case appending rows will cause the combobox to
complain. Here we disconnect the model, update it, then reconnect it
to the view.
<<helperFunctions>>=
addValue <- function(cb, value) {
  model <- cb$getModel()
  if(nrow(m) == 1 && m[1,1] == "") {
    m[1,1] <- value; m[1,2] <- ""; m[1,3] <- 0
  } else {                              # not first time
    cb$setModel(NULL)
    model$AppendRows(list(fname=value, visits="", novisits=0))
    cb$setModel(model)
  }
}
@ 

This helper function will be called each time a help page is
requested. It first updates the visit information, selects the
text for easier editing the next time round, then calls  \function{help}.
<<helperFunction2>>=
callHelpFunction <- function(cb, value) {
  model <- cb$getModel()
  ind <- match(value,model[,1, drop=TRUE])
  n <- model[ind, "novisits"] <- model[ind, "novisits"] + 1
  model[ind, "visits"] <- sprintf(ngettext(n, "%s visit", "%s visits"), n)
  ## select for easier editing
  cb$getChild()$selectRegion(start=0,end=-1)
  help(value)
}
@ 

We connect to two signals emitted by the combobox. First when a
selection is made (and  \method{getActive}{gtkComboBox} returns a
non-negative value) we call the help function.
gSignalConnect(cb, "changed", f=function(w, ...) {
  if(cb$getActive() >= 0) {
    val <- w$getActiveText()
    callHelpFunction(w, val)
  }
})
@ 

The \code{activate} callback checks to see if the requested value has
not been visited previosly. If not, this calls our \function[addValue}
function before calling the help function.
<<results=hide>>=
gSignalConnect(cb$getChild(), "activate", f = function(cb, entry, ...) {
  val <- entry$getText()
  if(!any(val == cb$getModel()[,1, drop=TRUE])) {
    addValue(cb, val)                   # a new one
  }
  callHelpFunction(cb, val)
}, data=cb, user.data.first=TRUE)
@ 


