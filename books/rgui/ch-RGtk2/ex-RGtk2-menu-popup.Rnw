To illustrate popup menus, we show how construct one and display it in
response to a mouse click. We start with a \code{gtkMenu} instance, to
which we add some items.
<<"menubar-ex">>=
popup <- gtkMenu()                       # top level
popup$append(gtkMenuItem("cut"))
popup$append(gtkMenuItem("copy"))
popup$append(gtkSeparatorMenuItem())
popup$append(gtkMenuItem("paste"))
@ 

Let us assume that we have a button that will popup a menu when
clicked with the third (right) mouse button:
<<rgtk2-menus-popup-button>>=
b <- gtkButton("Click me with right mouse button")
w <- gtkWindow(); w$setTitle("Popup menu example")
w$add(b)
@

This menu will be shown by calling \code{gtkMenuPopup} in response to
the \code{button-press-event} signal on the button. The
\function{gtkMenuPopup} function is called with the menu, some
optional arguments for placement, and some values describing the
event: the mouse button and time. The event values can be retrieved from
the second argument of the callback (a \code{GdkEvent}).
<<>>=
gSignalConnect(b,"button-press-event",
       f = function(w, e, menu) {
         if(e$getButton() == 3 ||
            (e$getButton() == 1 && # a mac
             e$getState() == GdkModifierType['control-mask'])) 
           gtkMenuPopup(menu, 
                        button = e$getButton(),
                        activate.time = e$getTime())
         return(FALSE)
       }, data=popup)
@ 

The above will popup a menu, but until we bind a callback to the \code{activate}
signal, nothing will happen when a menu item is selected. Below we
supply a stub for sake of illustration. The children of a popup menu
are the menu items, including the separator which we avoid.
<<>>=
IDs <- sapply(popup$getChildren(), function(i) {
  if(!inherits(i, "GtkSeparatorMenuItem")) # skip these
    gSignalConnect(i, "activate",
                   f = function(w, data) print("replace me"))
})
@ 
