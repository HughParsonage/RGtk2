%% intorduction
<<echo=FALSE>>=
require(RGtk2)
@ 

%% Technical, but short beginning

As the name implies, the \pkg{RGtk2} package is an interface, or
binding, between \R\/ and \GTK, a mature, cross-platform GUI
toolkit. The letters \emph{GTK} stand for the \emph{GIMP ToolKit},
with the word \emph{GIMP} recording the origin of the library as part
of the GNU Image Manipulation Program. \pkg{GTK+} provides the same
widgets on every platform, though it can be customized to emulate
platform-specific look and feel. The library is written in
\proglang{C}, which facilitates access from languages like
\proglang{R} that are also implemented in \proglang{C}. \pkg{GTK+} is
licensed under the \textit{Lesser GNU Public License} (LGPL), while
\pkg{RGtk2} is under the \textit{GNU Public License} (GPL).
The package is available from the Comprehensive \proglang{R} Archive
Network (CRAN) at \url{http://CRAN.R-project.org/package=RGtk2}.

The name \pkg{RGtk2} also implies that there exists a package named
\pkg{RGtk}, which is indeed the case. The original \pkg{RGtk} is bound
to the previous generation of \pkg{GTK+}, version 1.2. \pkg{RGtk2} is
based on \pkg{GTK+ 2.0}, the current generation. This book covers
\pkg{RGtk2} specifically, although many of the fundamental features of
\pkg{RGtk2} are inherited from \pkg{RGtk}. 

\pkg{RGtk2} provides virtually all of the functionality in \GTK\/ to
the \R\/ programmer. In addition, \pkg{RGtk2} interfaces with several
other libraries in the \GTK\/ stack: Pango for font rendering; Cairo
for vector graphics; GdkPixbuf for image manipulation; GIO for
synchronous and asynchronous input/output for files and network
resources; ATK for accessible interfaces; and GDK, an abstraction over
the native windowing system, supporting either X11 or Windows. These
libraries are multi-platform and extensive and have been used for many
major projects, such as the Linux versions of Firefox and Open Office.

The API of each of these libraries is mapped to \R\/ in a way that is
consistent with \R\/ conventions and familiar to the \R\/
user. Much of the \pkg{RGtk2} API consists of autogenerated \R\/
functions that call into one of the underlying libraries. For
example, the \R\/ function \function{gtkContainerAdd} eventually calls
the C function \code{gtk\_container\_add}. The naming convention is
that the C name has its underscores removed and each following letter
capitalized (camelback style).

The full API for \GTK\/ is quite large, and complete documentation of
it is beyond our scope. However, the \GTK\/ documentation is
algorithmically converted into the \R\/ help format during the
generation of \pkg{RGtk2}. This conveniently allows the programmer to
refer to the appropriate documentation within an \R\/ session, without
having to consult a web page, such as
\url{http://library.gnome.org/devel/gtk/stable/}, which lists the
\proglang{C} API of the stable version of \GTK.

In this chapter, we give an overview of how \pkg{RGtk2} maps the
\GTK\/ API, including its classes, constructors, methods, properties,
signals and enumerations, to an \R-level API that is relatively
familiar to, and convenient for, an \R\/ user. A simple GUI will be
gradually constructed to demonstrate the API.

%%% ------- OOP --------------

\section{Synopsis of the \pkg{RGtk2} API}

Constructing a GUI with \pkg{RGtk2} generally proceeds by constructing
a widget and then configuring it by calling methods and setting
properties. Signal handlers are connected to respond to user input and
the widget is combined with other widgets to form the GUI. For
example:
<<gtk-overview-initial-example>>=
button <- gtkButton("Click Me")
button['image'] <- gtkImage(stock = "gtk-apply", size = "button")
gSignalConnect(button, "clicked", function(x) message("Hello World!"))
window <- gtkWindow(show = FALSE)
window$add(button)
window$showAll()
@ 
% 
Once one understands the syntax and themes of the above example, it is
only a matter of reading through the documentation to discover all of
the widgets and their features. The rest of this chapter will explain
these basic components of the API.

\section{Objects and Classes}

In any toolkit, all widget types have functionality in common. For
example, they are all drawn on the screen in a consistent style. They
can be hidden and shown again. To formalize this relationship and to
simplify implementation by sharing code between widgets, \pkg{GTK+},
like many other toolkits, defines an inheritance hierarchy for its
widget types. In the parlance of object-oriented programming, each
type is represented by a \textit{class}.

For specifying the hierarchy, \pkg{GTK+} relies on \pkg{GObject}, a
\proglang{C} library that implements a class-based, single-inheritance
object-oriented system. A \pkg{GObject} class encapsulates behaviors
that all instances of the class share. Every class has at most one
parent from which it inherits the behaviors of its ancestors. A
subclass can override some specific inherited behaviors. The interface
defined by a class consists of constructors, methods, properties,
and signals. 
% TODO: example of gTypeGetAncestors

Single inheritance can be restrictive when a class performs multiple
roles in a program. To circumvent this, \pkg{GTK+} adopts the popular
concept of the \textit{interface}, which is essentially a contract
that specifies which methods, properties and signals a class must
implement. As with languages like Java and \proglang{C\#}, a class can
\textit{implement} multiple interfaces, and an interface can be
composed of other interfaces. An interface allows the programmer to
treat all instances of implementing classes in a similar way. However,
unlike class inheritance, the implementation of the methods,
properties and signals is not shared.
% TODO: example of gTypeGetInterfaces

We explain the constructors, methods, properties and signals of
classes and interfaces in the following sections and demonstrate them
in the construction of a simple ``Hello World'' GUI, shown in
Figure~\ref{fig:hello-world}. A more detailed and technical
explanation of \pkg{GObject} is available in
Section~\ref{sec:gobject-primer}.

\begin{figure}[h!tbp]
  \begin{center}
    \includegraphics[width=2in]{hello-world.png}
    \caption{\label{fig:hello-world}``Hello World'' in GTK+. 
      A window containing a single button displaying a label with the text
      \code{Hello World}.}
  \end{center}
\end{figure}

\section{Constructors}

The first step in our example is to create a top-level window to
contain our GUI.  Creating an instance of a GTK\/ widget requires
calling a single \R\/ function, known as a constructor. Following \R\/
conventions, the constructor for a class has the same name as the
class, except the first character is lowercase. The following
statement constructs an instance of the \code{GtkWindow} class:
<<intro-constructor-gtkWindow>>=
window <- gtkWindow("toplevel", show = FALSE)
@
%
The first argument to the constructor for \code{GtkWindow} instructs
the window manager to treat the window as top-level.  The \code{show}
argument is the last argument for every widget constructor. It
indicates whether the widget should be made visible immediately after
construction.  The default value of \code{show} is \code{TRUE}. In
this case we want to defer showing the window until after we finish
constructing our simple GUI.

At the \GTK\/ level, a class usually has multiple constructors, each
implemented as a separate C function. In \pkg{RGtk2}, the names of
these functions all end with \code{New}. The ``meta'' constructor
\function{gtkWindow}, called above, automatically delegates to one of
the low-level constructors, based on the provided arguments.

We prefer these shorter, more flexible constructors, such as
\function{gtkWindow} or \function{gtkButton}, but note their
documentation is provided by the \R\/ package author and is in
addition to the formal API. These constructors can take many
arguments, and only some subsets of the arguments may be specified at
once. For example, this call
<<gtk-overview-construct-image, results=hide>>=
gtkImage(stock = "gtk-apply", size = "button")
@ 
% 
uses only two arguments, \argument{stock}{gtkImage} and
\argument{size}{gtkImage}, which always must be specified
together. The entire signature is more complex:
<<gtk-overview-construct-image-args>>=
args(gtkImage)
@ 

A \GTK\/ object created by the \R\/ user has an \R-level object as its
proxy. Thus, \code{window} is a reference to a \class{GtkWindow}
instance. A reference object will not be copied before
modification. This is different from the behavior of most \R\/
objects. For example, calling \function{abs} on a numeric vector does
not change the value assigned to the original symbol:
<<gtk-overview-objects-value>>=
a <- -1
abs(a)
a
@ 
% 
Setting the text label on our button, however, will change the
original value:
<<gtk-overview-objects-ref>>=
gtkButtonSetLabel(button, "New text")
gtkButtonGetLabel(button)
@ 
% 
If this widget were displayed on the screen, the label would also be
updated.

The class hierarchy of an object is represented by the
\code{class} attribute. One interprets the attribute according to S3
conventions, so that the class names are in order from most to least
derived:
<<intro-constructor-classes>>=
class(window)
@
%
We find that the \class{GtkWindow} class inherits methods,
properties, and signals from the \class{GtkBin}, \class{GtkContainer},
\class{GtkWidget}, \class{GtkObject}, \class{GInitiallyUnowned}, and
\class{GObject} classes. Every type of \pkg{GTK+} widget inherits from
the base \code{GtkWidget} class, which implements the general
characteristics shared by all widget classes, e.g., properties storing
the location and background color; methods for hiding, showing and
painting the widget. We can also query \code{window} for the
interfaces it implements:
<<intro-constructor-interfaces>>=
interface(window)
@ % In the next version of RGtk2, this will become just 'interface'

When the underlying \GTK\/ object is destroyed, i.e., deleted
from memory, the class of the proxy object is set to \class{<invalid>},
indicating that it can no longer be manipulated.

\section{Methods}

The next steps in our example are to create a ``Hello World'' button
and to place the button in the window that we have already
created. This depends on an understanding of how of one
programmatically manipulates widgets by invoking methods.  Methods are
functions that take an instance of their class as the first argument
and instruct the widget to perform an action.

Although class information is stored in the style of S3, \pkg{RGtk2}
introduces its own mechanism for method dispatch.  The call
\code{obj\$method(...)}  resolves to a function call
\code{f(obj,...)}. The function is found by looking for any function
that matches the pattern \emph{classNameMethodName}, the concatenation
of one of the names from \code{class(obj)} or \code{interface(obj)}
with the method name. The search begins with the interfaces and
proceeds through each character vector in order.

For instance, if \code{win} is a \function{gtkWindow} instance, then
to resolve the call \code{win\$add(widget)} \pkg{RGtk2} considers
\function{gtkBuildableAdd}, \function{atkImplementorIfaceAdd},
\function{gtkWindowAdd}, \function{gtkBinAdd} and finally finds
\function{gtkContainerAdd}, which is called as
\code{gtkContainerAdd(win, widget)}. The \method{\$}{GObject} method
for \pkg{RGtk2} objects does the work.

We take advantage of this convenience when we add the ``Hello World''
button to our window and set its size:
<<intro-methods-button>>=
button <- gtkButton("Hello World")
window$add(button)
window$setDefaultSize(200, 200)
@ 
%
The above code calls the \function{gtkContainerAdd} and
\function{gtkWindowSetDefaultSize} functions with less typing and less
demands on the memory of the user.

Understanding this mechanism allows us to add to the \pkg{RGtk2}
API. For instance, we can add to the button API with
<<gtkButtonAddApi>>=
gtkButtonSayHello <- function(obj, target) 
  obj$setLabel(paste("Hello", target))
button$sayHello("World")
button$getLabel()
@ 

%% common methods
Some common methods are inherited by most widgets, as they are defined
in the base \class{gtkWidget} class. These include the methods 
\method{show}{gtkWidget} to specify that the widget should be drawn;
\method{hide}{gtkWidget} to hide the widget until specified;
\method{destroy}{gtkWidget} to destroy a widget and clear up any
references to it; \method{getParent}{gtkWidget} to find the parent
container of the widget; \method{modifyBg}{gtkWidget} to modify the
background color of a widget; and \method{modifyFg}{gtkWidget} to
modify the foreground color.


\section{Properties}


%% --------- Properties ------------
The \GTK\/ API uses properties to store object state. Properties are
similar to \R\/ attributes and even more so to S4 slots. They are
inherited, typed, self-describing and encapsulated, so that an object
can intercept access to the underlying data. A list of properties that
a widget has is returned by its \method{getPropInfo}{GObject}
method. \pkg{RGtk2} uses the \R\/ generic \method{names}{GObject}
as a familiar alternative for this method. Auto-completion of property
names is gained as a side effect.  For the button just defined, we can
see the first eight properties listed with:
<<showProperties>>=
head(names(button), n=8)                 # or b$getPropInfo()
@ 

Some common properties are: \code{parent}, to store the parent widget
(if any); \code{user-data}, which allows one to store arbitrary data
with the widget; and \code{sensitive}, to control whether a widget can
receive user events. 

There are a few different ways to access these properties. \GTK\/
provides the functions \function{gObjectGet} and \function{gObjectSet}
to get and set properties of a widget. The set funtion treats the
arguments names as the property names, and setting multiple properties
at once is supported. Here we add an icon to the top-left corner of
our window and set the title:
<<intro-props-get-set>>=
image <- gdkPixbuf(filename = imagefile("rgtk-logo.gif"))[[1]]
window$set(icon = image, title = "Hello World 1.0")
@ 

Additionally, most user-accessible properties have specific \code{get} and
\code{set} methods defined for them. For example, to set the title of
the window, we could have used the \method{setTitle}{GtkWindow} method
and verified the change with \method{getTitle}{GtkWindow}.
<<>>=
window$setTitle("Hello World 1.0")
window$getTitle()
@ 

\pkg{RGtk2} provides the convenient and familiar \code{[} and
\code{[$<$-} methods to get and access the properties. In our example,
we might check the window to ensure that it is not yet visible:
<<intro-props-visible>>=
window["visible"]
@
Finally, we can make our window visible by setting the ``visible'' property,
although calling \function{gtkWidgetShow} is more conventional:
<<intro-props-show>>=
window["visible"] <- TRUE 
window$show() # same effect
@ 

For ease of referencing the appropriate help pages, we tend to use the
full method name in the examples, although at times the move \R-like
vector notation will be used for commonly accessed properties.

%%% ------ Signals ----------

\section{Events and signals}

In \pkg{RGtk2}, a user action, such as a mouse click, key press, or
drag and drop motion, triggers the widget to emit a corresponding
signal.  A GUI can be made interactive by specifying a callback
function to be invoked upon the emission of a particular signal.

The signals provided by a class or interface are returned by the
function \function{gTypeGetSignals}. For example
<<>>=
names(gTypeGetSignals("GtkButton"))
@ 
shows the ``clicked'' signal in addition to others. Note that this
only lists the signals provided directly by the \class{GtkButton}. To
list all inherited signals, we need to loop over the hierarchy, but it
is not common to do this in practice, as the documentation includes
information on the signals.

The \function{gSignalConnect} (or \function{gSignalConnect}) function is used
to add a callback to a widget's signal. Its signature is
%% XXX tighten up output
\begin{Soutput}
function (obj, signal, f, data = NULL, after = FALSE, 
          user.data.first = FALSE)
\end{Soutput}
<<echo=FALSE, eval=FALSE>>=
args(gSignalConnect)
@
%
The basic usage is to call \function{gSignalConnect} to connect a
callback function \argument{f}{gSignalConnect} to the signal named
\argument{signal}{gSignalConnect} belonging to the object
\argument{obj}{gSignalConnect}. The function returns an identifier for
managing the connection. This is not usually necessary but will be
discussed later.

We demonstrate this usage by adding a callback to our ``Hello World''
example, so that ``Hello World'' is printed to the console when the
button is clicked:
<<intro-signals-hello-world>>=
gSignalConnect(button, "clicked", 
               function(widget) print("Hello world!"))
@ 
%

The \argument{data}{gSignalConnect} argument allows arbitrary data to
be passed to the callback.  The
\argument{user.data.first}{gSignalConnect} argument specifies if this
\argument{data}{gSignalConnect} argument should be the first argument
to the callback or (the default) the last.

The \argument{after}{gSignalConnect} argument is a logical indicating
if the callback should be called after the default handlers (see
\command{?gSignalConnect}).

%% the callback
The signature for the callback varies for each signal. Unless
\code{user.data.first} is \code{TRUE}, the first argument is the
widget. Other arguments are possible depending on the signal type. For
window events, the second argument is a \class{GdkEvent} type, which
can carry with it extra information about the event that occurred. The
\GTK\/ API lists the signature of each signal.

Is important to note that the widget, and possibly other arguments,
are references, so their manipulation has side effects outside of the
callback. This is obviously a critical feature, but it is one that
may be surprising to the \R\/ user.

<<>>=
w <- gtkWindow(); w['title'] <- "test signals"
x <- 1; 
b <- gtkButton("click me"); w$add(b)
ID <- gSignalConnect(b, signal = "clicked", 
                     f = function(widget) {
                       widget$setData("x", 2)
                       x <- 2
                       return(TRUE)
                     })
@ 
Then after clicking, we would have
<<echo=FALSE>>=
b$setData("x", 2)                        # fix non-interactivity
@ 

<<>>=
cat(x, b$getData("x"), "\n") # 1 and 2
@ 

Callbacks for signals emitted by window manager events are expected to
return a logical value. Failure to do so can cause errors to be
raised. A return value of \code{TRUE} indicates that no further
callbacks should be called, whereas \code{FALSE} indicates that the
next callback should be called. In other words, the return value
indicates whether the handler has consumed the event. In the following
example, only the first two callbacks are executed when the user
clicks the button:
<<>>=
b <- gtkButton("click")
w <- gtkWindow()
w$add(b)
id1 <- gSignalConnect(b, "button-press-event", 
function(b, event, data) {
  print("hi"); return(FALSE)
})
id2 <- gSignalConnect(b, "button-press-event", 
function(b, event, data) {
  print("and"); return(TRUE)
})
id3 <- gSignalConnect(b, "button-press-event", 
function(b, event, data) {
  print("bye"); return(TRUE)
})
@ 

%% multiple callbacks; remove; block
Multiple callbacks can be assigned to each signal. They will be
processed in the order they were bound to the signal.  The
\function{gSignalConnect} function returns an ID that can be used to
disconnect a handler, if desired, using
\function{gSignalHandlerDisconnect}. To temporarily block a handler,
call \function{gSignalHandlerBlock} and then
\function{gSignalHandlerUnblock} to unblock. The man page for
\function{gSignalConnect} gives the details on this.

%%% ------ constants --------

\section{Enumerated types and flags}

At the beginning of our example, we constructed the window thusly: 
<<intro-enum-window, eval=FALSE>>=
window <- gtkWindow("toplevel", show = FALSE)
@
%
The first parameter indicates the window type. The set of possible
window types is specified by what in \proglang{C} is known as an
\emph{enumeration}. A value from an enumeration can be thought of as a
length one factor in \R. The possible values defined by the
enumeration are analogous to the factor levels.  Since enumerations
are foreign to \proglang{R}, \pkg{RGtk2} accepts string
representations of enumeration values, like \code{"toplevel"}. 

For every \pkg{GTK+} enumeration, \pkg{RGtk2} provides an \proglang{R}
vector that maps the nicknames to the underlying numeric values.  In
the above case, the vector is named \code{GtkWindowType}.
<<intro-enum-GtkWindowType>>=
GtkWindowType
@ 
%
The names of the vector indicate the allowed nickname for each value
of the enumeration. It is rarely necessary to explicitly use the
enumeration vectors; specifying the nickname will work in most cases,
including all method invocations, and is preferable as it is easier
for human readers to comprehend.

Flags are an extension of enumerations, where the value of each member
is a unique power of two, so that the values can be combined
unambiguously. An example of a flag enumeration is
\class{GtkWidgetFlags}.
<<intro-enum-GtkWidgetFlags>>=
GtkWidgetFlags
@ 
%
\class{GtkWidgetFlags} represents the possible flags that can be set
on a widget. We can retrieve the flags currently set on our window:



<<intro-enum-gtkWidgetFlags, results=hide>>=
window$flags()
@ % output will be much prettier with next version of RGtk2
\begin{Soutput}
GtkWidgetFlags: toplevel, realized, mapped, visible, 
         sensitive, parent-sensitive, double-buffered
\end{Soutput}
%
Flag values can be combined using 
%% JV: \function{\\|}, 
\verb+|+
the bitwise
\textit{OR}. The \function{\&} function, the bitwise \textit{AND},
allows one to check whether a value belongs to a combination. For
example, we could check whether our window is top-level:
<<intro-enum-toplevel>>=
(window$flags() & GtkWidgetFlags["toplevel"]) > 0
@ 

%% --------- Event Loop

\section{The event loop}

\pkg{RGtk2} integrates the \GTK\/ and \R\/ event loops by treating the
\R\/ loop as the master and iterating the \GTK\/ event loop whenever R
is idle.  During a long calculation, the GUI can seem unresponsive. To
avoid this, the following construct should be inserted into the long
running algorithm in order to ensure that \GTK\/ events are
periodically processed:
<<>>=
while(gtkEventsPending()) 
  gtkMainIteration()
@ 
This is often useful, for example, to update a progress bar.

If one runs an \pkg{RGtk2} script non-interactively, such as by
assigning an icon to launch a GUI under Windows, R will exit after
the script is finished and the GUI will disappear just after it
appears. To work around this, call the function \function{gtkMain} to
run the main loop until the function \function{gtkMainQuit} is
called. Since there is no interactive session, \function{gtkMainQuit}
should be called through some event handler.

\SweaveInput{Glade}

%% MOVEME: seems like integration between gWidgets and native toolkits
%% belongs in the gWidgets chapters. Otherwise, each toolkit chapter
%% needs to say the same thing. Better to have it in one place.

% \section{RGtk2 and gWidgetsRGtk2}
% \label{sec:RGtk2:gWidgetsRGtk2}


% The widgets described above, are also available through
% \pkg{gWidgetsRGtk2}. The two packages can be used together, for the
% most part. The \code{add} method of \pkg{gWidgetsRGtk2} can be used to
% add an \pkg{RGtk2} widget to a \code{gWidgetsRGtk2}
% container. Whereas, the \code{getToolkitWidget} method will (usually)
% return the \pkg{RGtk2} component to use within \pkg{RGtk2}.

%% Views example in next chapter?
