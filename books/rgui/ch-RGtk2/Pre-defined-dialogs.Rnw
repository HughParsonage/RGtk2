%% FIXME: the examples in this section are pretty lame

\section{Dialogs}
\label{sec:dialogs}

\GTK\/ provides general infrastructure for constructing custom dialogs
and also implements several commonplace special purpose dialogs. 

\subsection{Message dialogs}

A dialog is a window that generally consists of an icon, a content
area, and an action area with a row of buttons representing the
possible user responses.  \class{GtkDialog} represents a generic
dialog and serves as the base class for all special purpose dialogs in
\GTK.

Communicating textual messages to the user
is perhaps the most common application of a dialog. A message dialog
has a primary and secondary message.  We construct one presently:
<<eval=FALSE>>=
w <- gtkWindow()
w['title'] <- "Parent window"
dlg <- gtkMessageDialog(parent=w, flags="destroy-with-parent",
                        type="question", buttons="ok",
                        "My message")
dlg['secondary-text'] <- "A secondary message"
@ 
%
The \argument{flags}{gtkMessageDialog} argument allows one to specify
a combination of values from \code{GtkDialogFlags}. These include 
\code{destroy-with-parent} and \code{modal}. Here, the dialog will be
destroyed upon destruction of the parent window. The
\argument{type}{gtkMessageDialog} argument specifies the message type,
using a value in \code{GtkMessageType}. This determines the icon that
is placed adjacent to the message text. The
\argument{buttons}{gtkMessageDialog} argument indicates the set of
response buttons with a value from \code{GtkButtonsType}. The
remaining arguments are pasted together into the primary message.  The
dialog has a \code{secondary-text} property that can be set to give a
secondary message.

Dialogs are optionally modal. Below, we enable modality by calling the
\method{run}{gtkDialog} method, which will additionally block the \R\/
session:
<<>>=
response <- dlg$run()
if(response == GtkResponseType["cancel"] || # for other buttons
   response == GtkResponseType["close"] ||
   response == GtkResponseType["delete-event"]) {
  ## pass
} else if(response == GtkResponseType["ok"]) {
  print("Ok")
}
dlg$Destroy()
@ 
%
The return value can then be inspected for the action, such as what
button was pressed. \class{GtkMessageDialog} will return response
codes from the \code{GtkResponseType} enumeration. We will see an
example of asynchronous response handling in the next section.

\subsection{Custom dialogs}
\label{sec:custom-dialogs}

The \constructor{gtkDialog} constructor returns a generic dialog
object which can be customized, in terms of its content and response
buttons.  Usually, a \class{GtkDialog} is constructed with
\constructor{gtkDialogNewWithButtons}, as a dialog almost always
contains a set of response buttons, such as \kbd{Ok}, \kbd{Yes},
\kbd{No} and \kbd{Cancel}.

In this example, we will create a dialog with a text entry. We use the
\constructor{gtkDialogNewWithButtons}, which allows us to specify the
label and response code for each button:
<<>>=
dlg <- gtkDialogNewWithButtons(title="Enter a value", 
                               parent=NULL, flags=0,
                               "gtk-ok", GtkResponseType["ok"],
                               "gtk-cancel", GtkResponseType["cancel"],
                               show=FALSE)
@ 
%
If the label matches a stock ID, the icon and text are taken from the
stock definition. We use standard responses from
\code{GtkResponseType}, although in general the codes are simply
integer values; interpretation is up to the programmer. 

We pack our label and text entry into the dialog:
<<>>=
vb <- dlg$getContentArea()
hb <- gtkHBox()
hb['spacing'] <- 10
vb$packStart(hb)

hb$packStart(gtkLabel("Enter a value:"))
entry <- gtkEntry()
hb$packStart(entry)
@ 
%
The content of the dialog, such as a message or in this case a form,
is stored in the \textit{content area}, a \class{GtkVBox}. This box
has a separator and button box packed in at the end, we pack in a
horizontal box at the beginning below to hold a label and our entry
widget.

In the message dialog example, we called the \method{run}{GtkDialog}
method to block the \R\/ session. Here, we set the dialog to be modal
and connect to the \code{response} signal, which will inform us of the
user response asynchronously. The \R\/ session is not blocked.
<<>>=
ID <- gSignalConnect(dlg, "response", 
                     f=function(dlg, resp, user.data) {
                       if(resp == GtkResponseType["ok"])
                         print(entry$getText())
                       dlg$Destroy()
                     })
dlg$showAll()
dlg$setModal(TRUE)
@

\subsection{File chooser}
\label{sec:RGtk2:file-chooser}

A common task in a GUI is the selection of files and directories, for
example to load or save a document. \class{GtkFileChooser} is an
interface shared by widgets that choose files. \GTK\/ provides three
such widgets. The first is \class{GtkFileChooserWidget}, which may be
placed anywhere in a GUI. The other two are based on the
first. \class{GtkFileChooserDialog} embeds the chooser widget in a
modal dialog, while \class{GtkFileChooserButton} is a button that
displays a file path and launches the dialog when clicked.

\begin{example}{An open file dialog}{ex:RGtk2:open-file}
  Here, we demonstrate the use of the dialog, the most popular of the
  three.  An open file dialog can be created with:
<<openFileDialog>>=
dlg <- gtkFileChooserDialog(title="Open a file", 
                     parent=NULL, action="open",
                     "gtk-ok", GtkResponseType["ok"],
                     "gtk-cancel", GtkResponseType["cancel"])
@ 
%
The dialog constructor allows one to spcify a title, a parent and an
action, either \code{open}, \code{save}, \code{select-folder} or
\code{create-folder}. In addition, the dialog buttons must be
specified, as with the last example using
\code{gtkDialogNewWithButtons}.

One can use the \code{run} method to make this modal or connect to the
\signal{response} signal. We do the latter: 
<<print=FALSE>>=
gSignalConnect(dlg, "response", f=function(dlg, resp, data) {
  if(resp == GtkResponseType["ok"]) {
    filename <- dlg$getFilename()
    print(filename)
  }
  dlg$destroy()
})
@
%
The file selected is returned by
\method{getFilename}{gtkFileChooser}. If multiple selection is enabled
with via the \code{select-multiple} property, one should call the
plural \method{getFilenames}{gtkFileChooser}.

For the open dialog, one may wish to specify one or more filters that
narrow the available files for selection:
<<>>=
fileFilter <- gtkFileFilter()
fileFilter$setName("R files")
fileFilter$addPattern("*.R")
fileFilter$addPattern("*.Rdata")
dlg$addFilter(fileFilter)
@ 
%
The \constructor{gtkFileFilter} function constructs a filter, which is
given a name and a set of file name patterns, before being added to
the file chooser. Filtering by mime type is also supported.

\end{example}

The save file dialog would be similar. The initial filename could be
specified with \method{setFilename}{gtkFileChooser}, or folder with
\method{setFolder}{gtkFileChooser}. The
\code{do-overwrite-confirmation} property controls whether the user is
prompted when attempting to overwrite an existing file.

Other features not discussed here, include embedding of preview and
other custom widgets, and specifying shortcut folders.

\subsection{Other choosers}
\label{sec:RGkt2:other-choosers}

There are several other types of dialogs for making common types of
selections. These include \code{GtkCalendar} for picking dates,
\code{GtkColorSelectionDialog} for choosing colors, and
\code{GtkFontSelectionDialog} for fonts. These are very high-level
dialogs that are trivial to construct and manipulate, at a cost of
flexibility.
