This example shows a combination widget that is familiar from other
statistics GUIs. It provides two tree views listing variable names and
has arrows to move variable names from one side to the other. Often
such widgets are used for specifying statistical models. 

\begin{figure}
  \centering
  \includegraphics[width=.4\textwidth]{ex-RGtk2-pingpong}
  \caption{An example showing to tree views with buttons to move
    entries from one to the other. This is a common method for
    variable selection.}
  \label{fig:RGtk2-pingpong}
\end{figure}


We will use Example~\ref{ex:RGtk2:add-stock-icons}, in particular its
function \code{addToStockIcons}, to add some custom
stock icons to identify the variable type.
<<echo=FALSE>>=
## also in previous example
addToStockIcons <- function(pixbufs, stock.prefix="new") {
  iconfactory <- gtkIconFactory()
  
  items <- lapply(names(pixbufs), function(iconName) {
    ## each icon has its own icon set, which is registered with icon factory
    iconset <- gtkIconSetNewFromPixbuf(pixbufs[[iconName]])
    stockName <- paste(stock.prefix, "-", iconName, sep="")
    iconfactory$add(stockName, iconset)
    
    ## create stock item for icon
    as.GtkStockItem(list(stock_id = stockName, label = iconName))
  })
  ## register our factory of icons
  iconfactory$addDefault()
  ## officially register the stock items
  gtkStockAdd(items)
}
@ 
<<addIcons>>=
fileNms <- c(factor = system.file("images","factor.gif", package="gWidgets"),
             numeric = system.file("images","numeric.gif", package="gWidgets"))
pixbufs <- lapply(fileNms, function(fn) gdkPixbuf(file = fn)[[1]])
addToStockIcons(pixbufs)
@ 

To keep track of the variables in the two tree views we use a single
model. It has a column for all the variable names, a column for the
icon, and two columns to keep track of which variable names are to be
displayed in the respective tree views.
<<>>=
d <- data.frame(varNames=c("response", "trt1", "trt2"),
                stock.id=c("new-numeric", "new-factor", "new-factor"),
                leftView  = rep(TRUE, 3),
                rightView = rep(FALSE, 3),
                stringsAsFactors=FALSE)
model <- rGtkDataFrame(d)
@ 

We will use a filtered data store to show each tree view.
As the two tree views are identical, except for the rows that are
displayed, we generate them with a function. The \code{vis.col}
indicates which column in the \code{rGtkDataFrame} object contains the
visibility information. Our tree view packs in both a pixbuf cell
renderer and a text cell renderer.
<<>>=
makeView <- function(model, vis.col) {
  filteredModel <- model$filter()
  filteredModel$setVisibleColumn(vis.col - 1)
  tv <- gtkTreeView(filteredModel)
  tv$getSelection()$setMode("multiple")
  ##
  cr <- gtkCellRendererPixbuf()
  cr['xalign'] <- 1
  tv$insertColumnWithAttributes(0, "Variable", cr, "stock-id" = 1)
  vc <- tv$getColumn(0)
  ##
  cr <- gtkCellRendererText()
  vc$PackStart(cr, expand=TRUE)
  cr['xalign'] <- 0
  cr['xpad'] <- 5
  vc$addAttribute(cr, "text", 0)

  return(tv)
}
@ 
We now create the tree views:
<<>>=
views <- list()
views[["left"]] <- makeView(model,3)
views[["right"]] <- makeView(model,4)
selections <- lapply(views, gtkTreeViewGetSelection)
@ 
We need buttons to move the values left and right; these are stored
in a list for convenience.
<<>>=
buttons <- list()
buttons[["fromLeft"]] <- gtkButton(">")
buttons[["fromRight"]] <- gtkButton("<")
@ 

Our basic GUI is shown in Figure~\ref{fig:RGtk2-pingpong} where the
two tree views are placed side-by-side.
%The basic GUI just lays out the two tree views with the buttons in
%between. We left out command to add scroll windows etc.
<<basicGUI, echo=FALSE>>=
## Not shown, but lays out a basic GUI
w <- gtkWindow()
g <- gtkHBox()
w$add(g)
g$PackStart(views$left)
vg <- gtkVBox()
QT <- sapply(buttons, function(i) vg$packStart(i, expand=FALSE))
g$PackStart(vg)
g$PackStart(views$right)
@ 

The key handler moves the selected value from one side to the other. A
complication is that when the view is using filtering the selection
returns values relative to the child model (the filtered one). In
general, the methods \code{convertChildPathToPath} and
\code{convertChildIterToIter} of the filtered model will translate
between the two models, but in this case we map the indices using the
appropriate visibility column. This handler assumes that an index
indicating the view (\code{i}) is passed as user data.
<<>>=
moveSelected <- function(b, i) {
  selection <- selections[[i]]
  selected <- selection$getSelectedRows()
  if(length(selected$retval)) {
    childRows <- sapply(selected$retval, function(childPath) {
      childRow <- as.numeric(childPath$toString()) + 1L
    })
    shownIndices <- which(model[, 2L + i])
    rows <- shownIndices[childRows]
    
    model[rows, 2L + i] <- FALSE
    model[rows, 2L + (3L-i)] <- !model[rows, 2L + i]
  }
}
@ 
We connect the handler to the \qcode{clicked} signal for the buttons.
<<results=hide>>=
mapply(gSignalConnect, buttons, "clicked", list(moveSelected), 1:2)
@ 

We add one flourish, namely ensuring that the arrows are not sensitive
when the corresponding selection is not set.
<<disableButtonsIfNoSelection, results=hide>>=
disableButton <- function(sel, button) {
  selected <- sel$getSelectedRows()
  button$setSensitive(length(selected$retval) != 0)
}
mapply(gSignalConnect, selections, "changed", list(disableButton), buttons)
@
%
As the initial state has no selection, we set the button
sensitivities accordingly.
<<results=hide>>=
sapply(buttons, gtkWidgetSetSensitive, FALSE)
@ 
