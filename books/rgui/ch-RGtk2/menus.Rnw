% Menus in RGtk2

<<echo=FALSE>>=
require(RGtk2)
@ 

In the traditional WIMP-style GUI, the user executes commands by
selecting items from a menu. In GUI terminology, such a command is
known as an \textit{action}. A GUI may provide more than one control
for executing a particular action. Menubars and toolbars are the two
most common widgets for performing application-wide actions. In this
chapter, we will introduce actions, menus and toolbars and conclude by
explaining the mechanisms in \GTK\/ for conveniently defining and
managing actions and associated widgets in a large application.

\section{Actions}
\label{sec:RGtk2:actions}


\GTK\/ represents actions with the \class{GtkAction} class. A
\class{GtkAction} can be proxied by widgets like buttons in a
\class{GtkMenubar} or \class{GtkToolbar}.  The \constructor{gtkAction}
function is the constructor:
<<rgtk2-menus-actions-constructor>>=
a <- gtkAction(name="ok", label="_Ok", 
               tooltip="An OK button", stock.id="gtk-ok")
@ 
%
The constructor takes arguments \argument{name}{gtkAction} (to
programmatically refer to the action), \argument{label}{gtkAction}
(the displayed text), \argument{tooltip}{gtkAction}, and
\argument{stock.id}{gtkAction} (identifying a stock icon).  The
command associated with an action is implemented by a callback
connected to the \signal{activate} signal:
<<rgtk2-menus-actions-activate, print=FALSE>>=
gSignalConnect(a, "activate", f = function(w, data) {
  print(a$getName())                    # or some useful thing
})
@ 


An action plays the role of a data model describing a command, while
widgets that implement the \class{GtkActivatable} interface are the
views and controllers. All buttons, menu items and tool items
implement \class{GtkActivatable} and thus may serve as action
proxies. Actions are connected to widgets through the method
\method{connectProxy}{gtkAction}:
<<ConnectAction>>=
b <- gtkButton()
a$connectProxy(b)
@
%
Certain aspects of a proxy widget are coordinated through the
action. This includes sensitivity and visibility, corresponding to the
\code{sensitive} and \code{visible} properties. To synchronize with
aesthetic properties like the \code{label} and icon (e.g.,
\code{stock-id}), the \code{use-action-appearance} property must be
set on the activatable widget:
<<rgtk2-menus-action-appearance>>=
a["use-action-appearance"] <- TRUE
@ 

Often, the commands in an application have a natural grouping. It can
be convenient to coordinate the sensitivity and visibility of entire
groups of actions. \class{GtkActionGroup} represents a group of
actions. By convention, keyboard accelerators are organized by group,
and the accelerator for an action is usually specified upon insertion:
<<rgtk2-menus-action-group>>=
group <- gtkActionGroup()
group$addActionWithAccel(a, "<control>O")
@ 

In addition to the properties already introduced, an action may have a
shorter label for display in a toolbar (\code{short\_label}), and
hints for when to display its label (\code{is\_important}) and image
(\code{always\_show\_image}).

There is a special type of action that has a toggled state:
\class{GtkToggleAction}. The \code{active} property represents the
toggle. A further extension is \class{GtkRadioAction}, where the
toggled state is shared across a list of radio actions, via the
\code{group} property. Proxy widgets represent toggle and radio
actions with controls resembling check boxes and radio buttons,
respectively. Here, we create a toggle action for fullscreen mode:
<<rgtk2-menus-toggle-action>>=
fullScreen <- gtkToggleAction("fullscreen", "Full screen", "Toggle full screen")
gSignalConnect(fullScreen, "toggled", function(action) {
  window$fullscreen()
})
@
%
We connect to the \code{toggled} signal to respond to a change in the
action state.

<<showGUI, echo=FALSE>>=
window <- gtkWindow(show=FALSE)
window['title'] <- "Action with button example"
window$add(b)
window$showAll()
@ 

\section{Menus}
\label{sec:RGtk2:menus}

A menu is a compact, hierarchically organized collection of buttons,
each of which may proxy an action. Menus listing window-level actions
are usually contained within a menu bar at the top of the window or
screen. Menus with options specific to a particular GUI element may
``popup'' when the user interacts with the element, such as by
clicking the right mouse button. Menubars and popup menus may be
constructed by appending each menu item and submenu separately, as
illustrated below. For menus with more than a few items, we recommend
the strategies described in Section~\ref{sec:RGtk2:UIManager}.

\subsection{Menubars}

We will first demonstrate the menu bar, leaving the popup menu for
later.  The first step towards populating a menu bar is to construct
the menu bar itself:
<<rgtk2-menus-menubar>>=
menubar <- gtkMenuBar()
@

A menu bar is a special type of container called a menu shell. An
instance of \class{GtkMenuShell} contains one or more menu
items. \class{GtkMenuItem} is an implementation of
\class{GtkActivatable}, so each menu item can proxy an
action. Usually, a menu bar consists multiple instances of the other
type of menu shell: the menu, \class{GtkMenu}. Here, we create a menu
object for our ``File'' menu:
<<rgtk2-menus-menu>>=
fileMenu <- gtkMenu()
@
%
As a menu is not itself a menu item, we first must embed the menu
into a menu item, which is labeled with the menu title:
<<rgtk2-menus-menuitem>>=
fileItem <- gtkMenuItemNewWithMnemonic(label="_File")
fileItem$setSubmenu(fileMenu)
@
%
The underscore in the label indicates the key associated with the
mnemonic for use when navigating the menu with a keyboard.  Finally,
we append the item containing the file menu to the menu bar:
<<rgtk2-menus-append>>=
menubar$append(fileItem)
@ 
%
In addition to \method{append}{gtkMenuShell}, it is also possible to
\method{prepend}{gtkMenuShell} and \method{insert}{gtkMenuShell} menu
items into a menu shell. As with any container, one can
\method{remove}{gtkContainer} a child menu item, although the
convention is to desensitize an item, through the \code{sensitive}
property, when it is not currently relevant.

Next, we populate our file menu with menu items that perform some
command. For example, we may desire an open item:
<<rgtk2-menus-open>>=
open <- gtkMenuItemNewWithMnemonic("_Open")
@
%
This item does not have an associated \class{GtkAction}, so we need to
implement its activate signal directly:
<<rgtk2-menus-open-activate>>=
gSignalConnect(open, "activate", function(item) {
  f <- file.choose()
  file.show(f)
})
@ 
%
The item is now ready to be added to the file menu:
<<rgtk2-menus-append-item>>=
fileMenu$append(open)
@ 

It is recommended, however, to create menu items that proxy an
action. This will facilitate, for example, adding an equivalent
toolbar item later. First, we create the action:
<<rgtk2-menus-save-action>>=
saveAction <- gtkAction("save", "Save", "Save object", "gtk-save")
@ 
%
Then the appropriate menu item is generated from the action and added
to the file menu:
<<rgtk2-menus-save-item>>=
save <- saveAction$createMenuItem()
##save["use-action-appearance"] <- TRUE
fileMenu$append(save)
@ 

Toggle menu items, i.e., a label next to a check box, are also
supported. A toggle action will create one implicitly:
<<rgtk2-menus-toggle-item>>=
autoSaveAction <- gtkToggleAction("autosave", "Autosave", "Enable autosave")
autoSave <- autoSaveAction$createMenuItem()
fileMenu$append(autoSave)
@ 

A simple way to organize menu items, besides grouping into menus, is
to insert separators between logical groups of items. Here, we insert
a separator item, rendered as a line, to group the open and save
commands a part from the rest of the menu:
<<rgtk2-menus-separator>>=
fileMenu$append(gtkSeparatorMenuItem())
@ 

\subsection{Popup Menus}

\begin{example}{Popup menus}{ex:RGtk2-popup-menus}
\SweaveInput{ex-RGtk2-menu-popup}
\end{example}

\section{Toolbars}
\label{sec:RGtk2:toolbars}

Toolbars are like menu bars in that they are containers for
activatable items, but toolbars are not hierarchical. Thus, toolbars
are not appropriate for storing a large number of items, only those
that are activated most often.

We begin by constructing an instance of \class{GtkToolbar}:
<<rgtk2-menus-toolbar-construct>>=
toolbar <- gtkToolbar()
@ 

In analogous fashion to the menu bar, toolbars are containers for tool
items. Technically, an instance of \class{GtkToolItem} could contain
any type of widget, though toolbars typically represent actions
with buttons. The \class{GtkToolButton} class implements this common
case.  Here, we create a tool button for opening a file:
<<rgtk2-menus-toolbar-open-item>>=
openButton <-  gtkToolButton(stock.id = "gtk-open") 
@ 
%
Tool buttons have a number of properties, including \code{label} and
several for specifying an icon. Above, we specify a stock identifier,
for which there is a predefined translated label and theme-specific icon.
As with any other container, the button may be added to the toolbar with
the \method{add}{GtkContainer} method:
<<rgtk2-menus-toolbar-add>>=
toolbar$add(openButton)
@ 
%
This appends the open button to the end of the toolbar. To insert into
a specific position, we would call the \method{insert}{GtkToolbar} method.

Usually, any application with a toolbar also has a menu bar, in which
case many actions are shared between the two containers. Thus, it is
often beneficial to construct a tool button directly from its
corresponding action:
<<rgtk2-menus-toolbar-save-item>>=
saveButton <- saveAction$createToolItem()
toolbar$add(saveButton)
@ 
%
A tool button is created for \code{saveAction}, created in the
previous section.

Like menus, related buttons may be grouped using separators:
<<rgtk2-menus-toolbar-separator>>=
toolbar$add(gtkSeparatorToolItem())
@

Any toggle action will create a toggle tool button as its proxy:
<<rgtk2-menus-toolbar-toggle>>=
fullScreenButton <- fullScreen$createToolItem()
toolbar$add(fullScreenButton)
@ 
%
A \class{GtkToggleToolButton} embeds a \class{GtkToggleButton}, which
is depressed whenever its \code{active} property is \code{TRUE}.

A toolbar may be customized in a number of ways.
%% Note about toolbar style and is-important, i.e., where did my text go?
%% More complex layout is possible with 'expand' child property

It is now our responsibility to place the toolbar at the top of the
window, under the menu created in the previous section:
<<rgtk2-menus-toolbar-place>>=
@ 

\begin{example}{Color menu tool button}{ex:RGtk2-color-tool-button}
  \SweaveInput{ex-RGtk2-color-tool-button}
\end{example}

Toolbar items have some common properties. The buttons are comprised
of an icon and text, and the style of their layout is specified by the
toolbar method \method{setStyle}{gtkToolbar}, with values coming from
the \code{GtkToolbarStyle} enumeration. Toolbar items can have a
tooltip set for them through the methods
\method{setTooltipText}{gtkToolItem} or
\method{setTooltipMarkup}{gtkToolItem}, the latter if PANGO markup is
desired. Toolbar items can be disabled, through the method
\method{setSensitive}{gtkWidget}.

The items can be one of a few different types. A stock toolbar item is
constructed by \constructor{gtkToolbarButtonNewFromStock}, with the
stock id as the argument. The constructor
\constructor{gtkToolbarButton} creates a button that can have its
label and icon value set through methods
\method{setLabel}{gtkToolbarButton} and
\method{setIconWidget}{gtkToolbarButton}. Additionally, there are
methods for setting a tooltip or specifying a stock id after
construction. A toggle button, which toggles between looking depressed
or not when clicked is created by \constructor{gtkToggleToolButton}
(or \constructor{gtkToggleToolButtonNewFromStock}).  Additionally
there are constructors to place menus
(\constructor{gtkMenuToolButton}) and radio groups
(\constructor{gtkRadioToolButton}).
  
% signale
The \code{clicked} signal is emitted when a toolbar button is
pressed. For the toggle button, the \code{toggle} signal is
emitteed.



\begin{example}{Basic toolbar usage}{ex:RGtk2-basic-toolbar}
We illustrate with a toolbar whose buttons are produced in various ways.
<<>>=
tb <- gtkToolbar()
@ 
A button with a stock icon is produced by a call to the appropriate constructor.
<<>>=
b1 <-  gtkToolButtonNewFromStock("gtk-open") 
tb$add(b1)
@ 
To use a custom icons, requires a few steps.
<<>>=
f <- system.file("images/dataframe.gif", package="gWidgets")
image <- gtkImageNewFromFile(f)
b2 <- gtkToolButton()
b2$setIconWidget(image)
b2$setLabel("Edit")
tb$add(b2)
@ 
Adding a toggle button also is just a matter of calling the
appropriate constructor. In this, example we illustrate how to
initiate the callback only when the button is depressed.
<<>>=
b3 <- gtkToggleToolButtonNewFromStock("gtk-fullscreen")
tb$add(b3)
QT <- gSignalConnect(b3, "toggled", f=function(button, data) {
  if(button$getActive())
    cat("toggle button is depressed\n")
  })
@ 
We give the other buttons a simple callback when clicked:
<<>>=
QT <- sapply(1:2, function(i) {
  gSignalConnect(tb[[i]], "clicked", function(button, data) {
    cat("You clicked", button$getLabel(), "\n")
  })
})
@ 

<<MakeToolbarGUI, echo=FALSE>>=
## simple GUI to finish toolbar example
w <- gtkWindow(show=FALSE)
w['title'] <- "Toolbar example"
g <- gtkVBox()
w$add(g)
g$packStart(tb, expand=FALSE)
g$packStart(gtkLabel("filler"), expand=TRUE, fill=TRUE)
w$showAll()
@ 
\end{example}

\section{Managing a large user interface}
\label{sec:RGtk2:UIManager}


A GUI is designed around actions that are accessible through the
menubar and the toolbar. The notion of a \dfn{user interface manager}
(\acronym{UI} manager) separates out the definitions of the actions
from the user interface. The steps required to use \GTK's UI manager
are 
\begin{enumerate}
\item define a UI manager,
\item  set up an accelarator group for
keyboard shortcuts,
\item define our actions,
\item create action groups to
specify the name, label (with possible mnuemonic), keyboard
accelerator, tooltip, icon and callback for the graphical elements
that call the action,
\item specify where the menu items and toolbar
items will be placed,
\item connect the action group to the UI manager,
and finally
\item display the widgets.
\end{enumerate}

We show by an example how this is done. 

\begin{example}{UI Manager example}{ex:RGtk2:UImanager}
  \SweaveInput{ex-RGtk2-UImanager}
\end{example}
