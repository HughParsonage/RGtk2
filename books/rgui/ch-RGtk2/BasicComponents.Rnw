

\section{Buttons}
\label{sec:RGtk2:gtkButton}

The button is the very essence of a GUI. It communicates its purpose
to the user and executes a command in response to a simple click or
key press. In \GTK\/, A basic button is usually constructed using
\constructor{gtkButton}, as the following example demonstrates.

\begin{example}{Button constructors}{eg:RGtk2:button-constructors}
<<ButtonConstructors>>=
w <- gtkWindow(show=FALSE)
w$setTitle("Various buttons")
w$setDefaultSize(400, 25)
g <- gtkHBox(homogeneous=FALSE, spacing=5)
w$add(g)
b <- gtkButtonNew() 
b$setLabel("long way")
g$packStart(b)
g$packStart(gtkButton(label="label only") )
g$packStart(gtkButton(stock.id="gtk-ok") )
g$packStart(gtkButtonNewWithMnemonic("_Mnemonic") ) # Alt-m to "click"
w$show()
@ 
\end{example}

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{RGtk2-various-button}
  \caption{Various buttons}
  \label{fig:RGtk2:various-buttons}
\end{figure}

A \class{GtkButton} is simply a clickable region on the screen that is
decorated to appear as a button. \class{GtkButton} is a subclass of
\class{GtkBin}, so it will accept any widget as an indicator of its
purpose. By far the most common button decoration is a label. The
first argument of \constructor{gtkButton},
\argument{label}{gtkButton}, accepts the text for an automatically
created \class{GtkLabel}. We have seen this usage in our ``Hello
World'' example and others.

The alternative \argument{stock.id}{gtkButton} argument will use
decorations associated with the stock identifier. For example,
``gtk-ok'' would produce a button with a theme-dependent image (such
as a checkmark) and the ``Ok'' label, with the appropriate mnemonic
and translated into the current language.  The available stock
identifiers are listed by \function{gtkStockListIds}. See
\code{help(``stock-items'')} for more information.

The final button created in the example uses
\constructor{gtkButtonNewWithMnemonic} to create a button with a
mnemonic. Mnemonics are specified by prefixing the character with an
underscore.

The method \method{setRelief}{gtkButton} changes the relief style of
the button. For example, the relief can be disable so that the button
is drawn like a label.

%% signals
\paragraph{Signals}

The \signal{clicked} signal is emitted when the button is
clicked on with the mouse or when the button has focus and the
\kbd{enter} key is pressed. A callback can listen for this event to
perform a command when the button is clicked.  

\begin{example}{Callback example for
    \code{gtkButton}}{eg:RGtk2:gtkButton-callback}

<<CallbackExampleForButton>>=
w <- gtkWindow(); b <- gtkButton("click me");
w$add(b)

ID <- gSignalConnect(b,"button-press-event",   # just mouse click
                     f = function(w,e,data) {
                       print(e$getButton())    # which button
                       return(FALSE)           # propagate
                     })
ID <- gSignalConnect(b,"clicked",              # click or keyboard
                     f = function(w,...) {
                       print("clicked")
                     })
@ 
\end{example}

As buttons are intended to call an action immediately after being
clicked, it is customary to make them insensitive to user input when
the action is not possible. The \method{setSensitive}{gtkWidget}
method can adjust this for the button, as with other widgets.

%% Buttons initiate actions
Windows often have a default action. For example, if a window contains
a form, the default action often submits the form. If the action a
button is to initiate is the default action for the window it can be
set so that it is activated when the user presses \kbd{enter} while
the parent window has the focus. To implement this, the property
\code{can-default} must be \code{TRUE} and the widget method
\method{grabDefault}{gtkWidget} must be called. (This is not specific
to buttons, but any widget that can be activatable.)

If the action that a button initiates is to be represented elsewhere
in the GUI, say a menu bar, then a \code{GtkAction} object may be
appropriate. Action objects are covered in
Section~\ref{sec:RGtk2:UIManager}.

\begin{example}{Spacing between buttons}{eg:RGtk2:mac-buttons}
  \SweaveInput{ex-RGtk2-mac-buttons.Rnw}
\end{example}

\section{Static Text and Images}

\subsection{Labels}
\label{sec:RGtk2:gtkLabel}

The primary purpose of a label is to communicate the role of another
widget, as we showed for the button. Labels are created by the
\constructor{gtkLabel} constructor. Its main argument is
\argument{str}{gtkLabel} to specify the button text, stored in the
\code{label} property. This text can be set with either
\method{setLabel}{gtkLabel} or \method{setText}{gtkLabel} and
retrieved with either \method{getLabel}{gtkLabel} or
\method{getText}{gtkLabel}.  The difference being the former
respects formatting marks.

\begin{example}{Label formatting}{eg:RGtk2:label-formatting}
  As all text in a \GTK\/ GUI is ultimately displayed by
  \class{GtkLabel}, there are many formatting options available.  This
  example demonstrates a sample of these~(Figure~\ref{fig:RGtk2:label-formatting})
  
  \begin{figure}
    \centering
    \includegraphics[width=.5\textwidth]{fig-RGtk2-labels}
    \caption{Various formatting for a label: wrapping, alignment,
      ellipsizing, PANGO markup}
    \label{fig:RGtk2:label-formatting}
  \end{figure}
  
<<LabelFormatting, results=hide>>=
w <- gtkWindow(show=FALSE); w$setTitle("Label formatting")
w$setSizeRequest(250,300)               # narrow
g <- gtkVBox(spacing=2); g$setBorderWidth(5); w$add(g)
string <- "the quick brown fox jumped over the lazy dog"
## wrap by setting number of characters
basicLabel <- gtkLabel(string)
basicLabel$setLineWrap(TRUE)
basicLabel$setWidthChars(35)            # no. characters

## Set ellipsis to shorten long text
ellipsized <- gtkLabel(string)
ellipsized$setEllipsize("middle")

## Right justify text lines
## use xalign property for aligning entire block
rightJustified <- gtkLabel("right justify"); 
rightJustified$setJustify("right")
rightJustified['xalign'] <- 1

## PANGO markup
pangoLabel <- gtkLabel()
tmpl <- "<span foreground='blue' size='x-small'>%s</span>"
pangoLabel$setMarkup(sprintf(tmpl, string))
#
sapply(list(basicLabel, ellipsized, rightJustified, pangoLabel), 
       g$packStart, expand = TRUE, fill = TRUE)
w$showAll()
@ 
\end{example}

Many of the text formatting options are demonstrated in
Example~\ref{eg:RGtk2:label-formatting}. Line wrapping is enabled with
\method{setLineWrap}{gtkLabel}. Labels also support explicit line
breaks, specified with ``\code{\backslashn}.'' The
\method{setWidthChars}{gtkLabel} method is a convenience for instructing the
label to request enough space to show a specified number of
characters in a line.  When space is at a premium, long labels can be
ellipsized, i.e., have some of their text replaced with an
ellipsis, ``...''.  By default this is turned off; to enable, call
\method{setEllipsize}{gtkLabel}.  The property \code{justify}, with
values taken from \code{GtkJustification}, controls the alignment of
multiple lines within a label. To align the entire block of text
within the space allocated to the label, modify the \code{xalign}
property, as described in Section~\ref{sec:RGtk2:layout:align}.

\GTK\/ allows markup of text elements using the Pango text attribute
markup language, an XML-based format that resembles basic HTML. The
method \method{setMarkup}{gtkLabel} accepts text in the format. Text
is marked using tags to indicate the style. Some convenient tags are
\code{<b>} for bold, \code{<i>} for italics, \code{<ul>} for
underline, and \code{<tt>} for monospace text. More complicated markup
involves the \code{<span>} tag markup, such as \code{<span
  color='red'>some text</span>}. As with HTML, the text may need to be escaped
first so that designated entities replace reserved characters.

Although mostly meant for static text display, \class{GtkLabel} has
some interactive features. If the \code{selectable} property is set to
\code{TRUE}, the text can be selected and copied into the clipboard.
Labels can hold mnemonics for other widgets; this is useful for
navigating forms. The mnemonic is specified at construction time with
\code{gtkLabelNewWithMnemonic}. The
\method{setMnemonicWidget}{gtkLabel} method identifies the widget to
which the mnemonic refers.


%% signals
\paragraph{Signals}
Unlike buttons, labels do not emit any specific signals, as they are
intended to hold static text. Although a label is a \class{GtkWidget},
it does not receive any system events. A work-around is to place the
label within an instance of \class{GtkEventBox}. This creates a
non-visible parent window for the label that listens to the windowing
system. Example~\ref{eg:RGtk2:editable-label} will illustrate the use
of an event box.  Alternatively, if a clickable label is desired, one
could use an instance of \code{gtkButton} with its \code{relief}
property assigned to \qcode{none}. %%\code{GtkReliefStyle['none']}.

%% ML: Better to just update RGtk2 and talk about the 2.18 support for
%% links in label markup. Link buttons are pretty limited in comparison.

% \subsection{Link Buttons}
% \label{sec:link-buttons}

% A link button is a special label which shows an underlined link, such
% as is done by a web browser (newer versions of \GTK\/ allow the label
% of a button to contain HTML links). The \code{uri} is specified to the
% \constructor{gtkLinkButton} constructor with an optional
% \argument{label}{gtkLinkButton} argument. If none is specified, the
% \code{uri} is used to provide the value. This \code{uri} is stored in
% the \code{uri} property and the label in the \code{label} value. These
% may be adjusted later.

% As the link button inherits from the \class{gtkButton} class, the
% \code{clicked} signal is emitted when a user clicks a mouse on the link.

% \begin{example}{Basic link button usage}{eg:RGtk2:link-button}
% <<LinkButton>>=
% w <- gtkWindow()
% g <- gtkVBox(); w$add(g)
% lb <- gtkLinkButton(uri="http://www.r-project.org")
% lb1<- gtkLinkButton(uri="http://www.r-project.org", label="R Home")
% g$packStart(lb)
% g$packStart(lb1)

% f <- function(w,...) browseURL(w['uri'])

% ID <- gSignalConnect(lb,  "clicked", f = f)
% ID <- gSignalConnect(lb1, "clicked", f = f)
% @ 
% \end{example}

\subsection{Statusbars}
\label{sec:RGtk2:statusbars}


In \GTK, a statusbar is constructed through the
\constructor{gtkStatusbar} function. Statusbars must be placed at the
bottom of a top-level window by the programmer. In \GTK, a statusbar
keeps various stacks of messages for display. One adds a message to
display for given stack through the \method{Push}{gtkStatusbar} method
by specifying first an integer value for \code{context.id} and a
message. To pop the top message on a stack and display the next, the
method \method{Pop}{gtkStatusbar} method is available.

%% XXX
%% TODO: add GtkInfoBar
%% TODO: somehow, progress bars have gotten lost
%% TODO: with progress bars, mention GtkSpinner

\subsection{Information bars}
\label{sec:gtkInfoBar}

An information bar is similar in purpose to a message dialog, only is intended to
be less obtrusive. \GTK\/ provides the \class{GtkInfoBar} class for
managing information bars. The use is similar to a dialog: one places
widgets into their content area, and listens to the
\signal{response} signal of the button. However, the presentation of the
message in this case is a simple call to its \meth{show} method (or
\meth{hide}). The placement of the bar is left to the user, it does
not carry its own top-level window.

A simple use might look like:
<<>>=
ib <- gtkInfoBar(show=FALSE)
ib$setNoShowAll(TRUE)
@ 
We call \method{setNoShowAll} so that the widget isn't displayed when
its parent container is. To this information bar we add a simple label
and specify the message type using one of the enumerated values in \code{GtkMessageType}.
<<>>=
l <- gtkLabel("Warning, Warning ....")
ib$setMessageType("warning")            
ib$getContentArea()$add(l)
@ 
A button to allow the user to hide the bar can be added as follows:
<<>>=
ib$addButton(button.text="gtk-ok",
             response.id=GtkResponseType['ok']) # not just "ok"
@ 
As with dialogs, we connect to the \signal{response} signal which is
emitted when the button is activated.
<<results=hide>>=
gSignalConnect(ib, "response", function(w, ...) w$hide())
@ 

Our configuration is done. We now add the bar to a top-level window:
<<addToWinodw>>=
w <- gtkWindow(); w['title'] <- "Info bar example"
g <- gtkVBox()
w$add(g)
g$packStart(ib, expand=FALSE)
#
contentArea <- gtkHBox()
g$packStart(contentArea, expand=TRUE)
l <- gtkLabel("Lorem ipsum so dolor ...")
contentArea$packStart(l)
#
ib$show()                               # show
@ 



\subsection{Progress bars}
\label{sec:progress-bars}
It is common to use a progress bar to indicate to the user the amount
of time remaining during a long running computation. The
\constructor{gtkProgressBar} creates the widget. The typical use
involves placing a text label to notify the user and periodically
updating the bar to reflect the percentage of time spent. 

The following will do so:
<<>>=
w <- gtkWindow(); w$setTitle("Progress bar example")
pb <- gtkProgressBar()
w$add(pb)
#
pb$setText("Please be patient...")
for(i in 1:100) {
  pb$setFraction(i/100)
  Sys.sleep(0.05) ## replace with a step in the process
}
pb$setText("All done.")
@ 


Progress bars can also show activity but not an indication of
duration. Activity is displayed by periodically pulsing the bar
through the \method{pulse}{gtkProgressBar} method.


\paragraph{\class{GtkSpinner}}
Related to a progress bar is the \class{GtkSpinner} widget, which is
also used to show an indefinite amount of activity, and is commonly used in
web browser. The basic usage is straightforward: the object is created
by \constructor{gtkSpinner} and the animation is begun and ended with
teh respective methods \method{start}{gtkSpinner} and \method{stop}{gtkSpinner}.

\subsection{Images}
\label{sec:RGtk2:images}

It is often said that a picture can be worth a thousand
words. Applying this to GUIs, images can often provide a more space
efficient alternative to labels. \class{GtkImage} is the widget that
displays images. The constructor \constructor{gtkImage} supports
creating images from various in-memory image representations, files,
and other sources.  Images can be loaded after construction, as well. For example,
the \method{setFromFile}{gtkImage} method loads an image from a file.

The image widget, like the label widget, does not have a parent
\class{GdkWindow}, which means it does not receive window events. As
with the label widget, the image widget can be placed inside a
\constructor{gtkEventBox} container if one wishes to connect to such
events.


\begin{example}{Using a pixmap to present graphs}{ex:RGtk2:pixbuf}
  \SweaveInput{ex-RGtk2-ImageForGraphics}
\end{example}

<<notShown, echo=FALSE>>=
## Work this into an example ###
makeIconRGtk2 <- function(w, giffile) {
  if(checkPtrType(w, "GtkWindow")) {
    img <- gdkPixbufNewFromFile(giffile)
    if(!is.null(img$retval))
      w$setIcon(img$retval)
  }
}
@ 

\subsection{Stock icons}
\label{sec:RGtk2:stock-icons}

In \GTK\/, standard icons, like the one on the ``OK'' button, can be
customized by themes. This is implemented by a database that maps a
\textit{stock} identifier to an icon image. The stock identifier
corresponds to a commonly performed type of action, such as the ``OK''
response or the ``Save'' operation. There is no hard-coded set of
stock identifiers, however \GTK\/ provides a default set for the most
common operations. These identifiers are all prefixed with
``gtk-''. Users may register new types of stock icons.
%% ML: I believe there is an example of this in the RGtk2 demos

As mentioned previously, the full list of stock icons are returned in
a list by \function{gtkStockListIds}. The first $4$ are:
<<gtkStockListIds>>=
head(unlist(gtkStockListIds()), n=4)   
@ 

The use of stock identifiers over specific images is encouraged, as it
allows an application to be customized through themes. The
\constructor{gtkButton} and \constructor{gtkImage} constructors accept
a stock identifier passed as \code{stock.id} argument, and the icons in
toolbars and menus are most conveniently specified by stock
identifier. 

% ML: Sorry, but I am not sure if this illustrates an important concept


% In the example below, we use the method \method{renderIcon}{gtkWidget} to
% return a pixbuf containing the icon that can be used with the
% constructor \constructor{gtkImageNewFromPixbuf} to display the
% icon. Here the stock id and size are specified to the
% \method{renderIcon}{gtkWidget} method.

% \begin{example}{\constructor{gtkButtonNewFromStock} -- the hard way}{ex:RGtk2:stock-icon}
% \SweaveInput{ex-RGtk2-button-new-stock-hardway}
% \end{example}

% ML: Could this example be in the book, but marked as optional or advanced?
%% JV Only for the package?? This will be placed in the package as an example.
% \begin{example}{Adding to the stock icons}{ex:RGtk2:add-stock-icons}
%   \SweaveInput{ex-RGtk2-add-stock-icon}
% \end{example}



%% Alertpanel application
%% JV replaced this with one using reference Classes
\begin{example}{An alert panel}{eg:RGtk2:alert-panel}
  \SweaveInput{ex-RGtk2-alert-panel-2}
\end{example}

\section{Input Controls}

\subsection{Text entry}
\label{sec:RGtk2:gtkEntry}

The widgets explained thus far are largely static. For example, \GTK\/
does not yet support editable labels. Text editing is handled by other
widgets that are rendered in the familiar depressed box form. We will
discuss complex multi-line text editing in
Section~\ref{sec:RGtk2:textviews}. For entering a single line of text,
the \class{GtkEntry} widget is appropriate.  It is constructed by
\function{gtkEntry}.  Specifying the \argument{max}{gtkEntry} argument
calls a deprecated function, instead use the method
\method{setMaxLength}{gtkEntry} after construction.

The \code{text} property stores the text. This can be set with the
method \method{setText}{gtkEntry} and retrieved with
\method{getText}{gtkEntry}. Editing text programmatically relies on
the \class{GtkEditable} interface, which \class{GtkEntry}
implements. The method \method{insertText}{GtkEditable} inserts text.
Its argument \argument{new.text}{gtkEditableInsertText} contains the
text and \argument{position}{gtkEditableInsertText} specifies the
position of the text to be added. The return value is a list with the
component \code{position} indicating the position \textit{after} the
new text. The \method{deleteText}{GtkEditable} method deletes
text. This takes two integers indicating the start and finish location
of the text to delete.

\begin{example}{Insert and Delete text}{eg:RGtk2:insert-delete-text}
The example will show how to add then delete text.  
<<InsertDeleteText>>=
e <- gtkEntry()
e$setText("Where did that guy go?")
add.pos <- regexpr("guy", e['text']) - 1 # before "guy"
ret <- e$insertText("@$#%! ", position = add.pos)
e$getText()                             # or e['text']
e$deleteText(start = add.pos, end= ret$position)
e$getText()
@ 
\end{example}

%% signals
The \class{GtkEditable} interface supports three signals:
\signal{changed} when text is changed, \signal{delete-text} for delete
events, and \signal{insert-text} for insert events. It is possible to
prevent the insertion or deletion of text by connecting to the
corresponding signal and stopping the signal propagation with
\function{gSignalStopEmission}. 

\class{GtkEntry} defines a number of its own signals, including the
\signal{activate} signal, which is emitted when the \kbd{enter} key is
pressed.

%% skipped
%% ML: I agree; kind of a hack
% \begin{example}{Editable label}{eg:RGtk2:editable-label}
%   \SweaveInput{ex-RGtk2-editable-label}
% \end{example}

%% TODO: add note about icons and progress in GtkEntry

\subsection{Check button}
\label{sec:RGtk2:gtkCheckbox}
%% TODO: example in this section

Very often, the action performed by a button simply changes the value
of a state variable in the application. \GTK\/ defines several types
of buttons that explicitly manage and display the value of a state
variable. The simplest type of state variable is binary (boolean) and is
usually proxied by a \class{GtkCheckButton}. 

A \class{GtkCheckButton} is constructed by
\function{gtkCheckButton}. The optional argument
\argument{label}{gtkCheckButton} places a label next to the
button. The alternative constructor
\constructor{gtkCheckButtonNewWithMnemonic} gives the label a mnemonic.

As with any \class{GtkButton}, the \code{label} property stores the
label.  The state of the binary variable is represented by the
\code{active} property. It can be set or retrieved with the methods
\method{setActive}{gtkToggleButton} and
\method{getActive}{gtkToggleButton}.

When the state is changed the \signal{toggle} signal is emitted. The
callback should check the \code{active} property to determine if the
button has been enabled or disabled.

An alternative to \class{GtkCheckButton} is the lesser used
\class{GtkToggleButton}, which is actually the parent class of
\class{GtkCheckButton}. A toggle button is drawn as an ordinary
button. It remains depressed while the state variable is \code{TRUE},
instead of relying on a check box to communicate the binary value.

\subsection{Radio button group}
\label{sec:RGtk2:gtkRadioButton}

\GTK\/ provides two button types for discrete state variables that
accept more than two possible values: combo boxes, discussed in the
next section, and radio buttons. The \function{gtkRadioButton}
constructor creates an instance of \class{GtkRadioButton}, an
extension of \class{GtkCheckButton}. Each radio button belongs to a
group.  There is no explicit group object; rather, the buttons are
chained together as a linked list. By default, a newly constructed
button is added to its own group. If \argument{group}{gtkRadioButton}
is a list of radio buttons, the newly created button is added to the
group. The constructor returns a single radio button widget.

%% active
Like other types derived from \class{GtkToggleButton}, each radio
button in the group has an \code{active} property.  Only one button in
the group can have \code{active} set to \code{TRUE} at a time. To
determine which button is active, each button needs to be queried
individually. Setting \code{active} to \code{TRUE} activates the
corresponding button and ensures that the other buttons are disabled.

\begin{example}{Radio group construction}{eg:RGtk2:radio-buttons}
Creating a new radio button group with the basic
\constructor{gtkRadioButton} constructor follows this pattern:
<<RadioGroupExample>>=
vals <- c("two.sided", "less", "greater")
radiogp <- list()                                 # list for group
radiogp[[vals[1]]] <- gtkRadioButton(label=vals[1]) # group = NULL
for(i in vals[-1]) 
  radiogp[[i]] <- gtkRadioButton(radiogp, label=i)  # group is a list
@ 
Each button needs to be managed. Here we illustrate a simple GUI doing so.
<<results=hide>>=
w <- gtkWindow(); w$setTitle("Radio group example")
g <- gtkVBox(FALSE, 5); w$add(g)
sapply(radiogp, gtkBoxPackStart, object = g)
@ 
We can set and query which button is active, as follows:
<<>>=
g[[3]]$setActive(TRUE)           
sapply(radiogp, `[`, "active") 
@ 
Here is how we might register a callback for the \code{toggled} signal.
<<results=hide>>=
sapply(radiogp, gSignalConnect, "toggled",     # connect each
       f = function(w, data) {
         if(w$getActive()) # set before callback
           cat("clicked", w$getLabel(),"\n")
       })
@ 
\end{example}

The \method{getGroup}{gtkRadioButton} method returns a list containing
the radio buttons in the same group. However, it is in the reverse
order of construction (newest first). This results from an internal
optimization that prepends, rather than appends, the buttons to a
linked list.
% ML: wow! they can't reverse the list?

As a convenience, there are constructor functions ending with
\code{FromWidget} that determine the group from a radio button
belonging to the group. As we will see in our second example, this
allows for a more natural \function{sapply} idiom that avoids the need
to allocate a list and populate it in a \code{for} loop.

\begin{example}{Radio group using \code{getGroup}}{eg:gtk:radio-group-get-group}
  In this example below, we illustrate two things: using the
  \constructor{gtkRadioButtonNewWithLabelFromWidget} function to add new
  buttons to the group and the \method{GetGroup}{gtkRadioButton}
  method to reference the buttons. The \function{rev} function is used
  to pack the widgets, to get them to display first to last.
<<results=hide>>=
radiogp <- gtkRadioButton(label=vals[1])
sapply(vals[-1], gtkRadioButtonNewWithLabelFromWidget, group = radiogp)
w <- gtkWindow(); 
w['title'] <- "Radio group example"
g <- gtkVBox(); w$add(g)
sapply(rev(radiogp$getGroup()), gtkBoxPackStart, object = g)
@ 
\end{example}



\subsection{Combo boxes}
\label{sec:RGtk2:basic-combobox}

The combo box is a more space efficient alternative to radio buttons
and is better suited for when there are a large number of options. A
basic, text-only \class{GtkComboBox} is constructed by
\constructor{gtkComboBoxNewText}. Later we will discuss more
complicated combo boxes, where an underlying data model is
manipulated.
% Unlike
% others, as of writing, this widget must have its
% \method{Show}{gtkWidget} method called to be mapped.

For the basic combo box, items may be added in a few different ways.
The methods \method{appendText}{gtkComboBox} and
\method{prependText}{gtkComboBox} add a text item to the end or
beginning, respectively.  A text item is inserted at an arbitrary
position in the list with the \method{insertText}{gtkComboBox}.

The currently selected value is specified by index with the method
\method{setActive}{gtkComboBox} and returned by
\method{getActive}{gtkComboBox}. The index, as usual, is $0$-based,
and in this case, a value of $-1$ indicates that no value is selected.
The \method{getActiveText}{gtkComboBox} method can be used to retrieve
the text shown by the basic combo box.

Although combo boxes are much more space efficient than radio buttons,
it can be difficult to use a combo box when there are a large number
of selections. The \method{setWrapWidth}{gtkComboBox} method specifies
the preferred number of columns for displaying the items.


%% signal
The main signal to connect to is \signal{changed} which is emitted
when the active item is changed either by the user or the programmer
through the \method{setActive}{gtkComboBox} method.

%% JV: added this example in place of the more artificial one below.
\begin{example}{Using one combo box to populate another}{ex:RGtk2-comboboxes}
  \SweaveInput{ex-RGtk2-comboboxes}
\end{example}


\begin{example}{Dialog layout}{ex-RGtk2-dialog-layout}
  \SweaveInput{ex-RGtk2-dialog-layout.Rnw}
\end{example}

% \begin{example}{Combo box}{eg:RGtk2:simple-combo-box}
% A simple combo box may be produced as follows:
% <<results=hide>>=
% vals <- c("two.sided", "less", "greater")
% cb <- gtkComboBoxNewText()
% sapply(vals, gtkComboBoxAppendText, object = cb)
% cb$setActive(0)                         # first one
% gSignalConnect(cb, "changed",
%                f = function(w, ...) {
%                  i <- w$getActive() + 1 # shift index
%                  if(i == 0) 
%                    cat("No value selected\n")
%                  else
%                    cat("Value is", w$getActiveText(), "\n")
%                })
% w <- gtkWindow(show=FALSE)
% w['title'] <- "Combobox example"
% w$add(cb)
% w$show()
% @  % ML: gtkComboBoxNewText() will gain a show=TRUE argument in next version
% \end{example}

\subsection{Sliders}
\label{sec:RGtk2:sliders}

The slider widget and spin button widget allow selection from a
regularly spaced, semi-continuous list of values.

The slider widget is called \class{GtkScale} and may be oriented
either horizontally or vertically. This depends on the constructor:
\constructor{gtkHScale} or \constructor{gtkVScale}.  The user must
specify the minimum, maximum and step values for the scale.  This set
of values is formally represented by the \class{GtkAdjustment}
structure. Ordinarily, it is not necessary to construct a
\class{GtkAdjustment} explicitly. Instead, the constructors accept the
the numeric arguments \argument{min}{gtkHScale}, \argument{max}{gtkHScale},
and \argument{step}{gtkHScale}.

The underlying \class{GtkAdjustment} serves as the data model for the
slider. Multiple sliders can be synchronized by attaching to the same
adjustment object.

The methods \method{getValue}{gtkRange} and
\method{setValue}{gtkRange} can be used to get and set the value of
the widget. Values are clamped to the bounds defined by the
adjustment.

%% properties
A few properties define the appearance of the slider widget.  The
\code{digits} property controls the number of digits after the decimal
point.  The property \code{draw-value} toggles the drawing of the
selected value near the slider. Finally, \code{value-pos}
specifies where this value will be drawn using values from
\code{GtkPositionType}. The default is \code{top}.

%% value-changed
Callbacks can be assigned to the \code{value-changed} signal, which is
emitted when the slider is moved.

\begin{example}{A slider controlling histogram bin selection}{ex:RGtk2:sliders}
  A simple mechanism to make a graph interactive is to redraw the graph
  whenever a slider, controlling a plot parameter, is changed. The
  following shows how this can be achieved.
<<SliderAndHistogram, results=hide>>=
library(lattice)
x <- rnorm(100)                         # the data
drawHistogram <- function(val) print(histogram(x, nint = val))
#
w <- gtkWindow(); w$setTitle("Histogram bin selection")
#
slider <- gtkHScale(min = 1, max = 100, step = 1)
slider$setValue(10)                     # initial value
slider['value-pos'] <- "bottom"
w$add(slider)
#
gSignalConnect(slider, "value-changed",
               f = function(w, ...) {
                 val <- w$getValue()
                 drawHistogram(val)
               })
#
drawHistogram(slider$getValue())        # initial graphic
@               
\end{example}

\subsection{Spin buttons}
\label{sec:RGtk2:spinboxes}

The spin button widget is very similar to the slider widget,
conceptually and in terms of the \GTK\/ API. Spin buttons are
constructed with \constructor{gtkSpinButton}. As with sliders, this
constructor requires specifying adjustment values, either as a
\class{GtkAdjustment} or individually. 

As with sliders, the methods \method{getValue}{gtkSpinButton} and
\method{setValue}{gtkSpinButton} get and set the widgets
value. The property \code{snap-to-ticks} can be set to \code{TRUE} to
force the new value to belong to the sequence of values in the
adjustment. The \code{wrap} property indicates if the sequence will
``wrap'' around at the bounds.

The \code{value-changed} signal is emitted when the spin button is
changed, as with sliders.

\begin{example}{A range widget}{ex:RGtk2-range-widget}
  \SweaveInput{ex-RGtk2-range-widget}
\end{example}

\section{Graphics}

% Describe Cairo, GtkDrawingArea

\subsection{The cairoDevice package}
\label{sec:cairodevice-package}

The package \pkg{cairoDevice} is an R graphics device based on the
Cairo graphics library.  It is cross-platform and supports
alpha-blending and antialiasing. Through its support for the
\function{getGraphicsEvent} function, it is currently the most
interactive cross-platform graphics device.  

\pkg{RGtk2} and \pkg{cairoDevice} are integrated through the
\function{asCairoDevice} function.If a \class{GtkDrawingArea},
\class{GdkDrawable}, \class{Cairo} context, or \class{GtkPrintContext}
is passed to \function{asCairoDevice}, an R graphics device will be
initialized that targets its drawing to the
object. Example~\ref{ex:RGtk2:pixbuf} employed this function to paint
a histogram on a pixmap.  For simply displaying graphics in a GUI, the
\class{GtkDrawingArea} is the best choice.
For more complex use cases, such as compositing a layer above
or below the R graphic, one should pass an off-screen
\class{GdkDrawable}, like a \class{GdkPixmap}, or a \class{Cairo}
context. The off-screen drawing can then be composited with other
images when displayed. Finally, passing a \class{GtkPrintContext} to
\function{asCairoDevice} allows printing R graphics through the \GTK\/
printing dialogs.

% TODO: put GtkDrawingArea example here


%% JV: this is in need of rewriting
\section{Drag and drop}
\label{sec:RGtk2:dnd}

%% ------------ Drag and Drop

\GTK\/ has mechanisms to provide drag and drop facilities for
widgets. To setup drag and drop actions requires setting a widget to
be a source for a drag request, and setting a widget to be a target
for a drop action, and assigning callbacks to respond to certain
signals.  Only widgets which can receive signals will work for drag
and drop, so to drag or drop on a label, say, an event box must be
used. 

We illustrate how to set up the dragging of a text value from one
widget to another. Much more complicated examples are possible, but we
do not pursue it here.

When a drag and drop is initiated, different types of data may be
transferred. \GTK\/ allows the user to specify a target type. Below,
we define target types for text and pixmap objects. These
give numeric IDs for lookup purposes.
<<>>=
TARGET.TYPE.TEXT   <- 80                 
TARGET.TYPE.PIXMAP <- 81                  
@ 
We use these to make different types of objects that can be dragged.
<<>>=
widgetTargetTypes <- list(
## target -- string representing the drag type. MIME type used.
## flag delimiting drag scope. 0 -- no limit
## info -- application assigned value to identify
text = gtkTargetEntry("text/plain", 0, TARGET.TYPE.TEXT),
pixmap = gtkTargetEntry("image/x-pixmap", 0, TARGET.TYPE.PIXMAP)
)
@ 

\paragraph{A drag source}
A widget that can have a value dragged from it is a drag source. It is
specified by calling
\function{gtkDragSourceSet}. This function has arguments
\argument{object}{gtkDragSourceSet} for the widget we are making a
source, \argument{start.button.mask}{gtkDragSourceSet}  to specify
which mouse buttons can initiate the drag,
\argument{targets}{gtkDragSourceSet} to specify the target type, and
\argument{actions}{gtkDragSourceSet} to indicate which of the
\code{GdkDragAction} types is in effect, for instance \code{copy} or
\code{move}. 

When a widget is a drag source, it sends the data being dragged in
response to the \signal{drag-data-get} signal using a callback. The
signature of this callback is important, although we only use the
\code{selection} argument, as this is assigned the text that will be the
data passed to the target widget. (Text, as we are passing text
information.)

<<results=hide>>=
w <- gtkWindow(); w['title'] <- "Drag Source"
dragSourceWidget <-  gtkButton("Drag me")
w$add(dragSourceWidget)

gtkDragSourceSet(dragSourceWidget,
                 start.button.mask=c("button1-mask", "button3-mask"),
                 targets=widgetTargetTypes[["text"]],
                 actions="copy") ## can also be any of GdkDragAction

ID <- 
  gSignalConnect(dragSourceWidget, "drag-data-get", 
                 f=function(widget, context, 
                   selection, targetType, eventTime) {
                   ## customize this to set the text
                   selection$setText(str="some value") 
                 })
@ 

\paragraph{Drop target}
To make a widget a drop target, we call \function{gtkDragDestSet} on
the object with the argument \argument{flags}{gtkDragDestSet} for
specifying the actions \GTK\/ will perform when the widget is dropped
on. We use the value \qcode{all} for \qcode{motion},
\qcode{highlight}, and \qcode{drop}. The
\argument{targets}{gtkDragDestSet} argument matches the type of data
being allowed, in this case text. Finally, the value of
\argument{action}{gtkDragDestSet} specifies what \code{GdkDragAction}
should be sent back to the drop source widget. If the action was
\qcode{move} then the source widget emits the \code{drag-data-delete}
signal, so that a callback can be defined to handle the deletion of
the data.

 
<<results=hide>>=
w <- gtkWindow(); w['title'] <- "Drop Target"
dropTargetWidget <- gtkButton("Drop here")
w$add(dropTargetWidget)

gtkDragDestSet(dropTargetWidget,
               flags="all", 
               targets=widgetTargetTypes[["text"]],
               actions="copy"
               )
@

When data is dropped, the widget emits the
\code{drag-data-received}. The data is passed to the callback through the
\code{selection} argument. The \code{context} argument is a
\code{gdkDragContext}, containing information about the drag
event. The \code{x} and \code{y} arguments are integer valued and pass
in the position in the widget where the drop occurred. In the example
below, we see that text data is passed to this function in \code{raw}
format, so it is converted with \function{rawToChar}.

<<>>=
ID <- 
  gSignalConnect(dropTargetWidget, "drag-data-received", 
                 f=function(dropTargetWidget, 
                   context, x, y, 
                   selection, targetType, eventTime) {
                   dropdata <- selection$getText()
                   if(class(dropdata)[1] == "raw")
                     val <- paste(rawToChar(dropdata), sep="")
                   else
                     val <- paste(dropdata, sep="")
                   print(val) ## some action
                 })
@ 

%% JV: This could be expanded -- motion is not covered, as is done with
%% tcltk, but I don't think it is needed without a compelling use case.


