

\section{Buttons}
\label{sec:RGtk2:gtkButton}

The button is the very essence of a GUI. It communicates its purpose
to the user and executes a command in response to a simple click or
key press. In \GTK\/, A basic button is usually constructed using
\constructor{gtkButton}, as the following example demonstrates.

\begin{example}{Button constructors}{eg:RGtk2:button-constructors}
<<ButtonConstructors>>=
w <- gtkWindow(show=FALSE)
w$setTitle("Various buttons")
w$setDefaultSize(400, 25)
g <- gtkHBox(homogeneous=FALSE, spacing=5)
w$add(g)
b <- gtkButtonNew() 
b$setLabel("long way")
g$packStart(b)
g$packStart(gtkButton(label="label only") )
g$packStart(gtkButton(stock.id="gtk-ok") )
g$packStart(gtkButtonNewWithMnemonic("_Mnemonic") ) # Alt-m
w$show()
@ 
\end{example}

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{RGtk2-various-button}
  \caption{Various buttons}
  \label{fig:RGtk2:various-buttons}
\end{figure}

A \class{GtkButton} is simply a clickable region on the screen that is
decorated to appear as a button. \class{GtkButton} is a subclass of
\class{GtkBin}, so it will accept any widget as an indicator of its
purpose. By far the most common button decoration is a label. The
first argument of \constructor{gtkButton},
\argument{label}{gtkButton}, accepts the text for an automatically
created \class{GtkLabel}. We have seen this usage in our ``Hello
World'' example and others.

The alternative \argument{stock.id}{gtkButton} argument will use
decorations associated with the stock identifier. For example,
``gtk-ok'' would produce a button with a theme-dependent image (such
as a checkmark) and the ``Ok'' label, with the appropriate mnemonic
and translated into the current language.  The available stock
identifiers are listed by \function{gtkStockListIds}. See
\code{help(``stock-items'')} for more information.

The final button created in the example uses
\constructor{gtkButtonNewWithMnemonic} to create a button with a
mnemonic. Mnemonics are specified by prefixing the character with an
underscore.

The method \method{setRelief}{gtkButton} changes the relief style of
the button. For example, the relief can be disable so that the button
is drawn like a label.

%% signals
\paragraph{Signals}

The \signal{clicked} signal is emitted when the button is
clicked on with the mouse or when the button has focus and the
\kbd{enter} key is pressed. A callback can listen for this event to
perform a command when the button is clicked.  

\begin{example}{Callback example for
    \code{gtkButton}}{eg:RGtk2:gtkButton-callback}

<<CallbackExampleForButton>>=
w <- gtkWindow(); b <- gtkButton("click me");
w$add(b)

ID <- gSignalConnect(b,"button-press-event",   # just mouse
                     f = function(w,e,data) {
                       print(e$getButton())    # which button
                       return(FALSE)           # propagate
                     })
ID <- gSignalConnect(b,"clicked",              # keyboard too
                     f = function(w,...) {
                       print("clicked")
                     })
@ 
\end{example}

As buttons are intended to call an action immediately after being
clicked, it is customary to make them insensitive to user input when
the action is not possible. The \method{setSensitive}{gtkWidget}
method can adjust this for the button, as with other widgets.

%% Buttons initiate actions
Windows often have a default action. For example, if a window contains
a form, the default action often submits the form. If a button
executes the default action for the window, the button can be
set so that it is activated when the user presses \kbd{enter} while
the parent window has the focus. To implement this, the property
\code{can-default} must be \code{TRUE} and the widget method
\method{grabDefault}{gtkWidget} must be called. (This is not specific
to buttons, but any widget that can be activatable.) The
\class{GtkDialog} widget and its derivatives facilitate the use of
buttons in this manner, see Section~\ref{sec:dialogs}.

If the action that a button initiates is to be represented elsewhere
in the GUI, say a menu bar, then a \code{GtkAction} object may be
appropriate. Action objects are covered in
Section~\ref{sec:RGtk2:UIManager}.

\begin{example}{Spacing between buttons}{eg:RGtk2:mac-buttons}
  \SweaveInput{ex-RGtk2-mac-buttons.Rnw}
\end{example}

\section{Static Text and Images}

\subsection{Labels}
\label{sec:RGtk2:gtkLabel}

The primary purpose of a label is to communicate the role of another
widget, as we showed for the button. Labels are created by the
\constructor{gtkLabel} constructor, which takes the label text as its
first argument. This text can be set with either
\method{setLabel}{gtkLabel} or \method{setText}{gtkLabel} and
retrieved with either \method{getLabel}{gtkLabel} or
\method{getText}{gtkLabel}.  The difference being the former
respects formatting marks.

\begin{example}{Label formatting}{eg:RGtk2:label-formatting}
  As most text in a \GTK\/ GUI is ultimately displayed by
  \class{GtkLabel}, there are many formatting options available.  This
  example demonstrates a sample of
  these~(Figure~\ref{fig:RGtk2:label-formatting})
  
  \begin{figure}
    \centering
    \includegraphics[width=.5\textwidth]{fig-RGtk2-labels}
    \caption{Various formatting for a label: wrapping, alignment,
      ellipsizing, PANGO markup}
    \label{fig:RGtk2:label-formatting}
  \end{figure}
  
<<LabelFormatting, results=hide>>=
w <- gtkWindow(show=FALSE); w$setTitle("Label formatting")
w$setSizeRequest(250,300)               # narrow
g <- gtkVBox(spacing=2); g$setBorderWidth(5); w$add(g)
string <- "the quick brown fox jumped over the lazy dog"
## wrap by setting number of characters
basicLabel <- gtkLabel(string)
basicLabel$setLineWrap(TRUE)
basicLabel$setWidthChars(35)            # no. characters

## Set ellipsis to shorten long text
ellipsized <- gtkLabel(string)
ellipsized$setEllipsize("middle")

## Right justify text lines
## use xalign property for aligning entire block
rightJustified <- gtkLabel("right justify"); 
rightJustified$setJustify("right")
rightJustified['xalign'] <- 1

## PANGO markup
pangoLabel <- gtkLabel()
tmpl <- "<span foreground='blue' size='x-small'>%s</span>"
pangoLabel$setMarkup(sprintf(tmpl, string))
#
sapply(list(basicLabel, ellipsized, rightJustified, pangoLabel), 
       g$packStart, expand = TRUE, fill = TRUE)
w$showAll()
@ 
\end{example}

Many of the text formatting options are demonstrated in
Example~\ref{eg:RGtk2:label-formatting}. Line wrapping is enabled with
\method{setLineWrap}{gtkLabel}. Labels also support explicit line
breaks, specified with ``\code{\backslashn}.'' The
\method{setWidthChars}{gtkLabel} method is a convenience for instructing the
label to request enough space to show a specified number of
characters in a line.  When space is at a premium, long labels can be
ellipsized, i.e., have some of their text replaced with an
ellipsis, ``...''.  By default this is turned off; to enable, call
\method{setEllipsize}{gtkLabel}.  The property \code{justify}, with
values taken from \code{GtkJustification}, controls the alignment of
multiple lines within a label. To align the entire block of text
within the space allocated to the label, modify the \code{xalign}
property, as described in Section~\ref{sec:RGtk2:layout:align}.

\GTK\/ allows markup of text elements using the Pango text attribute
markup language, an XML-based format that resembles basic HTML. The
method \method{setMarkup}{gtkLabel} accepts text in the format. Text
is marked using tags to indicate the style. Some convenient tags are
\code{<b>} for bold, \code{<i>} for italics, \code{<ul>} for
underline, and \code{<tt>} for monospace text. Hyperlinks are possible
with \code{<a>}, as of version 2.18, and similar logic to
\function{browseURL} is implemented for launching a web
browser. Connect to the \signal{activate\_link} signal to
override. More complicated markup involves the \code{<span>} tag
markup, such as \code{<span color='red'>some text</span>}. As with
HTML, the text may need to be escaped first so that designated
entities replace reserved characters.

Although mostly meant for static text display, \class{GtkLabel} has
some interactive features. If the \code{selectable} property is set to
\code{TRUE}, the text can be selected and copied into the clipboard.
Labels can hold mnemonics for other widgets; this is useful for
navigating forms. The mnemonic is specified at construction time with
\code{gtkLabelNewWithMnemonic}. The
\method{setMnemonicWidget}{gtkLabel} method identifies the widget to
which the mnemonic refers.

\subsection{Images}
\label{sec:RGtk2:images}

It is often said that a picture can be worth a thousand
words. Applying this to GUIs, images can often provide a more space
efficient alternative to labels. \class{GtkImage} is the widget that
displays images. The constructor \constructor{gtkImage} supports
creating images from various in-memory image representations, files,
and other sources.  Images can be loaded after construction, as well. For example,
the \method{setFromFile}{gtkImage} method loads an image from a file.

The image widget, like the label widget, does not have a parent
\class{GdkWindow}, which means it does not receive window events. As
with the label widget, the image widget can be placed inside a
\constructor{gtkEventBox} container if one wishes to connect to such
events.


\begin{example}{Using a pixmap to present graphs}{ex:RGtk2:pixbuf}
  \SweaveInput{ex-RGtk2-ImageForGraphics}
\end{example}

<<notShown, echo=FALSE>>=
## Work this into an example ###
makeIconRGtk2 <- function(w, giffile) {
  if(checkPtrType(w, "GtkWindow")) {
    img <- gdkPixbufNewFromFile(giffile)
    if(!is.null(img$retval))
      w$setIcon(img$retval)
  }
}
@ 

\subsection{Stock icons}
\label{sec:RGtk2:stock-icons}

In \GTK\/, standard icons, like the one on the ``OK'' button, can be
customized by themes. This is implemented by a database that maps a
\textit{stock} identifier to an icon image. The stock identifier
corresponds to a commonly performed type of action, such as the ``OK''
response or the ``Save'' operation. There is no hard-coded set of
stock identifiers, however \GTK\/ provides a default set for the most
common operations. These identifiers are all prefixed with
``gtk-''. Users may register new types of stock icons.
%% ML: I believe there is an example of this in the RGtk2 demos

As mentioned previously, the full list of stock icons are returned in
a list by \function{gtkStockListIds}. The first $3$ are:
<<gtkStockListIds>>=
head(unlist(gtkStockListIds()), n=3)   
@ 

The use of stock identifiers over specific images is encouraged, as it
allows an application to be customized through themes. The
\constructor{gtkButton} and \constructor{gtkImage} constructors accept
a stock identifier passed as \code{stock.id} argument, and the icons in
toolbars and menus are most conveniently specified by stock
identifier. 

% ML: Sorry, but I am not sure if this illustrates an important concept


% In the example below, we use the method \method{renderIcon}{gtkWidget} to
% return a pixbuf containing the icon that can be used with the
% constructor \constructor{gtkImageNewFromPixbuf} to display the
% icon. Here the stock id and size are specified to the
% \method{renderIcon}{gtkWidget} method.

% \begin{example}{\constructor{gtkButtonNewFromStock} -- the hard way}{ex:RGtk2:stock-icon}
% \SweaveInput{ex-RGtk2-button-new-stock-hardway}
% \end{example}

% ML: Could this example be in the book, but marked as optional or advanced?
%% JV Only for the package?? This will be placed in the package as an example.
% \begin{example}{Adding to the stock icons}{ex:RGtk2:add-stock-icons}
%   \SweaveInput{ex-RGtk2-add-stock-icon}
% \end{example}



%% Alertpanel application 
%% JV replaced this with one using reference Classes 
%% JV: This shows event boxes and reference classes, not a bad
%% thing but otherwise is just an info bar which isnow added. Should
%% we comment out?
\begin{example}{An alert panel}{eg:RGtk2:alert-panel}
  \SweaveInput{ex-RGtk2-alert-panel-2}
\end{example}

\section{Input Controls}

\subsection{Text entry}
\label{sec:RGtk2:gtkEntry}

The widgets explained thus far are largely static. For example, \GTK\/
does not yet support editable labels. Text editing is handled by other
widgets that are rendered in the familiar depressed box form. We will
discuss complex multi-line text editing in
Section~\ref{sec:RGtk2:textviews}. For entering a single line of text,
the \class{GtkEntry} widget is appropriate.  It is constructed by
\function{gtkEntry}.  Specifying the \argument{max}{gtkEntry} argument
calls a deprecated function, instead use the method
\method{setMaxLength}{gtkEntry} after construction.

The \code{text} property stores the text. This can be set with the
method \method{setText}{gtkEntry} and retrieved with
\method{getText}{gtkEntry}. Editing text programmatically relies on
the \class{GtkEditable} interface, which \class{GtkEntry}
implements. The method \method{insertText}{GtkEditable} inserts text.
Its argument \argument{new.text}{gtkEditableInsertText} contains the
text and \argument{position}{gtkEditableInsertText} specifies the
position of the text to be added. The return value is a list with the
component \code{position} indicating the position \textit{after} the
new text. The \method{deleteText}{GtkEditable} method deletes
text. This takes two integers indicating the start and finish location
of the text to delete.

\begin{example}{Insert and Delete text}{eg:RGtk2:insert-delete-text}
The example will show how to add then delete text.  
<<InsertDeleteText>>=
e <- gtkEntry()
e$setText("Where did that guy go?")
add.pos <- regexpr("guy", e['text']) - 1 # before "guy"
ret <- e$insertText("@$#%! ", position = add.pos)
e$getText()                             # or e['text']
e$deleteText(start = add.pos, end= ret$position)
e$getText()
@ 
\end{example}

%% signals
The \class{GtkEditable} interface supports three signals:
\signal{changed} when text is changed, \signal{delete-text} for delete
events, and \signal{insert-text} for insert events. It is possible to
prevent the insertion or deletion of text by connecting to the
corresponding signal and stopping the signal propagation with
\function{gSignalStopEmission}. 

\class{GtkEntry} defines a number of its own signals, including the
\signal{activate} signal, which is emitted when the \kbd{enter} key is
pressed.

%% skipped
%% ML: I agree; kind of a hack
% \begin{example}{Editable label}{eg:RGtk2:editable-label}
%   \SweaveInput{ex-RGtk2-editable-label}
% \end{example}

%% TODO: add note about icons and progress in GtkEntry

\subsection{Check button}
\label{sec:RGtk2:gtkCheckbox}
%% TODO: example in this section

Very often, the action performed by a button simply changes the value
of a state variable in the application. \GTK\/ defines several types
of buttons that explicitly manage and display the value of a state
variable. The simplest type of state variable is binary (boolean) and is
usually proxied by a \class{GtkCheckButton}. 

A \class{GtkCheckButton} is constructed by
\function{gtkCheckButton}. The optional argument
\argument{label}{gtkCheckButton} places a label next to the
button. The alternative constructor
\constructor{gtkCheckButtonNewWithMnemonic} gives the label a mnemonic.

As with any \class{GtkButton}, the \code{label} property stores the
label.  The state of the binary variable is represented by the
\code{active} property. It can be set or retrieved with the methods
\method{setActive}{gtkToggleButton} and
\method{getActive}{gtkToggleButton}.

When the state is changed the \signal{toggle} signal is emitted. The
callback should check the \code{active} property to determine if the
button has been enabled or disabled.

An alternative to \class{GtkCheckButton} is the lesser used
\class{GtkToggleButton}, which is actually the parent class of
\class{GtkCheckButton}. A toggle button is drawn as an ordinary
button. It remains depressed while the state variable is \code{TRUE},
instead of relying on a check box to communicate the binary value.

\subsection{Radio button group}
\label{sec:RGtk2:gtkRadioButton}

\GTK\/ provides two button types for discrete state variables that
accept more than two possible values: combo boxes, discussed in the
next section, and radio buttons. The \function{gtkRadioButton}
constructor creates an instance of \class{GtkRadioButton}, an
extension of \class{GtkCheckButton}. Each radio button belongs to a
group.  There is no explicit group object; rather, the buttons are
chained together as a linked list. By default, a newly constructed
button is added to its own group. If \argument{group}{gtkRadioButton}
is a list of radio buttons, the newly created button is added to the
group. The constructor returns a single radio button widget.

%% active
Like other types derived from \class{GtkToggleButton}, each radio
button in the group has an \code{active} property.  Only one button in
the group can have \code{active} set to \code{TRUE} at a time. To
determine which button is active, each button needs to be queried
individually. Setting \code{active} to \code{TRUE} activates the
corresponding button and ensures that the other buttons are disabled.

\begin{example}{Radio group construction}{eg:RGtk2:radio-buttons}
Creating a new radio button group with the basic
\constructor{gtkRadioButton} constructor follows this pattern:
<<RadioGroupExample>>=
vals <- c("two.sided", "less", "greater")
radiogp <- list()                                 # list for group
radiogp[[vals[1]]] <- gtkRadioButton(label=vals[1]) # group = NULL
for(i in vals[-1]) 
  radiogp[[i]] <- gtkRadioButton(radiogp, label=i)  # group is a list
@ 
Each button needs to be managed. Here we illustrate a simple GUI doing so.
<<results=hide>>=
w <- gtkWindow(); w$setTitle("Radio group example")
g <- gtkVBox(FALSE, 5); w$add(g)
sapply(radiogp, gtkBoxPackStart, object = g)
@ 
We can set and query which button is active, as follows:
<<>>=
g[[3]]$setActive(TRUE)           
sapply(radiogp, `[`, "active") 
@ 
Here is how we might register a callback for the \code{toggled} signal.
<<results=hide>>=
sapply(radiogp, gSignalConnect, "toggled",     # connect each
       f = function(w, data) {
         if(w$getActive()) # set before callback
           cat("clicked", w$getLabel(),"\n")
       })
@ 
\end{example}

The \method{getGroup}{gtkRadioButton} method returns a list containing
the radio buttons in the same group. However, it is in the reverse
order of construction (newest first). This results from an internal
optimization that prepends, rather than appends, the buttons to a
linked list.
% ML: wow! they can't reverse the list?

As a convenience, there are constructor functions ending with
\code{FromWidget} that determine the group from a radio button
belonging to the group. As we will see in our second example, this
allows for a more natural \function{sapply} idiom that avoids the need
to allocate a list and populate it in a \code{for} loop.

\begin{example}{Radio group using \code{getGroup}}{eg:gtk:radio-group-get-group}
  In this example below, we illustrate two things: using the
  \constructor{gtkRadioButtonNewWithLabelFromWidget} function to add new
  buttons to the group and the \method{GetGroup}{gtkRadioButton}
  method to reference the buttons. The \function{rev} function is used
  to pack the widgets, to get them to display first to last.
<<results=hide>>=
radiogp <- gtkRadioButton(label=vals[1])
sapply(vals[-1], gtkRadioButtonNewWithLabelFromWidget, 
       group = radiogp)
w <- gtkWindow(); 
w['title'] <- "Radio group example"
g <- gtkVBox(); w$add(g)
sapply(rev(radiogp$getGroup()), gtkBoxPackStart, object = g)
@ 
\end{example}



\subsection{Combo boxes}
\label{sec:RGtk2:basic-combobox}

The combo box is a more space efficient alternative to radio buttons
and is better suited for when there are a large number of options. A
basic, text-only \class{GtkComboBox} is constructed by
\constructor{gtkComboBoxNewText}. Later we will discuss more
complicated combo boxes, where an underlying data model is
manipulated.
% Unlike
% others, as of writing, this widget must have its
% \method{Show}{gtkWidget} method called to be mapped.

For the basic combo box, items may be added in a few different ways.
The methods \method{appendText}{gtkComboBox} and
\method{prependText}{gtkComboBox} add a text item to the end or
beginning, respectively.  A text item is inserted at an arbitrary
position in the list with the \method{insertText}{gtkComboBox}.

The currently selected value is specified by index with the method
\method{setActive}{gtkComboBox} and returned by
\method{getActive}{gtkComboBox}. The index, as usual, is $0$-based,
and in this case, a value of $-1$ indicates that no value is selected.
The \method{getActiveText}{gtkComboBox} method can be used to retrieve
the text shown by the basic combo box.

Although combo boxes are much more space efficient than radio buttons,
it can be difficult to use a combo box when there are a large number
of selections. The \method{setWrapWidth}{gtkComboBox} method specifies
the preferred number of columns for displaying the items.


%% signal
The main signal to connect to is \signal{changed} which is emitted
when the active item is changed either by the user or the programmer
through the \method{setActive}{gtkComboBox} method.

%% JV: added this example in place of the more artificial one below.
\begin{example}{Using one combo box to populate another}{ex:RGtk2-comboboxes}
  \SweaveInput{ex-RGtk2-comboboxes}
\end{example}


% \begin{example}{Combo box}{eg:RGtk2:simple-combo-box}
% A simple combo box may be produced as follows:
% <<results=hide>>=
% vals <- c("two.sided", "less", "greater")
% cb <- gtkComboBoxNewText()
% sapply(vals, gtkComboBoxAppendText, object = cb)
% cb$setActive(0)                         # first one
% gSignalConnect(cb, "changed",
%                f = function(w, ...) {
%                  i <- w$getActive() + 1 # shift index
%                  if(i == 0) 
%                    cat("No value selected\n")
%                  else
%                    cat("Value is", w$getActiveText(), "\n")
%                })
% w <- gtkWindow(show=FALSE)
% w['title'] <- "Combobox example"
% w$add(cb)
% w$show()
% @  % ML: gtkComboBoxNewText() will gain a show=TRUE argument in next version
% \end{example}

\subsection{Sliders}
\label{sec:RGtk2:sliders}

The slider widget and spin button widget allow selection from a
regularly spaced, semi-continuous list of values.

The slider widget is called \class{GtkScale} and may be oriented
either horizontally or vertically. This depends on the constructor:
\constructor{gtkHScale} or \constructor{gtkVScale}.  The user must
specify the minimum, maximum and step values for the scale.  This set
of values is formally represented by the \class{GtkAdjustment}
structure. Ordinarily, it is not necessary to construct a
\class{GtkAdjustment} explicitly. Instead, the constructors accept the
the numeric arguments \argument{min}{gtkHScale}, \argument{max}{gtkHScale},
and \argument{step}{gtkHScale}.

The underlying \class{GtkAdjustment} serves as the data model for the
slider. Multiple sliders can be synchronized by attaching to the same
adjustment object.

The methods \method{getValue}{gtkRange} and
\method{setValue}{gtkRange} can be used to get and set the value of
the widget. Values are clamped to the bounds defined by the
adjustment.

%% properties
A few properties define the appearance of the slider widget.  The
\code{digits} property controls the number of digits after the decimal
point.  The property \code{draw-value} toggles the drawing of the
selected value near the slider. Finally, \code{value-pos}
specifies where this value will be drawn using values from
\code{GtkPositionType}. The default is \code{top}.

%% value-changed
Callbacks can be assigned to the \code{value-changed} signal, which is
emitted when the slider is moved.

\begin{example}{A slider controlling histogram bin selection}{ex:RGtk2:sliders}
  A simple mechanism to make a graph interactive is to redraw the graph
  whenever a slider, controlling a plot parameter, is changed. The
  following shows how this can be achieved.
<<SliderAndHistogram, results=hide>>=
library(lattice)
x <- rnorm(100)                         # the data
drawHistogram <- function(val) print(histogram(x, nint = val))
#
w <- gtkWindow(); w$setTitle("Histogram bin selection")
#
slider <- gtkHScale(min = 1, max = 100, step = 1)
slider$setValue(10)                     # initial value
slider['value-pos'] <- "bottom"
w$add(slider)
#
gSignalConnect(slider, "value-changed",
               f = function(w, ...) {
                 val <- w$getValue()
                 drawHistogram(val)
               })
#
drawHistogram(slider$getValue())        # initial graphic
@               
\end{example}

\subsection{Spin buttons}
\label{sec:RGtk2:spinboxes}

The spin button widget is very similar to the slider widget,
conceptually and in terms of the \GTK\/ API. Spin buttons are
constructed with \constructor{gtkSpinButton}. As with sliders, this
constructor requires specifying adjustment values, either as a
\class{GtkAdjustment} or individually. 

As with sliders, the methods \method{getValue}{gtkSpinButton} and
\method{setValue}{gtkSpinButton} get and set the widgets
value. The property \code{snap-to-ticks} can be set to \code{TRUE} to
force the new value to belong to the sequence of values in the
adjustment. The \code{wrap} property indicates if the sequence will
``wrap'' around at the bounds.

The \code{value-changed} signal is emitted when the spin button is
changed, as with sliders.

\begin{example}{A range widget}{ex:RGtk2-range-widget}
  \SweaveInput{ex-RGtk2-range-widget}
\end{example}

\section{Progress Reporting}

\subsection{Progress bars}
\label{sec:progress-bars}

It is common to use a progress bar to indicate to the user the
progress of a long running computation. The
\constructor{gtkProgressBar} creates the widget. Typically, a text
label describes the current operation, and the progress bar
communicates the fraction completed:
<<>>=
w <- gtkWindow(); w$setTitle("Progress bar example")
pb <- gtkProgressBar()
w$add(pb)
#
pb$setText("Please be patient...")
for(i in 1:100) {
  pb$setFraction(i/100)
  Sys.sleep(0.05) ## replace with a step in the process
}
pb$setText("All done.")
@ 

Progress bars can also show indefinite activity by periodically
pulsing the bar: 
<<gtk-widget-progress-pulse>>=
pb$pulse()
@ 

\subsection{Spinners}

Related to a progress bar is the \class{GtkSpinner} widget, which is a
graphical heartbeat to assure the user that the application is still
alive during long-running operations. Spinners are commonly found in
web browsers. The basic usage is straightforward:
<<gtk-widget-spinner, eval=FALSE>>=
spinner <- gtkSpinner()
spinner$start()
spinner$stop()
@ 

%% JV: this is in need of rewriting
\section{Drag and drop}
\label{sec:RGtk2:dnd}

%% ------------ Drag and Drop

A drag and drop operation is the movement of data from a source widget
to a target widget. The source widget serializes the selected item as
MIME data, and the destination interprets that data to perform some
operation, often creating an item of its own. Our task is to configure
the source and destination widgets, so that they listen for the
appropriate events and understand each other. As a trivial example, we
allow the user to drag the text from one button to another.

\subsection{Initiating a Drag}

When a drag and drop is initiated, different types of data may be
transferred. We need to define a target type for each type of data, as
a \class{GtkTargetEntry} structure. 
<<>>=
TARGET.TYPE.TEXT   <- 80                 
TARGET.TYPE.PIXMAP <- 81                  
widgetTargetTypes <- 
  list(text = gtkTargetEntry("text/plain", 0, 
         TARGET.TYPE.TEXT),
       pixmap = gtkTargetEntry("image/x-pixmap", 0, 
         TARGET.TYPE.PIXMAP))
@ 
%
The first component of \class{GtkTargetEntry} is the name, which often
a MIME type. The flags come next, which are usually left at $0$, and
finally we specify an arbitrary identifier for the target. We will
only use the \qcode{text} target in this example.

To instruct a widget to act as a drag source, we call
\function{gtkDragSourceSet}:
<<results=hide>>=
w <- gtkWindow(); w['title'] <- "Drag Source"
dragSourceWidget <-  gtkButton("Text to drag")
w$add(dragSourceWidget)

gtkDragSourceSet(dragSourceWidget,
       start.button.mask=c("button1-mask", "button3-mask"),
       targets=widgetTargetTypes[["text"]],
       actions="copy")
@ 
%
The \argument{start.button.mask}{gtkDragSourceSet} indicates the
modifier buttons that need to be pressed to initiate the drag, with
values from \class{GdkModifierType}. Then we specify the allowed
targets, \qcode{text} in this case. The
\argument{actions}{gtkDragSourceSet} argument lists the supported
actions, such as \code{copy} or \code{move}, from the
\class{GdkDragAction} enumeration. 

When a drag is initiated, we will receive the \signal{drag-data-get}
signal, which needs to place some data into the passed
\class{GtkSelectionData} object:
<<results=hide>>=
gSignalConnect(dragSourceWidget, "drag-data-get", 
               function(widget, context, selection, targetType, eventTime) {
                 selection$setText(widget$getLabel()) 
               })
@ 
%
If we had specified the \code{move}, we would also need to connect to
\signal{drag-data-delete}, in order to delete the data that was
moved away.

\subsection{Handling Drops}

To make a widget a drop target, we call \function{gtkDragDestSet} on
the object:
<<results=hide>>=
w <- gtkWindow(); w['title'] <- "Drop Target"
dropTargetWidget <- gtkButton("Drop here")
w$add(dropTargetWidget)

gtkDragDestSet(dropTargetWidget,
               flags="all", 
               targets=widgetTargetTypes[["text"]],
               actions="copy")
@
%
The signature is similar to that of \function{gtkDragSourceSet},
except for the \argument{flags}{gtkDragDestSet} argument, which
indicates which operations, of the set \code{motion}, \code{highlight}
and \code{drop}, \GTK\/ will handle with reasonable default
behavior. Specifying \code{all} is the most convenient course, in
which case we only need to implement the extraction of the data from
the \class{GtkSelectionData} object. For a drop to occur, there must be a
non-empty intersection between the targets passed to
\function{gtkDragSourceSet} and those passed to
\function{gtkDragDestSet}.

When data is dropped, the destination widget emits the
\code{drag-data-received} signal. The handler is responsible for
extracting the dragged data from \code{selection} and performing some
operation with it. In this case, we set the text on the button:
<<>>=
gSignalConnect(dropTargetWidget, "drag-data-received", 
               function(dropTargetWidget, context, x, y, selection, targetType,
                        eventTime) 
               {
                 dropdata <- selection$getText()
                 dropTargetWidget$setLabel(rawToChar(dropdata))
               })
@ 
%
The \code{context} argument is a \code{gdkDragContext}, containing
information about the drag event. The \code{x} and \code{y} arguments
are integer valued and represent the position in the widget where the
drop occurred. The text data is returned by \function{getText} as a
\code{raw} vector, so it is converted with \function{rawToChar}.

%% JV: This could be expanded -- motion is not covered, as is done with
%% tcltk, but I don't think it is needed without a compelling use case.
