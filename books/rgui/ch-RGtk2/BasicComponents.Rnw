

\section{Buttons}
\label{sec:RGtk2:gtkButton}

The button is the very essence of a GUI. It communicates its purpose
to the user and executes a command in response to a simple click or
key press. In \GTK\/, A basic button is usually constructed using
\constructor{gtkButton}, as the following example demonstrates.

\begin{example}{Button constructors}{eg:RGtk2:button-constructors}
<<ButtonConstructors>>=
w <- gtkWindow(show=FALSE)
w$setTitle("Various buttons")
w$setDefaultSize(400, 25)
g <- gtkHBox(homogeneous=FALSE, spacing=5)
w$add(g)
b <- gtkButtonNew() 
b$setLabel("long way")
g$packStart(b)
g$packStart(gtkButton(label="label only") )
g$packStart(gtkButton(stock.id="gtk-ok") )
g$packStart(gtkButtonNewWithMnemonic("_Mnemonic") ) # Alt-m
w$show()
@ 
\end{example}

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{RGtk2-various-button}
  \caption{Various buttons}
  \label{fig:RGtk2:various-buttons}
\end{figure}

A \class{GtkButton} is simply a clickable region on the screen that is
decorated to appear as a button. \class{GtkButton} is a subclass of
\class{GtkBin}, so it will accept any widget as an indicator of its
purpose. By far the most common button decoration is a label. The
first argument of \constructor{gtkButton},
\argument{label}{gtkButton}, accepts the text for an automatically
created \class{GtkLabel}. We have seen this usage in our ``Hello
World'' example and others.

The alternative \argument{stock.id}{gtkButton} argument will use
decorations associated with the stock identifier. For example,
``gtk-ok'' would produce a button with a theme-dependent image (such
as a checkmark) and the ``Ok'' label, with the appropriate mnemonic
and translated into the current language.  The available stock
identifiers are listed by \function{gtkStockListIds}. See
\code{help(``stock-items'')} for more information.

The final button created in the example uses
\constructor{gtkButtonNewWithMnemonic} to create a button with a
mnemonic. Mnemonics are specified by prefixing the character with an
underscore.

The method \method{setRelief}{gtkButton} changes the relief style of
the button. For example, the relief can be disable so that the button
is drawn like a label.

%% signals
\paragraph{Signals}

The \signal{clicked} signal is emitted when the button is
clicked on with the mouse or when the button has focus and the
\kbd{enter} key is pressed. A callback can listen for this event to
perform a command when the button is clicked.  

\begin{example}{Callback example for
    \code{gtkButton}}{eg:RGtk2:gtkButton-callback}

<<CallbackExampleForButton>>=
w <- gtkWindow(); b <- gtkButton("click me");
w$add(b)

ID <- gSignalConnect(b,"button-press-event",   # just mouse
                     f = function(w,e,data) {
                       print(e$getButton())    # which button
                       return(FALSE)           # propagate
                     })
ID <- gSignalConnect(b,"clicked",              # keyboard too
                     f = function(w,...) {
                       print("clicked")
                     })
@ 
\end{example}

As buttons are intended to call an action immediately after being
clicked, it is customary to make them insensitive to user input when
the action is not possible. The \method{setSensitive}{gtkWidget}
method can adjust this for the button, as with other widgets.

%% Buttons initiate actions
Windows often have a default action. For example, if a window contains
a form, the default action often submits the form. If a button
executes the default action for the window, the button can be
set so that it is activated when the user presses \kbd{enter} while
the parent window has the focus. To implement this, the property
\code{can-default} must be \code{TRUE} and the widget method
\method{grabDefault}{gtkWidget} must be called. (This is not specific
to buttons, but any widget that can be activatable.) The
\class{GtkDialog} widget and its derivatives facilitate the use of
buttons in this manner, see Section~\ref{sec:dialogs}.

If the action that a button initiates is to be represented elsewhere
in the GUI, say a menu bar, then a \code{GtkAction} object may be
appropriate. Action objects are covered in
Section~\ref{sec:RGtk2:UIManager}.

\begin{example}{Spacing between buttons}{eg:RGtk2:mac-buttons}
  \SweaveInput{ex-RGtk2-mac-buttons.Rnw}
\end{example}

\section{Static Text and Images}

\subsection{Labels}
\label{sec:RGtk2:gtkLabel}

The primary purpose of a label is to communicate the role of another
widget, as we showed for the button. Labels are created by the
\constructor{gtkLabel} constructor, which takes the label text as its
first argument. This text can be set with either
\method{setLabel}{gtkLabel} or \method{setText}{gtkLabel} and
retrieved with either \method{getLabel}{gtkLabel} or
\method{getText}{gtkLabel}.  The difference being the former
respects formatting marks.

\begin{example}{Label formatting}{eg:RGtk2:label-formatting}
  As most text in a \GTK\/ GUI is ultimately displayed by
  \class{GtkLabel}, there are many formatting options available.  This
  example demonstrates a sample of
  these~(Figure~\ref{fig:RGtk2:label-formatting})
  
  \begin{figure}
    \centering
    \includegraphics[width=.5\textwidth]{fig-RGtk2-labels}
    \caption{Various formatting for a label: wrapping, alignment,
      ellipsizing, PANGO markup}
    \label{fig:RGtk2:label-formatting}
  \end{figure}
  
<<LabelFormatting, results=hide>>=
w <- gtkWindow(show=FALSE); w$setTitle("Label formatting")
w$setSizeRequest(250,300)               # narrow
g <- gtkVBox(spacing=2); g$setBorderWidth(5); w$add(g)
string <- "the quick brown fox jumped over the lazy dog"
## wrap by setting number of characters
basicLabel <- gtkLabel(string)
basicLabel$setLineWrap(TRUE)
basicLabel$setWidthChars(35)            # no. characters

## Set ellipsis to shorten long text
ellipsized <- gtkLabel(string)
ellipsized$setEllipsize("middle")

## Right justify text lines
## use xalign property for aligning entire block
rightJustified <- gtkLabel("right justify"); 
rightJustified$setJustify("right")
rightJustified['xalign'] <- 1

## PANGO markup
pangoLabel <- gtkLabel()
tmpl <- "<span foreground='blue' size='x-small'>%s</span>"
pangoLabel$setMarkup(sprintf(tmpl, string))
#
sapply(list(basicLabel, ellipsized, rightJustified, pangoLabel), 
       g$packStart, expand = TRUE, fill = TRUE)
w$showAll()
@ 
\end{example}

Many of the text formatting options are demonstrated in
Example~\ref{eg:RGtk2:label-formatting}. Line wrapping is enabled with
\method{setLineWrap}{gtkLabel}. Labels also support explicit line
breaks, specified with ``\code{\backslashn}.'' The
\method{setWidthChars}{gtkLabel} method is a convenience for instructing the
label to request enough space to show a specified number of
characters in a line.  When space is at a premium, long labels can be
ellipsized, i.e., have some of their text replaced with an
ellipsis, ``...''.  By default this is turned off; to enable, call
\method{setEllipsize}{gtkLabel}.  The property \code{justify}, with
values taken from \code{GtkJustification}, controls the alignment of
multiple lines within a label. To align the entire block of text
within the space allocated to the label, modify the \code{xalign}
property, as described in Section~\ref{sec:RGtk2:layout:align}.

\GTK\/ allows markup of text elements using the Pango text attribute
markup language, an XML-based format that resembles basic HTML. The
method \method{setMarkup}{gtkLabel} accepts text in the format. Text
is marked using tags to indicate the style. Some convenient tags are
\code{<b>} for bold, \code{<i>} for italics, \code{<ul>} for
underline, and \code{<tt>} for monospace text. Hyperlinks are possible
with \code{<a>}, as of version 2.18, and similar logic to
\function{browseURL} is implemented for launching a web
browser. Connect to the \signal{activate\_link} signal to
override. More complicated markup involves the \code{<span>} tag
markup, such as \code{<span color='red'>some text</span>}. As with
HTML, the text may need to be escaped first so that designated
entities replace reserved characters.

Although mostly meant for static text display, \class{GtkLabel} has
some interactive features. If the \code{selectable} property is set to
\code{TRUE}, the text can be selected and copied into the clipboard.
Labels can hold mnemonics for other widgets; this is useful for
navigating forms. The mnemonic is specified at construction time with
\code{gtkLabelNewWithMnemonic}. The
\method{setMnemonicWidget}{gtkLabel} method identifies the widget to
which the mnemonic refers.

For efficiency reasons \class{GtkLabel} does not receive any input
events. It lacks an underlying \class{GdkWindow}, meaning that there
are no window system resources allocated for receiving the
events. Thus, to make a label interactive, one must first embed it
within a \class{GtkEventBox}, which provides the \class{GdkWindow}.

\subsection{Images}
\label{sec:RGtk2:images}

It is often said that a picture can be worth a thousand
words. Applying this to GUIs, images can often provide a more space
efficient alternative to labels. \class{GtkImage} is the widget that
displays images. The constructor \constructor{gtkImage} creates images from various in-memory image representations, files,
and other sources.  Images can be loaded after construction, as well. For example,
the \method{setFromFile}{gtkImage} method loads an image from a file.

The image widget, like the label widget, does not have a parent
\class{GdkWindow}, which means it does not receive window events. As
with the label widget, the image widget can be placed inside a
\constructor{gtkEventBox} container if one wishes to connect to such
events.


\begin{example}{Using a pixmap to present graphs}{ex:RGtk2:pixbuf}
  \SweaveInput{ex-RGtk2-ImageForGraphics}
\end{example}

<<notShown, echo=FALSE>>=
## Work this into an example ###
makeIconRGtk2 <- function(w, giffile) {
  if(checkPtrType(w, "GtkWindow")) {
    img <- gdkPixbufNewFromFile(giffile)
    if(!is.null(img$retval))
      w$setIcon(img$retval)
  }
}
@ 

\subsection{Stock icons}
\label{sec:RGtk2:stock-icons}

In \GTK\/, standard icons, like the one on the ``OK'' button, can be
customized by themes. This is implemented by a database that maps a
\textit{stock} identifier to an icon image. The stock identifier
corresponds to a commonly performed type of action, such as the ``OK''
response or the ``Save'' operation. There is no hard-coded set of
stock identifiers, however \GTK\/ provides a default set for the most
common operations. These identifiers are all prefixed with
``gtk-''. Users may register new types of stock icons.
%% ML: I believe there is an example of this in the RGtk2 demos

As mentioned previously, the full list of stock icons are returned in
a list by \function{gtkStockListIds}. The first $3$ are:
<<gtkStockListIds>>=
head(unlist(gtkStockListIds()), n=3)   
@ 

The use of stock identifiers over specific images is encouraged, as it
allows an application to be customized through themes. The
\constructor{gtkButton} and \constructor{gtkImage} constructors accept
a stock identifier passed as \code{stock.id} argument, and the icons in
toolbars and menus are most conveniently specified by stock
identifier. 

% ML: Sorry, but I am not sure if this illustrates an important concept


% In the example below, we use the method \method{renderIcon}{gtkWidget} to
% return a pixbuf containing the icon that can be used with the
% constructor \constructor{gtkImageNewFromPixbuf} to display the
% icon. Here the stock id and size are specified to the
% \method{renderIcon}{gtkWidget} method.

% \begin{example}{\constructor{gtkButtonNewFromStock} -- the hard way}{ex:RGtk2:stock-icon}
% \SweaveInput{ex-RGtk2-button-new-stock-hardway}
% \end{example}

% ML: Could this example be in the book, but marked as optional or advanced?
%% JV Only for the package?? This will be placed in the package as an example.
% \begin{example}{Adding to the stock icons}{ex:RGtk2:add-stock-icons}
%   \SweaveInput{ex-RGtk2-add-stock-icon}
% \end{example}



%% Alertpanel application 
%% JV replaced this with one using reference Classes 
%% JV: This shows event boxes and reference classes, not a bad
%% thing but otherwise is just an info bar which isnow added. Should
%% we comment out?
%% ML: this is a fairly complicated example for a concept that is not
%% so important (GtkEventBox). I don't see how it's useful for
%% show/hide, which are pretty obvious.
\begin{example}{An alert panel}{eg:RGtk2:alert-panel}
  \SweaveInput{ex-RGtk2-alert-panel-2}
\end{example}

\section{Input Controls}

\subsection{Text entry}
\label{sec:RGtk2:gtkEntry}

The widgets explained thus far are largely static. For example, \GTK\/
does not yet support editable labels. \GTK\/ has two different widgets
for editing text. One is optimized for multi-line text documents, the
other for single line entry. We will discuss complex multi-line text
editing in Section~\ref{sec:RGtk2:textviews}. For entering a single
line of text, the \class{GtkEntry} widget is appropriate.

\begin{example}{Insert and Delete text}{eg:RGtk2:insert-delete-text}
  The example will show how to add then delete text.  
<<InsertDeleteText>>=
e <- gtkEntry()
e$setText("Where did that guy go?")
add.pos <- regexpr("guy", e['text']) - 1 # before "guy"
ret <- e$insertText("@$#%! ", position = add.pos)
e$getText()                             # or e['text']
e$deleteText(start = add.pos, end= ret$position)
e$getText()
@
%

\end{example}

The \code{text} property stores the text. This can be set with the
method \method{setText}{gtkEntry} and retrieved with
\method{getText}{gtkEntry}.

When the user has committed an entry, e.g. by pressing the \kbd{enter}
key, the \signal{activate} signal is emitted:
<<gtk-widget-entry-activate>>=
gSignalConnect(e, "activate", function() {
  message("Text entered: ", e$getText())
})
@ 

Sometimes the length of the text needs to be constrained to some
number of characters. The \argument{max}{gtkEntry} argument to
\function{gtkEntry} specifies this, but that usage is
deprecated. Instead, one should call \method{setMaxLength}{GtkEntry}.

\paragraph{The \class{GtkEditable} Interface}

Editing text programmatically relies on the \class{GtkEditable}
interface, which \class{GtkEntry} implements. The method
\method{insertText}{GtkEditable} inserts text before a position
specified by a $0$-based index. The return value is a list with the
component \code{position} indicating the position \textit{after} the
new text. The \method{deleteText}{GtkEditable} method deletes text
between two positions.

The \class{GtkEditable} interface supports three signals:
\signal{changed} when text is changed, \signal{delete-text} for delete
events, and \signal{insert-text} for insert events. It is possible to
prevent the insertion or deletion of text by connecting to the
corresponding signal and stopping the signal propagation with
\function{gSignalStopEmission}. 

\paragraph{Advanced \class{GtkEntry} Features}

\class{GtkEntry} has a number of features beyond basic text entry,
including: completion, buffer sharing, icons, and progress
reporting. We discuss completion in
Section~\ref{sec:RGtk2:entry-completion} and shared buffers in
Section~\ref{sec:RGtk2:buffer-sharing}. The progress reporting API,
introduced with version $2.16$, is virtually identical to that of
\class{GtkProgressBar}, introduced in
Section~\ref{sec:progress-bars}. We treat icons here. This feature has
been present since version $2.16$.

One can set an icon on an entry from a \class{GdkPixbuf}, stock ID,
icon name, or \class{GIcon}. Two icons are possible, one at the
beginning (\code{primary}) and one at the end (\code{secondary}). For
example, an entry might listen to its input and update its icon to
indicate whether the entered text is valid (in this case, consisting
only of letters):
<<gtk-widget-entry-validate>>=
validatedEntry <- gtkEntry()
gSignalConnect(validatedEntry, "changed", function(entry) {
  text <- entry$getText()
  if (nzchar(gsub("[a-zA-Z]", "", text))) {
    entry$setIconFromStock("primary", "gtk-no")
    validatedEntry$setIconTooltipText("primary", "Only letters are allowed")
  }
  else { 
    entry$setIconFromStock("primary", "gtk-yes")
    validatedEntry$setIconTooltipText("primary", NULL)
  }
})
validatedEntry$setIconFromStock("primary", "gtk-yes")
@
<<echo=FALSE>>=
w <- gtkWindow(show=FALSE)
w$add(validatedEntry)
w$showAll()
@ 
%
We add a tooltip on the error icon to indicate the nature of the
problem to the user. Icons can also be made clickable and used as a
source for drag and drop operations.

\subsection{Check button}
\label{sec:RGtk2:gtkCheckbox}

Very often, the action performed by a button simply changes the value
of a state variable in the application. \GTK\/ defines several types
of buttons that explicitly manage and display one aspect of the
application state. The simplest type of state variable is binary
(boolean/logical) and is usually proxied by a \class{GtkCheckButton}.

A \class{GtkCheckButton} is constructed by
\function{gtkCheckButton}:
<<gtk-widget-check-button, results=hide>>=
cb <- gtkCheckButton("Option")
@
%
The state of the binary variable is represented by the
\code{active} property. We check our button:
<<gtk-widget-check-button-active>>=
cb['active']
cb['active'] <- TRUE
@ 

When the state is changed the \signal{toggle} signal is emitted. The
callback should check the \code{active} property to determine if the
button has been enabled or disabled:
<<gtk-widget-check-button-toggle,results=hide>>=
gSignalConnect(cb, "toggle", function(x) {
  message("Button is ", if (x$active) "active" else "inactive")
})
@ 

An alternative to \class{GtkCheckButton} is the lesser used
\class{GtkToggleButton}, which is actually the parent class of
\class{GtkCheckButton}. A toggle button is drawn as an ordinary
button. It remains depressed while the state variable is \code{TRUE},
instead of relying on a check box to communicate the binary value.

\subsection{Radio button groups}
\label{sec:RGtk2:gtkRadioButton}

\GTK\/ provides two widgets for discrete state variables that accept
more than two possible values: combo boxes, discussed in the next
section, and radio buttons. The \function{gtkRadioButton} constructor
creates an instance of \class{GtkRadioButton}, an extension of
\class{GtkCheckButton}. Each radio button belongs to a group and only
one button in a group may be active at once.

\begin{example}{Basic Radio Button Usage}{eg:gtk:radio-group-group-list} 
  When we construct a radio button, we need to add it to a
  group. There is no explicit group object; rather, the buttons are
  chained together as a linked list. By default, a newly constructed
  button is added to its own group. If the group list is passed to the
  constructor, the newly created button is added to the group:
<<RadioGroupExample>>=
labels <- c("two.sided", "less", "greater")
radiogp <- list()                                 # list for group
radiogp[[vals[1]]] <- gtkRadioButton(label=labels[1]) # group = NULL
for(label in labels[-1]) 
  radiogp[[i]] <- gtkRadioButton(radiogp, label=label)  # group is a list
@ 
%
As a convenience, there are constructor functions ending with
\code{FromWidget} that determine the group from a radio button
belonging to the group. As we will see in our second example, this
allows for a more natural \function{sapply} idiom that avoids the need
to allocate a list and populate it in a \code{for} loop.

We add each button to a vertical box:
<<results=hide>>=
w <- gtkWindow(); w$setTitle("Radio group example")
g <- gtkVBox(FALSE, 5); w$add(g)
sapply(radiogp, gtkBoxPackStart, object = g)
@ 

We can set and query which button is active:
<<>>=
g[[3]]$setActive(TRUE)           
sapply(radiogp, `[`, "active") 
@ 

The \code{toggle} signal is emitted when a button is toggled. We need
to connect a handler to each button:
<<results=hide>>=
sapply(radiogp, gSignalConnect, "toggled",     # connect each
       f = function(w, data) {
         if(w['active']) # set before callback
           message("clicked", w$getLabel(),"\n")
       })
@ 
\end{example}

\begin{example}{Radio Group via a \function{FromWidget}
    Constructor}{eg:gtk:radio-group-get-group}
  In this example below, we illustrate two things: using the
  \constructor{gtkRadioButtonNewWithLabelFromWidget} function to add new
  buttons to the group:
<<results=hide>>=
radiogp <- gtkRadioButton(label=vals[1])
sapply(vals[-1], gtkRadioButtonNewWithLabelFromWidget, 
       group = radiogp)
w <- gtkWindow()
w['title'] <- "Radio group example"
g <- gtkVBox(); w$add(g)
sapply(rev(radiogp$getGroup()), gtkBoxPackStart, object = g)
@ 
%
The \method{getGroup}{gtkRadioButton} method returns a list containing
the radio buttons in the same group. However, it is in the reverse
order of construction (newest first). This results from an internal
optimization that prepends, rather than appends, the buttons to a
linked list. Thus, we need to call \function{rev} to reverse the list
before packing the widgets into the box.

\end{example}


%% TODO: I think GtkComboBoxEntry got lost??

\subsection{Combo boxes}
\label{sec:RGtk2:basic-combobox}

The combo box is a more space efficient alternative to radio buttons
and is better suited for when there are a large number of options. A
basic, text-only \class{GtkComboBox} is constructed by
\constructor{gtkComboBoxNewText}. Later we will discuss more
complicated combo boxes, that are based on an external data model.

We construct and populate a simple combo box:
<<gtk-widget-combo>>=
combo <- gtkComboBoxNewText()
sapply(c("two.sided", "less", "greater"), combo$appendText)
@ 
%

The index of the currently active item is stored in the
\property{active} property. The index, as usual, is $0$-based,
and in this case, a value of $-1$ indicates that no value is selected.
The \method{getActiveText}{gtkComboBox} method retrieves
the text shown by the basic combo box.

When the active index changes, the \signal{changed} signal is
emitted. The handler then needs to retrieve the active index:
<<gtk-widget-combo-changed>>=
gSignalConnect(combo, "changed",
               f = function(w, ...) {
                 i <- w$getActive() + 1 # shift index
                 if(i == 0) 
                   cat("No value selected\n")
                 else
                   cat("Value is", w$getActiveText(), "\n")
               })
@

Although combo boxes are much more space efficient than radio buttons,
it can be difficult to use a combo box when there are a large number
of items. The \method{setWrapWidth}{gtkComboBox} method specifies
the preferred number of columns for displaying the items.

\begin{example}{Using one combo box to populate another}{ex:RGtk2-comboboxes}
  \SweaveInput{ex-RGtk2-comboboxes}
\end{example}

\subsection{Sliders}
\label{sec:RGtk2:sliders}

The slider widget and spin button widget allow selection from a
regularly spaced, semi-continuous list of values.
\class{GtkScale} implements a slider and may be oriented
either horizontally or vertically. This depends on the class:
\class{GtkHScale} or \class{GtkVScale}.  

\begin{example}{A slider controlling histogram bin selection}{ex:RGtk2:sliders}
  We demonstrate a slider for controlling the bin size of a
  histogram. First, we create and configure the horizontal slider:
<<gtk-widget-slider>>=
slider <- gtkHScale(min = 1, max = 100, step = 1)
slider$setValue(10)
slider['value-pos'] <- "bottom"
@ 
%
We specify the minimum, maximum and step values for the scale.  This
set of values is formally represented by the \class{GtkAdjustment}
structure, which could serve as a data model for synchronizing multiple
sliders or other scale-based widgets. Ordinarily, it is not necessary
to construct a \class{GtkAdjustment} explicitly. Instead, one passes
the values as parameters to the constructor. The initial value is set
to $10$, and the value will be rendered in a label beneath the slider,
according to the \property{value-pos} property.

The \signal{value-changed} signal is emitted whenever the slider is
adjusted. Our handler updates the histogram:
<<gtk-widget-slider-value-changed>>=
gSignalConnect(slider, "value-changed",
               f = function(w, ...) {
                 val <- w$getValue()
                 drawHistogram(val)
               })
@ 

Finally, we load the data, define the \function{drawHistogram}
function, and finish the GUI:
<<SliderAndHistogram, results=hide>>=
data <- rnorm(100)

library(lattice)
drawHistogram <- function(val) print(histogram(data, nint = val))
drawHistogram(slider$getValue())        

w <- gtkWindow(); w$setTitle("Histogram bin selection")
w$add(slider)
@               
\end{example}

%% properties
A few properties define the appearance of the slider widget.  The
\code{digits} property controls the number of digits after the decimal
point.  The property \code{draw-value} toggles the drawing of the
selected value near the slider. Finally, \code{value-pos}
specifies where this value will be drawn using values from
\code{GtkPositionType}. The default is \code{top}.

\subsection{Spin buttons}
\label{sec:RGtk2:spinboxes}

The spin button widget is very similar to the slider widget,
conceptually and in terms of the \GTK\/ API. Spin buttons are
constructed with \constructor{gtkSpinButton}. As with sliders, this
constructor requires specifying adjustment values, either as a
\class{GtkAdjustment} or individually.  The methods
\method{getValue}{gtkSpinButton} and \method{setValue}{gtkSpinButton}
once again get and set the widgets value. The \code{value-changed}
signal is emitted when the spin button is changed.

\begin{example}{A range widget}{ex:RGtk2-range-widget}
  \SweaveInput{ex-RGtk2-range-widget}
\end{example}

There are a few additional features. The property \code{snap-to-ticks}
can be set to \code{TRUE} to force the new value to belong to the
sequence of values in the adjustment. The \code{wrap} property
indicates if the sequence will ``wrap'' around at the bounds.

\section{Progress Reporting}

\subsection{Progress bars}
\label{sec:progress-bars}

It is common to use a progress bar to indicate the progress of a long
running computation. This implemented by \class{GtkProgressBar}. A
text label describes the current operation, and the progress bar
communicates the fraction completed:
<<>>=
w <- gtkWindow(); w$setTitle("Progress bar example")
pb <- gtkProgressBar()
w$add(pb)
#
pb$setText("Please be patient...")
for(i in 1:100) {
  pb$setFraction(i/100)
  Sys.sleep(0.05) ## replace with a step in the process
}
pb$setText("All done.")
@ 

Progress bars can also show indefinite activity by periodically
pulsing the bar: 
<<gtk-widget-progress-pulse>>=
pb$pulse()
@ 

\subsection{Spinners}

Related to a progress bar is the \class{GtkSpinner} widget, which is a
graphical heartbeat to assure the user that the application is still
alive during long-running operations. Spinners are commonly found in
web browsers. The basic usage is straightforward:
<<gtk-widget-spinner, eval=FALSE>>=
spinner <- gtkSpinner()
spinner$start()
spinner$stop()
@ 

\section{Drag and drop}
\label{sec:RGtk2:dnd}

%% ------------ Drag and Drop

A drag and drop operation is the movement of data from a source widget
to a target widget. The source widget serializes the selected item as
MIME data, and the destination interprets that data to perform some
operation, often creating an item of its own. Our task is to configure
the source and destination widgets, so that they listen for the
appropriate events and understand each other. As a trivial example, we
allow the user to drag the text from one button to another.

\subsection{Initiating a Drag}

When a drag and drop is initiated, different types of data may be
transferred. We need to define a target type for each type of data, as
a \class{GtkTargetEntry} structure. 
<<>>=
TARGET.TYPE.TEXT   <- 80                 
TARGET.TYPE.PIXMAP <- 81                  
widgetTargetTypes <- 
  list(text = gtkTargetEntry("text/plain", 0, 
         TARGET.TYPE.TEXT),
       pixmap = gtkTargetEntry("image/x-pixmap", 0, 
         TARGET.TYPE.PIXMAP))
@ 
%
The first component of \class{GtkTargetEntry} is the name, which often
a MIME type. The flags come next, which are usually left at $0$, and
finally we specify an arbitrary identifier for the target. We will
only use the \qcode{text} target in this example.

To instruct a widget to act as a drag source, we call
\function{gtkDragSourceSet}:
<<results=hide>>=
w <- gtkWindow(); w['title'] <- "Drag Source"
dragSourceWidget <-  gtkButton("Text to drag")
w$add(dragSourceWidget)

gtkDragSourceSet(dragSourceWidget,
       start.button.mask=c("button1-mask", "button3-mask"),
       targets=widgetTargetTypes[["text"]],
       actions="copy")
@ 
%
The \argument{start.button.mask}{gtkDragSourceSet} indicates the
modifier buttons that need to be pressed to initiate the drag, with
values from \class{GdkModifierType}. Then we specify the allowed
targets, \qcode{text} in this case. The
\argument{actions}{gtkDragSourceSet} argument lists the supported
actions, such as \code{copy} or \code{move}, from the
\class{GdkDragAction} enumeration. 

When a drag is initiated, we will receive the \signal{drag-data-get}
signal, which needs to place some data into the passed
\class{GtkSelectionData} object:
<<results=hide>>=
gSignalConnect(dragSourceWidget, "drag-data-get", 
               function(widget, context, selection, targetType, eventTime) {
                 selection$setText(widget$getLabel()) 
               })
@ 
%
If we had specified the \code{move}, we would also need to connect to
\signal{drag-data-delete}, in order to delete the data that was
moved away.

\subsection{Handling Drops}

To make a widget a drop target, we call \function{gtkDragDestSet} on
the object:
<<results=hide>>=
w <- gtkWindow(); w['title'] <- "Drop Target"
dropTargetWidget <- gtkButton("Drop here")
w$add(dropTargetWidget)

gtkDragDestSet(dropTargetWidget,
               flags="all", 
               targets=widgetTargetTypes[["text"]],
               actions="copy")
@
%
The signature is similar to that of \function{gtkDragSourceSet},
except for the \argument{flags}{gtkDragDestSet} argument, which
indicates which operations, of the set \code{motion}, \code{highlight}
and \code{drop}, \GTK\/ will handle with reasonable default
behavior. Specifying \code{all} is the most convenient course, in
which case we only need to implement the extraction of the data from
the \class{GtkSelectionData} object. For a drop to occur, there must be a
non-empty intersection between the targets passed to
\function{gtkDragSourceSet} and those passed to
\function{gtkDragDestSet}.

When data is dropped, the destination widget emits the
\code{drag-data-received} signal. The handler is responsible for
extracting the dragged data from \code{selection} and performing some
operation with it. In this case, we set the text on the button:
<<>>=
gSignalConnect(dropTargetWidget, "drag-data-received", 
               function(dropTargetWidget, context, x, y, selection, targetType,
                        eventTime) 
               {
                 dropdata <- selection$getText()
                 dropTargetWidget$setLabel(rawToChar(dropdata))
               })
@ 
%
The \code{context} argument is a \code{gdkDragContext}, containing
information about the drag event. The \code{x} and \code{y} arguments
are integer valued and represent the position in the widget where the
drop occurred. The text data is returned by \function{getText} as a
\code{raw} vector, so it is converted with \function{rawToChar}.

%% JV: This could be expanded -- motion is not covered, as is done with
%% tcltk, but I don't think it is needed without a compelling use case.

%% ML: agreed

%% ML: Should this go into this chapter or the next?
\section{Embedding R Graphics}
\label{sec:gtk-widget-graphics}

\SweaveInput{cairoDevice}
