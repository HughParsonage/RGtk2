This example demonstrates the construction of a GUI for selecting one
or more rows from a data frame. We will display a list of the installed
packages that can be upgraded from CRAN, although this code is
trivially generalizable to any list of choices. The user selects a row
by clicking on a checkbox produced by a toggle cell renderer.

<<echo=FALSE>>=
## example showing how to add a toggle button on left of data display
library(RGtk2)
@ 

To get the installed packages that can be upgraded, we use some of the
functions provided by the  \pkg{utils} package.
<<FixACRANforSweave, echo=FALSE>>=
repos <- getOption("repos")
repos["CRAN"] <- "http://streaming.stat.iastate.edu/CRAN"
options(repos = repos)
@ 
<<getUpgradablePackages>>=
d <- old.packages()[,c("Package", "Installed", "ReposVer")]
d <- as.data.frame(d)
@ 


This function will be called on the selected rows. Here, we simply
call \function{install.packages} to update the selected packages.
<<>>=
doUpdate <- function(d) {
  install.packages(d$Package)
}
@ 

To display the data frame, we first append a column to the data frame
to store the selection information and then create a corresponding
\class{RGtkDataFrame}.
<<>>=
n <- ncol(d)
nms <- colnames(d)
d$.toggle <- rep(FALSE, nrow(d))
store <- rGtkDataFrame(d)
@ 

Our tree view shows each text column using a simple text cell renderer,
except for the first column that contains the check boxes for selection.
<<print=FALSE>>=
view <- gtkTreeView()
# add toggle
cr <- gtkCellRendererToggle()
view$insertColumnWithAttributes(0, "", cr, active = n)
cr['activatable'] <- TRUE
gSignalConnect(cr, "toggled", function(cr, path, user.data) {
  view <- user.data
  row <- as.numeric(path) + 1
  model <- view$getModel()
  n <- dim(model)[2]
  model[row, n] <- !model[row, n]
}, data=view)
@ 

The text columns are added one-by-one in a similar manner:

<<print=FALSE>>=
mapply(view$insertColumnWithAttributes, -1, nms, list(gtkCellRendererText()), 
       text = 1:n-1)
@ 

Finally, we connect the store to the model.
<<>>=
view$setModel(store)
@ 

To allow the user to initiate the action, we create a button and
assign a callback. We pass in the view, rather than the model, in case
the model would be recreated by the \code{doUpdate} call. In a real
application, once a package is upgraded it would be removed from the
display.
<<print=FALSE>>=
b <- gtkButton("Update packages")
gSignalConnect(b, "clicked", function(w, data) {
  view <- data
  model <- view$getModel()
  n <- dim(model)[2]
  vals <- model[model[, n], -n, drop=FALSE]
  doUpdate(vals)
}, data=view)
@ 


Our basic GUI places the view into a box container that also holds the
button to initiate the action.
<<>>=
w <- gtkWindow(show=FALSE)
w$setTitle("Installed packages that need upgrading")
w$setSizeRequest(300, 300)

g <- gtkVBox(); w$add(g)
sw <- gtkScrolledWindow()
g$packStart(sw, expand=TRUE, fill=TRUE)

sw$add(view)
sw$setPolicy("automatic", "automatic")
g$packStart(b, expand=FALSE)
w$show()
@ 
