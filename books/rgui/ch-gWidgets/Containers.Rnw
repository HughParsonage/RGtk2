%% Basic Containers
<<echo=FALSE>>=
library(gWidgets)
options("guiToolkit"="RGtk2") ## for examples
@ 

%% ML: Might be clearer if the examples came almost at the beginning
%% of each section and followed by the details. For me, it's much
%% easier to see something and then have it explained, instead of
%% reading the details, constructing the example in my imagination,
%% and then seeing it.

% \begin{table}
%   \centering
%   \begin{tabular}{l@{\quad}p{.75\textwidth}}
% %    \toprule
%     \constructor{gwindow} & Creates a top-level window\\
%     \constructor{ggroup} & Creates a box-like container\\
%     \constructor{gframe} & Creates a container with a text label \\
%     \constructor{gexpandgroup} & Creates a container with a label and
%     expand/collapse trigger\\ 
%     \constructor{gpanedgroup} & Creates a container for two child widgets
%     with a handle to assign allocation of space\\
%     \constructor{glayout} & A grid container\\
%     \constructor{gnotebook} & A tabbed notebook container for holding a
%     collection of child widgets\\
%     \bottomrule
%   \end{tabular}
%   \caption{Table of container constructors in \pkg{gWidgets}}
%   \label{tab:gWidgets-container-constructors}
% \end{table}


After identifying the underlying data to manipulate and how to
represent it, GUI construction involves three basic steps: creation
and configuration of the main components; the layout of these
components; and linking the components to make a GUI interactive. This
chapter discusses the layout process within \pkg{gWidgets}. Layout in
\pkg{gWidgets} is done by placing child components within parent
containers which in turn may be nested in other containers. (This is
more like \GTK, and not \Qt where layout managers control where the
components are displayed.) The \pkg{gWidgets} package provides a just
few types containers: top-level windows, box containers, a grid
container, a paned container and  a notebook
container. Figure~\ref{fig:gWidgets-sample-layout} shows most all of
these employed to produce a GUI to select and then show contents of a file.


%% add
Except for the grid container, the primary method for containers is
their \meth{add} method. The basic call is of the form
\code{add(parent, child, extra\_arguments)}. However, this isn't
typically used. In some toolkits, notably \pkg{tcltk}, the widget
constructors require the specification of a parent window for the
widget. To accomodate that, the \pkg{gWidgets} constructors --
except for top-level windows -- have the argument \args{container}
to specify the immediate parent container.  Within the constructor is
the call \code{add(container, child,...)} where the constructor
creates the child and \code{...}  values are passed from the
constructor down to the \meth{add} method. That is, the widget
construction and layout are coupled together. Although, this isn't
necessary when utilizing \pkg{RGtk2} or \pkg{qtbase} -- and the two
aspects can be separated -- for the sake of cross-toolkit portability
we don't illustrate this here.




\section{Top-level windows}
\label{sec:gWidgets-top-level-windows}

The \constructor{gwindow} constructor creates top-level windows. The
main window property is the title which is typically displayed at the
top of the window. This can be set during construction via the
\argument{title}{gwindow} argument or accessed later through the
\meth{svalue\ASSIGN} method. A basic window then is constructed as follows:

<<windowTest1>>=
w <- gwindow("Our title", visible=TRUE)
@ 
%

We can then use this as a parent container for a constructor. For example;
<<windowTest1Container>>=
l <- glabel("A child label", container=w)
@ 
%
However, top-level windows only allow one child component. Typically, its child
is a container allowing multiple children such as a box container.


%% visible
The optional \argument{visible}{gwindow} argument, used above with its
default value \code{TRUE}~\footnote{If the option
\code{gWidgets:gwindow-default-visible-is-false} is non NULL, then the
default will be \code{FALSE}.}, controls whether the
window is initially drawn. If not drawn, the
\method{visible\ASSIGN}{gwindow} method, taking a logical value, can
be used to draw the window later.  Often it is good practice to suppress
the initial drawing, especially for displaying GUIs with several
controls, as the incremental drawing of subsequent child components can
make the GUI seem sluggish. As well, this allows the underlying
toolkit to compute the necessary size before it is displayed.


%% Size and placement
\paragraph{Size and placement}
In GUI programming, a window geometry is a specification of position
and size, often abbreviated $w \times h + x + y$. The width and height
can be specified at construction through the \argument{width}{gwindow}
and \argument{height}{gwindow} arguments. This initial size is the
default size, but may be adjusted later through the
\method{size}{gwindow} method or through the window manager. 

%% parent, location
The initial placement of a window, $x+y$, will be decided by the
window manager, unless the \argument{parent}{gwindow} argument is
specified. If this is done with a vector of $x$ and $y$ pixel values,
the upper left corner will be placed there. The \args{parent} argument
can also be another \code{gwindow} instance. In this case, the new
window will be positioned over the specified window and be transient
for the window. That is, it will be disposed when the parent window
is. This is useful, say, when a main window opens a dialog window to
gather values.

For example this call makes a child window of \code{w} with a square
size of 200 pixels.
<<childWindowTest>>=
childw <- gwindow("A child window", parent=w, size=c(200,200))
@ 


%% dispose/addHandlerUnrealize
\paragraph{Handlers}
Windows objects can be closed programmatically through their
\method{dispose}{gwindow} method. Windows may also be closed through
the window manager, by clicking a close icon in the title bar.  The
\argument{handler}{gwindow} argument is called just before the window
is destroyed, but cannot prevent that from happening.  The
\method{addHandlerUnrealize}{gwindow} method can be used to call a
handler between the initial click of the close icon and the subsequent
destroy event of the window. This handler must return a logical value:
if \code{TRUE} the window will not be destroyed, if \code{FALSE} the
window will be. For example:

<<windowUnrealizeMethod>>=
w <- gwindow("Close through the window manager")
id <- addHandlerUnrealize(w, handler=function(h,...) {
  !gconfirm("Really close", parent=h$obj)
})
@ 

In most GUIs,  the use of menubars, toolbars and
statusbars is often reserved for the main window, while dialogs are
not decorated so.  In \pkg{gWidgets} it is suggested, although not
strictly enforced unless done so by the underlying toolkit, that these be
added only to a top-level window.  We discuss these later in
Section~\ref{sec:gWidgets-acti-menus-toolb}. 

<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\constructor{gwindow}","Creates a top-level window"),
            c("\\constructor{ggroup}","Creates a box-like container"),
            c("\\constructor{gframe}","Creates a box container with a text label"),
            c("\\constructor{gexpandgroup}",paste("Creates a box container with a label and",
                                                  "trigger to expand/collapse",sep=" ")),
            c("\\constructor{glayout}","A grid container"),
            c("\\constructor{gpanedgroup}",
              paste("Creates a container for two child widgets",
                    "with a handle to assign allocation of space.",sep=" ")),
            c("\\constructor{gnotebook}","A tabbed notebook container for holding a collection of child widgets")
            )
colnames(df) <- c("Constructor","Description")
cat(booktabs(df, 
             colTypes = c("l","p{0.6\\textwidth}"),
             caption="Constructors for container objects",
             label="tab:gWidgets-container-constructors"))
@ 






\subsection{A modal window}
\label{sec:modal-window}


The \constructor{gbasicdialog} constructor allows one to place an
arbitrary widget within a modal window. It also adds \kbd{OK} and
\kbd{Cancel} buttons. The argument \argument{title}{gbasicdialog} is
used to specify the window title. 



As with the \function{gconfirm} dialog, this widget returns
\code{TRUE} or \code{FALSE} depending on the user's selection. To do
something more complicated than \code{gconfirm}, a handler should be
specified at construction which is called just before the dialog is
disposed.


This dialog is used in a slightly different manner, requiring the use
of a call to \meth{visible} (not \meth{visible\ASSIGN}).
There are three basic steps: an initial call to
\function{gbasicdialog} to return a container to be used as the parent
container for a child component; a construction of the dialog; then a
call to the \code{visible} method on the dialog with \code{set=TRUE}
value (not though \code{visible(obj) \ASSIGN\/ TRUE}).

For a basic example where the handler simply echoes back
the text stored in the label, we have:
<<eval=FALSE>>=
w <- gbasicdialog("A modal dialog", handler=function(h,...) {
  print(svalue(l))                      
})
l <- glabel("A simple label", cont=w)
visible(w, set=TRUE)                 # not visible(w) <- TRUE
@ 


\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{fig-gWidgets-example-browser}
  \caption{The example browser for gWidgets showing different layout components.}
  \label{fig:gWidgets-sample-layout}
\end{figure}



\section{Box containers}
\label{sec:gWidgets-box-containers}

The container produced by \constructor{gwindow} is intended to contain
just a single child widget, not several. This section demonstrates
variations on box containers that can be used to hold multiple child
components. Through nesting, fairly complicated layouts can be
produced.



<<echo=FALSE, results=tex>>=
## List methods for containers
df <- rbind(c("\\meth{add}",paste("Adds a child object to a parent container.",
                                  "Called when a parent container is specified to the \\args{container}",
                                  "argument of the widget constructor, in which case,",
                                  "the \\args{...} arguments are passed to",
                                  "this method.", sep=" ")),
            c("\\meth{delete}", "Remove a child object from a parent container"),
            c("\\meth{dispose}", "Destroy container and children"),
            c("\\meth{enabled\\ASSIGN}", "Set sensitivity of child components"),
            c("\\meth{visible\\ASSIGN}", "Hide or show child components")
            )
colnames(df) <- c("Method<","Description")
cat(booktabs(df, 
             colTypes=c("l","p{0.6\\textwidth}"),
             caption="Container methods", 
             label="tab:gWidgets-container-methods"
             ))
@ 



\subsection{The \code{ggroup} container}
\label{sec:gWidgets-ggroup-container}
  
The basic box container is produced by \constructor{ggroup}. Its main
argument is \argument{horizontal}{ggroup} to specify whether the child
widgets are packed in horizontally from left to right (the default) or
vertically from top to bottom. 

For example, to pack a \code{cancel} and \code{ok} button into a box container we might have:
<<cancelOk>>=
w <- gwindow("Some buttons", visible=FALSE)
g <- ggroup(horizontal=TRUE, cont=w)
cancel <- gbutton("cancel", cont=g)
ok <- gbutton("ok", cont=g)
visible(w) <- TRUE
@ 

\paragraph{The add method}
When packing in child widgets, the \method{add}{ggroup} method is
used. In our example above, this is called by the
\code{gbutton} constructor when the \args{container} argument is
specified. Unlike with the underlying graphical toolkits, there is no
means to specify other styles of packing such as from the ends, or in
the middle by some index.

The \meth{add} method for box containers has a few arguments to
customize how the child widgets respond when their parent window is
resized. These are passed through the 
\args{...}  argument of the constructor.

These arguments are:
\begin{description}
\item[expand, fill] When \code{expand=TRUE} is specified then the child
  widget will expand to fill the space allocated to it. The
  \args{fill} argument can be specified as \qcode{x}, \qcode{y}, or
  the default \qcode{both} to indicate which direction to fill
  in.  (This varies among the toolkits.)
  
  
\item[anchor] If a widget does not expand or if it does but does not fill in both
  directions, it can be anchored into its available space in more than
  one position. The \args{anchor} argument can be specified to suggest
  where to anchor the child. It takes a numeric vector representing
  Cartesian coordinates (length two),
  with either value being \code{-1}, \code{0}, or \code{1}. For
  example, a value of \code{c(1,1)} would specify the northwest corner.
\end{description}

Figure~\ref{fig:gWidgets-ggroup-expand-fill-anchor} shows combinations
of these arguments under \pkg{gWidgetsQt}.


\begin{figure}
  \centering
  \includegraphics[width=.5\textwidth]{fig-gWidgets-ggroup-expand-fill-anchor}
  \caption{Different combinations of \code{expand}, \code{fill} and
    \code{anchor} for combo boxes in \pkg{gWidgetsQt}. The \code{fill}
    and \code{anchor} arguments
    may be overridden by the underlying toolkit for some widgets.}
  \label{fig:gWidgets-ggroup-expand-fill-anchor}
\end{figure}
<<echo=FALSE, results=hide>>=
w <- gwindow("gWidgetsQt")
g <- ggroup(horizontal=FALSE, cont=w)
l <- gcombobox("expand=TRUE", expand=TRUE, cont=g)
gseparator(cont=g)
l <- gcombobox("expand=TRUE, fill='x'", expand=TRUE, fill="x", cont=g)
gseparator(cont=g)
l <- gcombobox("expand=TRUE, fill='y'", expand=TRUE, fill="y", cont=g)
gseparator(cont=g)
l <- gcombobox("expand=FALSE, anchor=c(1,0)",anchor=c(1,0), cont=g)
@ 


\paragraph{delete}
The \method{delete}{ggroup} method can be used to remove a child
component from a container. In some toolkits, this child may be
added back at a later time, but this isn't part of the API. In the
case where you wish to hide a child temporarily, the
\meth{visible\ASSIGN} method may be used.





\paragraph{Spacing}
For spacing between the child components, the constructor's argument
\argument{spacing}{ggroup} may be used to specify, in pixels, the
amount of space between the child widgets. For \code{ggroup}
instances, this can later be set through the \method{svalue}{ggroup}
method. The method \method{addSpace}{ggroup} can add a non-uniform
amount of space between two widgets packed next to each other, whereas
the method \method{addSpring}{ggroup} will place an invisible spring
between two widgets, forcing them apart.  Both are useful for laying
out buttons.


For example, we might modify our button layout example to include a
``help'' button on the far left and the others on the right with a
fixed amount of space between them as follows (Figure~\ref{fig:gWidgets-button-layout}):
<<results=hide>>=
w <- gwindow("Some buttons", visible=FALSE)
g <- ggroup(horizontal=TRUE, spacing=6, cont=w)
help <- gbutton("help", cont=g)
addSpring(g)
cancel <- gbutton("cancel", cont=g)
addSpace(g, 12)                         # 6 + 12 + 6 pixels
ok <- gbutton("ok", cont=g)
visible(w) <- TRUE
@ 


\begin{figure}
  \centering
  \includegraphics[width=.7\textwidth]{fig-gWidgets-buttons}
  \caption{Button layout for \pkg{RGtk2} (top), \pkg{tcltk} (middle)
    and \pkg{qtbase} (bottom). Although the same code is used for each, the different styling yields varying sizes. }
  \label{fig:gWidgets-button-layout}
\end{figure}

To illustrate how the right panel of
Figure~\ref{fig:gWidgets-sample-layout} was done, we used nested
layouts as follows:

<<echo=FALSE>>=
w <- gwindow("Nested layout example")
@ 

<<nestedLayout, results=hide>>=
g <- ggroup(horizontal=FALSE, cont=w)
bg <- ggroup(cont=g)                    # nested group
addSpring(bg)
b <- gbutton("Source", cont=bg)
nb <- gnotebook(cont=g, expand=TRUE)    # fill space
@ 


\paragraph{Sizing}
The overall size of a \code{ggroup} container is typically decided by
how it is added to its parent. However, a requested size can be assigned
through the \method{size\ASSIGN}{ggroup} method. 


For some toolkits the argument \argument{use.scrollwindow}{ggroup},
when specified as \code{TRUE}, will add scrollbars to the box
container so that a fixed size can be maintained. Setting a requested
size in this case is a good idea. (Although, it is generally
considered a poor idea to use scrollbars when there is a chance the
key controls for a dialog will be hidden, this can be useful for
displaying lists of data.)


% \begin{example}{The \args{use.scrollwindow} argument}{ex-gWidgets-ggroup-use.scrollwindow}
%   \SweaveInput{ex-gWidgets-ggroup-scrollwindow}
% \end{example}

% The next example shows an alternative to the expand group widget.

% \begin{example}{The \meth{delete} method of \code{ggroup}}{ex-gWidgets-ggroup-delete}
%   \SweaveInput{ex-gWidgets-alert-box}
% \end{example}


\subsection{The \code{gframe} and \code{gexpandgroup} containers}
\label{sec:gWidgets-decorated-cont}

We discuss briefly two widgets that essentially subclass the
\code{ggroup} class. Much of the previous discussion applies.

Framed containers are used to set off its child elements using a
border and label. The \constructor{gframe} constructor produces
them. In Figure~\ref{fig:gWidgets-sample-layout} the table to select
the file is from is nested in a frame to give the user some indication
as to what to do.

For \constructor{gframe} the first argument, \argument{text}{gframe}, is
used to specify the label. This can later be adjusted through the
\method{names\ASSIGN}{gframe} method. The argument
\argument{pos}{gframe} can be specified to adjust the label's
positioning with $0$ being the left and $1$ the right.



The basic framed container is used along these lines:
<<>>=
w <- gwindow("gframe example")
f <- gframe("gWidgets Examples:", cont=w)
files <- list.files(system.file("Examples","ch-gWidgets", 
                                package="ProgGUIInR"))
vars <- gtable(files, cont=f, expand=TRUE)
@ 


Expandable containers are useful when their child items need not be
visible all the time. The typical design involves a trigger indicator
with accompanying label indicating to the user that a click can
disclose or hide some additional information. This class subclasses
\code{gframe} where the \method{visible\ASSIGN}{gexpandgroup} method
is overridden to initiate the hiding or showing of its child area, not
the entire container.

In addition, a handler can be added that is called whenever the widget
toggles its state.

Here we show how one might leave optional the display of a statistical
summary of a model.
<<>>=
res <- lm(mpg ~ wt, mtcars)
out <- capture.output(summary(res))

w <- gwindow("gexpandgroup example", visible=FALSE)
eg <- gexpandgroup("Summary", cont=w)
l <- glabel(out, cont=eg)
visible(eg) <- TRUE                     # display summary
visible(w) <- TRUE
@ 

(How each toolkit resizes when the widget collapse varies.)

\paragraph{Separators}
Although not a container, the \constructor{gseparator} widget can be
used to place a horizontal or vertical line (with the
\code{horizontal=FALSE} argument) in a layout to separate off parts of
the GUI. 




% \begin{example}{The \constructor{gframe} and \constructor{gexpandgroup} containers}{gWidgets-gframe-gexpandgroup-ex}
% \SweaveInput{ex-gWidgets-gframe-gexpandgroup.Rnw}
% \end{example}



\section{Grid layout: the \code{glayout} container}
\label{sec:gWidgets-glayout-container}

The layout of dialogs and forms is usually seen with some form of
alignment between the widgets. The \constructor{glayout} constructor
provides a grid container to do so, using matrix notation to specify
location of the children.  

To see its use, we can layout a simple form for collecting information
as follows:

<<glayoutExample, results=hide>>=  
w <- gwindow("glayout example", visible=FALSE)
tbl <- glayout(cont=w, spacing=5)
right <- c(1,0); left <- c(-1,0)
tbl[1,1, anchor=right] <- "name"
tbl[1,2, anchor=left ] <- gedit("", cont=tbl)
tbl[2,1, anchor=right] <- "rank"
tbl[2,2, anchor=left ] <- gedit("", cont=tbl)
tbl[3,1, anchor=right] <- "serial number"
tbl[3,2, anchor=left ] <- gedit("", cont=tbl)
visible(w) <- TRUE
@ 
%

The constructor has a few arguments to configure the appearance of the
container. The spacing between each cell may be specified through the
\argument{spacing}{glayout} argument, the default is 10 pixels. A
value of 5 is used above to tighten up the display.
To impose a uniform cell size, the \argument{homogeneous}{glayout}
argument can be specified with a value of \code{TRUE}. The default is
\code{FALSE}. 

As seen, children may be added to the grid at a specific row and
column. To specify this, \R's matrix notation, \code{[\ASSIGN}, is
used with the indices indicating the row and column.  A child may span
more than one row or column. The corresponding index should be a
vector of indices indicating so.  

The \code{[} method may be used to
return the child occupying position $i,j$. To return the values of the
widgets above can be done through:
<<>>=
vals <- sapply(seq_len(dim(tbl)[1]), function(i) {
  svalue(tbl[i,2])
  })
@ 


When adding a child the \code{glayout} container should be specified as
the widget's \code{container} and also be on the left hand side of the
\code{[\ASSIGN} call. (This is necessary only for the toolkits where a
container must be specified, where the right hand side is used to pass
along the parent information and the left hand side is used for the
layout.) For convenience, if the right hand side is a string, a label
will be generated.  To align a widget within a cell, the
\argument{anchor}{add} argument of the \code{[\ASSIGN}{glayout} method
is used. The example above illustrates how this can be used to achieve
a center balance.


% \begin{example}{Layout with \constructor{glayout}}{ex-gWidgets-glayout}
%   This example shows how a simple form can be given an center-balanced
%   layout using a grid container. 

% \end{example}


\section{Paned containers: the \code{gpanedgroup} container}
\label{sec:gWidgets-gpanedgroup-container}

The \constructor{gpanedgroup} constructor produces a container which
has two children separated by a visual gutter that can be
adjusted by the user with their mouse to allocate the space among them.
Figure~\ref{fig:gWidgets-sample-layout} uses such a
container to separate the file selection controls from the file
display ones.  For this container, the children are aligned
side-by-side (by default) or top to bottom if the
\argument{horizontal}{gpanedgroup} argument is given as
\code{FALSE}. 


To add children, the container should be used as the parent container
for two constructors. These can be other container constructors which
is the typical usage for more complicated layouts.
(For toolkits which support the separation of widget
construction and layout, the \constructor{gpanedgroup} constructor can
have two children specified to the arguments
\argument{widget1}{gpanedgroup} and \argument{widget2}{gpanedgroup}.)

The main property of this container is the sash position, a value in
$[0,1]$. This may be configured programmatically
through the \method{svalue\ASSIGN}{gpanedgroup} method, where a value
from 0 to 1 specifies the proportion of space allocated to the
leftmost (topmost) child. This specification only works after the
containing window is drawn, as the percentage is based on the size of
the window.


A simplified version of the layout in
Figure~\ref{fig:gWidgets-sample-layout} would be
<<>>=
d <- system.file("Examples/ch-gWidgets", package="ProgGUIinR")
files <- list.files(d)
#
w <- gwindow("gpanedgroup example", visible=FALSE)
pg <- gpanedgroup(cont = w)
tbl <- gtable(files, cont=pg)           # left side
t <- gtext("", cont=pg, expand=TRUE)    # right side
visible(w) <- TRUE
svalue(pg) <- 0.33                      # after drawing
@ 


% \begin{example}{Paned groups}{ex-gWidgets-panedgroups}
%   This example shows how one could use this container.
% <<keep.source=TRUE>>=
% w <- gwindow("gpanedgroup example", visible=FALSE)
% pg <- gpanedgroup(cont=w)
% g <- ggroup(cont=pg)                  # left child
% l <- glabel("left child", cont=g)
% b <- gbutton("right child", cont=pg)
% visible(w) <- TRUE
% @ 
% To adjust the sash position, one can do:
% <<>>=
% svalue(pg) <- 0.75
% @ 
% \end{example}


  
\section{Tabbed notebooks: the \code{gnotebook} container}
\label{sec:gWidgets-gnotebook}

The \constructor{gnotebook} constructor produces a tabbed notebook
container. The GUI in Figure~\ref{fig:gWidgets-sample-layout} uses a
notebook to hold different text widgets, one for each file being displayed.

The \pkg{gWidgets} constructor has a few arguments. If permitted, the
argument \argument{tab.pos}{gnotebook} is used to specify the location
of the tabs using a value of 1 through 4 with 1 being botton, 2 left
side, 3 top and 4 right side being used, with the default being 3
(similar numbering as used in \function{par}). The
\argument{closebuttons}{gnotebook} argument takes a logical indicating
whether the tabs should have close buttons on them. In this case, the
argument \argument{dontCloseThese}{gnotebook} can be used to specify
which tabs, by index, should not be closable. (As of writing, this is
not implemented in \pkg{gWidgetstcltk}.)



\paragraph{Methods}
Pages are added through the \method{add}{gnotebook} method for the
notebook container. The extra  \argument{label}{add} argument is used
to specify the tab label. (As \meth{add} is called implicitly when a a
widget is constructed, this argument is usually specified to the
constructor.)



The \method{svalue}{gnotebook} method returns the index of the
currently raised tab, whereas \method{svalue\ASSIGN}{gnotebook} can be
used to switch the page to the specified tab. The currently shown tab
can be removed using the \method{dispose}{gnotebook} method. To remove
a different tab, use this method in combination with
\meth{svalue\ASSIGN}. (When removing many tabs, you will want to start
from the end as otherwise the tab positions change during removal.)

From some viewpoint, the notebook widget is viewed as a vector with a
names attribute (the labels) and components being the child
components. As such, the \method{names}{gnotebook} method can be used
to retrieve the tab names, and \method{names\ASSIGN}{gnotebook} to set
the names. The \method{length}{gnotebook} method returns the number of
pages held by the notebook. The \meth{[} method is also implemented to return the
child components by index.



\begin{example}{Tabbed notebook example}{ex-gWidgets-gnotebook}
 In the GUI of Figure~\ref{fig:gWidgets-sample-layout} a notebook is
 used to hold differing pages. The following is the basic setup used.
<<>>=  
w <- gwindow("gnotebook example")
nb <- gnotebook(cont=w)
@ 

New pages are added as follows:
<<results=hide>>=
fname <- "DESCRIPTION"                  # or something else
f <- system.file(fname, package="gWidgets")
gtext(readLines(f), cont = nb, label=fname)
@ 

To manipulate the displayed pages, say to set the page to the last one
we have:
<<>>=
svalue(nb) <- length(nb)
@ 
To remove the current  page
<<>>=
dispose(nb)
@ 
%
\end{example}


