%% orgainze by function
<<echo=FALSE>>=
library(gWidgets)
options(guiToolkit="RGtk2")

@ 

\XXX{Where to integrate methods such as enabled?}
\XXX{stock icons}
\XXX{addHandler text -- done here with first, but could be elsewhere}
\XXX{drag and drop example}
  

  
This section discusses the basic controls provided by
\pkg{gWidgets}.

<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\constructor{glabel}", "A text label"),
            c("\\constructor{gbutton}", "A button to initiate an action "),
            c("\\constructor{gcheckbox}", "A checkbox"),
            c("\\constructor{gcheckboxgroup}", "A group of checkboxes"),
            c("\\constructor{gradio}", "A radio button group"),
            c("\\constructor{gcombobox}", "A drop-down list of values, possible editable"),
            c("\\constructor{gtable}", "A table (vector or data frame) of values for selection"),
            c("\\constructor{gslider}", "A slider to select from a sequence value"),
            c("\\constructor{gspinbutton}", "A spinbutton to select from a sequence of values"),
            c("\\constructor{gedit}", "Single line of editable text"),
            c("\\constructor{gtext}", "Multi-line text edit area"),
            c("\\constructor{ghtml}", "Display text marked up with HTML"),
            c("\\constructor{gdf}", "Data frame viewer and editor"),
            c("\\constructor{gtree}", "A display for heirarchical data"),
            c("\\constructor{gimage}", "A display for icons and images"),
            c("\\constructor{ggraphics}", "A widget containing a graphics device"),
            c("\\constructor{gsvg}", "A widget to display SVG files"),            
            c("\\constructor{gfilebrowser}", "A widget to select a file or directory"),
            c("\\constructor{gcalendar}", "A widget to select a date"),
            c("\\constructor{gaction}", "A resusable definition of an action"),
            c("\\constructor{gmenubar}", "Adds a menubar on a top-level window "),
            c("\\constructor{gtoolbar}", "Adds a toolbar to a top-level window"),
            c("\\constructor{gstatusbar}", "Adds a status bar to a top-level window"),
            c("\\constructor{gtooltip}", "Add a tooltip to widget"),
            c("\\constructor{gseparator}", "A widget to display a horizontal or vertical line")
            )
colnames(df) <- c("Constructor","Description")
cat(booktabs(df,
             colTypes=c("l","p{0.7\\textwidth}"),
             caption="Table of constructors for control widgets in \\pkg{gWidgets}. Most, but not all, are implemented for each toolkit.",
             label="tab:gWidgets-control-widgets"))
@             
%% place these as approporiate
% \begin{table}
%   \centering
%   \begin{tabular}{l@{\quad}p{.75\textwidth}}
% %    \toprule
%     \constructor{glabel} & A text label\\
%     \constructor{gbutton} & A button to initiate an action \\
%     \constructor{gcheckbox} & A checkbox widget\\
%     \constructor{gradio} & Constructs a radio button group\\
%     \constructor{gcheckboxgroup} & Constructs a group of checkboxes\\
%     \constructor{gcombobox} & Constructs drop down list of values\\
%     \constructor{gtable} & Shows a table (vector or data frame) of
%     values for selection\\ 
%     \constructor{gslider} & A slider to select a value\\
%     \constructor{gspinbutton} & A spinbutton to select from a set of values\\
%     \constructor{gedit} & One line of editable text\\
%     \constructor{gtext} & multi-line text edit\\
%     \constructor{ghtml} & Display text marked up with HTML\\
%     \constructor{gdf} & Data frame viewer and editor\\
%     \constructor{gtree} & Displays heirarchical data\\
%     \constructor{gimage} & Displays icons and images\\
%     \constructor{ggraphics} & A widget containing a graphics device\\
%     \constructor{gfilebrowser} & A widget to select a file or directory\\
%     \constructor{gcalendar} & A widget to select a date\\
%     \constructor{gaction} & a resusable definition of an action\\
%     \constructor{gmenubar} & Puts a menubar on a top-level window\\    
%     \constructor{gtoolbar} & Adds a toolbar to a top-level window\\
%     \constructor{gstatusbar} & Adds a status bar to a top-level window\\
%     \constructor{gseparator} & A widget to display a horizontal or vertical line\\
%     \bottomrule
%   \end{tabular}
%   \caption{Table of basic control constructors in \pkg{gWidgets}}
%   \label{tab:gWidgets-control-widgets}  
% \end{table}


\subsection{Buttons}
\label{sec:gWidgets-buttons}

The button widget allows a user to initiate an action through clicking
on it. Buttons have labels, conventionally verbs indicating action,
and often icons. The \constructor{gbutton} constructor has an argument
\argument{text}{gbutton} to specify the text.  For text that matches
the stock icons of \pkg{gWidgets}
(Section~\ref{sec:gWidgets-displ-icons-imag}) an icon will
appear. (The \code{ok} button below, but not the custom \code{par...} one.)

In common with the other controls, the argument
\argument{handler}{gbutton} is used to specify a callback and the
\argument{action}{gbutton} argument will be passed along to this
callback (unless it is a \code{gaction} object, whose case is described
in Section~\ref{sec:gWidgets-actions}).
The default handler is the click handler which can be specified at
construction, or afterward through 
\method{addHandlerClicked}{gbutton}.

The following example shows how a button can be used to call a sub
dialog to collect optional information. We imagine this as part of a
dialog to generate a plot.

<<results=hide>>=
w <- gwindow("Make a plot")
g <- ggroup(horizontal=FALSE, cont=w)
glabel("... Fill me in ...", cont=g)
bg <- ggroup(cont=g)
addSpring(bg)
parButton <- gbutton("par...", cont=bg)

addHandlerClicked(parButton, handler=function(h,...) {
  w1 <- gwindow("Set par values...", parent=w)
  lyt <- glayout(cont=w1)
  lyt[1,1, align=c(-1,0)] <- "mfrow: c(nr,nc)"
  lyt[2,1] <- (nr <- gedit(1, cont=lyt))
  lyt[2,2] <- (nc <- gedit(1, cont=lyt))
  lyt[3,2] <- gbutton("ok", cont=lyt, handler=
                      function(h,...) {
                        x <- as.numeric(c(svalue(nr), svalue(nc)))
                        par(mfrow=x)
                        dispose(w1)
                      })
})
@ 



%% methods
The button's label is its main property and can be queried or set with
The \method{svalue}{gbutton} or \method{svalue\ASSIGN}{gbutton}.  Most
GUIs will make a button insensitive to user input if the button's
action is not currently permissible. Toolkits draw such buttons in a
grayed-out state. As with other components, the \method{enabled\ASSIGN}{gWidgets} method can set
or disable whether a widget can accept input.

%% Default
% A new button may or may not have the focus when a GUI is
% constructed. If it does have the focus, then the \kbd{return} key will
% initiate the button click signal. To make a GUI start with its focus
% on a button, the \method{defaultWidget}{gWidgets} method is available. 


% A basic example of a button with a handler was given in Example~\ref{ex-gWidgets-hello-world-button}.

%% ML: I don't think it would hurt to see something like that
%% again. The reader will expect an example here.

% As an example of the limitations of \pkg{gWidgets} compared to the
% underlying toolkits, within \pkg{gWidgets} there are no methods to set
% an icon, or add an mnemonic to the button.


% \begin{example}{Hello world button}{ex-gWidgets-hello-world-button}
%   This example shows how a button is assigned a handler to respond to
%   click events.~\footnote{Each toolkit has its idiosyncracies. If this
%     example is run using \pkg{RGtk2} the button will stretch to fill
%     the space. At times this is not desired. Placing the button within
%     a \code{ggroup} container can prevent this. Whereas, under
%     \code{tcltk} the parent window will shrink to fit the button. The
%     \meth{size} method can prevent this if it is not desired.} When
%   working with handlers, one can use an object name that will be found
%   through \R's scoping rules, or the components passed through the
%   \code{h} argument, as below.

% <<>>=
% w <- gwindow("Button example")
% b <- gbutton("Click me", cont=w)
% id <- addHandlerChanged(b, action=w, handler=function(h,...) {
%   btnText <- svalue(h$obj)                   # or svalue(b)
%   svalue(h$obj) <- paste("don't", btnText, "again") # set text
%   enabled(h$obj) <- FALSE
%   svalue(h$action) <- "Button example is finished" # set title
% })

% @ 

% \end{example}


\subsection{Labels}
\label{asec:gWidgets-labels}

The \constructor{glabel} constructor produces a basic label
widget. We've seen its use in a number of examples. The main property,
the label's text, is specified through the \argument{text}{glabel}
argument. This is a character vector of length 1 or is coerced into
one by collapsing the vector with newlines. The
\method{svalue}{glabel} method will return the label text as a single
string, whereas the \method{svalue\ASSIGN}{glabel} method is avaialable
to set the text programatically.

The \method{font\ASSIGN}{glabel} method
can also be used to set the text markup
(Table~\ref{tab:gWidgets-font-properties}).  For \pkg{gWidgetsRGtk2} the
argument \argument{markup}{glabel} for the constructor takes a logical
value indicating if the text is in the native markup language (PANGO).


For example, to make a form's labels have some emphasis we could do:
<<results=hide>>=
w <- gwindow("label example")
f <- gframe("Summary statistics:", cont=w)
lyt <- glayout(cont=f)
lyt[1,1] <- glabel("xbar:", cont=lyt)
lyt[1,2] <- gedit("", cont=lyt)
lyt[2,1] <- glabel("s:", cont=lyt)
lyt[2,2] <- gedit("", cont=lyt)
sapply(1:2, function(i) {
  tmp <- lyt[i,1]
  font(tmp) <- c(weight="bold", color="blue")
})
@ 


The widget constructor also has the argument
\argument{editable}{glabel}, which when specified as \code{TRUE} will
add a handler to the event so that the text can be edited when the
label is clicked.  Although this is popular in some familiar
interfaces, such as a spreadsheet tab, it has not proven to be
intuitive to most users, as labels are not generally expected to change.


\subsection{Statusbars}
\label{sec:gWidgets-statusbars}

Statusbars are simply labels placed at the bottom of a top-level window to leave
informative, but non-disruptive, messages for the user.  The
\constructor{gstatusbar} constructor provides this widget.  The
\args{container} argument should be a top-level window instance. 
The only property is the label's text. This may be specified at
construction with the argument
\argument{text}{gstatusbar}. Subsequent changes are made through
the \method{svalue\ASSIGN}{gstatusbar} method. 




\subsection{Displaying icons and images stored in files}
\label{sec:gWidgets-displ-icons-imag}

The \pkg{gWidgets} package provides a few stock icons that can be
added to various GUI components. A list of the defined stock icons is
returned by the function \code{getStockIcons}.  The names attribute
defines the valid stock icon names. It was mentioned that if a
button's label matches a stock icon name, that icon will appear
adjacent to the label.



%% gimage
Other graphic files and the stock icons can be displayed by the
\constructor{gimage} widget. \footnote{Not all file types may be
  displayed by each toolkit, in particular \pkg{gWidgetstcltk} can
  only display gif, ppm, and xbm files.} The file to display is
specified through the \argument{filename}{gimage} argument of the
constructor. This value is combined with that of the
\argument{dirname}{gimage} argument to specify the file path.  Stock
icons, can be specified by using their name for the \code{filename}
argument and the character string \code{"stock"} for the
\code{dirname} argument.~\footnote{For \pkg{gWidgetsRGtk2}, the size
  of a stock icon can be adjusted through the \argument{size}{gimage}
  argument, with a value from \qcode{menu}, \qcode{small\_toolbar},
  \qcode{large\_toolbar}, \qcode{button}, or \qcode{dialog}.}
%% methods

The \method{svalue\ASSIGN}{gimage} method is used to change the
displayed file. In this case, a full path name is specified, or the
stock icon name.

The default handler is a button click handler.


To illustrate, a simple means to display a graphic (except in
\pkg{gWidgetstcltk} where png support is not available) is
as follows:
<<results=hide>>=
f <- tempfile()
png(f)
hist(rnorm(100))
dev.off()

w <- gwindow("Example to show a graphic")
gimage(basename(f), dirname(f), cont=w)
@ 


More stock icon names may be added through the function
\code{addStockIcons}. This function requires a vector of stock icon
names and a vector of corresponding file paths, and is illustrated
through an example.


\begin{example}{Adding and using stock icons}{ex-gWidgets-stock-icons}
  \SweaveInput{ex-gWidgets-add-icons}
\end{example}

Finally, we mention the \constructor{gsvg} constructor is similar to \constructor{gimage}, but allows one to
display SVG files, as produced by the \function{svg} driver, say. It
currently is only available for \pkg{gWidgetsQt}.

\section{Text editing controls}
\label{sec:gWidgets-text-edit-contr}



\subsection{Single-line, editable text}
\label{sec:gWidgets-single-line-editable}

The \pkg{gWidgets} package, following the underlying toolkits, has two
main widgets for editing text: \constructor{gedit} for a single line
of editable text, and \constructor{gtext} for multi-line, editable
text.  For some toolkits, a \constructor{ghtml} widget is also
defined, but neither \pkg{gWidgetsRGtk2} nor \pkg{gWidgetstcltk} have this
implemented.


The \constructor{gedit} constructor produces a widget to display a
single line of editable text. The main property is the initial text
which can be set through the \argument{text}{gedit} argument.  If it
is desirable to set the width of the widget, the
\argument{width}{gedit} argument allows the specification in terms of
number of characters allowed to display without horizontal
scrolling. The width of the widget may also be specified in pixel size
through the \method{size}{guiWidget} method.


\paragraph{Methods}
The text is returned by the \method{svalue}{gedit} method and may be
set through the \method{svalue\ASSIGN}{gedit} method.  The
\meth{svalue} method will return a character vector by
default. However, it may be desirable to use this widget to collect
numeric values or perhaps some other type of variable. One could write
code to coerce the character to the desired type, but it is sometimes
convenient to have the return value be a certain non-character
type. In this case, the \argument{coerce.with}{gedit} argument can be
used to specify a function of a single argument to call before the
value is returned by \meth{svalue}.

Some toolkits allow type-ahead values to be set. These values
anticipate what a user wishes to type and offers a means to complete a
word. The \method{[\ASSIGN}{gedit} method allows these values to be
specifed through a character vector, as in \code{obj[] \ASSIGN\/ values}.

For example, the following can be used to collect one of the 50 state
names in the U.S.:
<<results=hide>>=
w <- gwindow("gedit example") 
g <- ggroup(cont=w)
glabel("State name:", cont=g)
e <- gedit("", cont=g)
e[] <- state.name
@ 

\paragraph{Handlers}
The default handler for the \constructor{gedit} widget is called when
the text area is ``activated'' through the
\kbd{return} key being pressed. Use \meth{addHandlerBlur} to add a
callback for the event of losing focus. The
\method{addHandlerKeystroke}{gedit} method can assign a handler to be
called when a key is released. For the toolkits that support it, the
specific key is given in the \code{key} component of the list \code{h} (the first component).

\begin{example}{Validation}{ex-gWidgets-gedit-validation}
  \SweaveInput{ex-gWidgets-gedit-validation}
\end{example}

\subsection{Multi-line, editable text}
\label{sec:gWidgets-multi-line-editable}

The \constructor{gtext} constructor produces a multi-line text editing
widget with scrollbars to accommodate large amounts of text. The
\argument{text}{gtext} argument is for specifying the intial
text. The initial width and height can be
set through similarly named arguments, which is useful with
\pkg{gWidgetstcltk}. 

The \method{svalue}{gtext} method retrieves the text stored in the
buffer. If the argument \code{drop=TRUE} is specified, then only the
currently selected text will be returned. Text in multiple lines is
returned as a single string with ``\backslashn'' separating the lines.

The contents of the text buffer can be replaced with the
\method{svalue\ASSIGN}{gtext} method. To clear the buffer, the
\method{dispose}{gtext} method can be used. The \method{insert}{gtext}
method adds text to a buffer. The signature is \code{insert(obj, text,
  where, font.attr)}
where \code{text} is a character vector. New text is added to the end
of the buffer, by default, but the \argument{where}{insert} argument
can specify \qcode{beginning} or \qcode{at.cursor}.




As with \code{gedit}, the \method{addHandlerKeystroke}{gtext} method
sets a handler to be called for each keystroke. This is the default
handler.

\paragraph{fonts}
Fonts can be specified for the entire buffer or the selection using
the specifications in Table~\ref{tab:gWidgets-font-properties}. To
specify fonts for the entire buffer use the
\argument{font.attr}{gtable} argument of the constructor. The
\method{font\ASSIGN}{gtext} method serves the same purpose, provided
there is no selection when called. If there is a selection, the font
change will only be applied to the selection. Finally, the
\argument{font.attr}{insert} argument for the \meth{insert} method
specifies the font attributes for the inserted text.

<<echo=FALSE, results=tex>>=
df <- rbind(
            c("weight","light, normal, bold"),
            c("style", "normal, oblique, italic"),
            c("family", "normal, sans, serif, monospace"),
            c("size", "a point size, such as 12"),
            c("color", "a named color")
            )
colnames(df) <- c("Attribute","Possible value")
cat(booktabs(df, 
             colTypes=c("l","p{0.6\\textwidth}"),
             caption="Possible specfications for setting font properties. Font values of an object are changed with named vectors, as in \\code{font(obj)\\ASSIGN c(weight=\"bold\", size=12, color=\"red\")}", 
             label="tab:gWidgets-font-properties"
             ))
@ 

\begin{example}{A calculator}{ex-gWidgets-calculator}
  \SweaveInput{ex-gWidgets-calculator}
\end{example}

\section{Selection controls}
\label{sec:gWidgets-widg-select-data}

A common task for a GUI control is to select a value or values from a
set of numbers or a table of numbers. Many toolkits implement these
widgets using a model-view-controller paradigm whereby the control is
just one of possibly many views of the data model. This
approach is not used by \pkg{gWidgets}. Rather, each widget has its
own data store (like a vector or data frame)
containing the data for selection, and familar \R\/ methods are used to
manipulate this underlying data store. The controls in \pkg{gWidgets} that
display such data have the methods \code{[}, \code{[\ASSIGN},
\code{length}, \code{dim}, \code{names} and \code{names\ASSIGN}, as
appropriate.

This section discusses several selection controls that serve a similar
purpose but make different use of screen space.

\subsection{Checkbox widget}
\label{sec:gWidgets-checkbox-widget}

The simplest selection control is the \constructor{checkbox} widget
that allows the user to set a state as \code{TRUE} or
\code{FALSE}. The constructor has an argument
\argument{text}{gcheckbox} to set a label and
\argument{checked}{gcheckbox} to indicate if the widget should
initially be checked. The default is \code{TRUE}. By default the label
will be drawn aside a checkbox, if the argument
\argument{use.togglebutton}{gcheckbox} is \code{TRUE}, a toggle button
-- which appears depressed when \code{TRUE} -- is used.

The \method{svalue}{gcheckbox} method returns a logical indicating if
the widget is in the checked state. Use \method{svalue\ASSIGN}{gcheckbox} to set
the state. The label's value is returned by the
\method{[}{gcheckbox} method, and can be adjusted through 
\method{[\ASSIGN}{gcheckbox}. (We take the abstract view that the user
is selecting, or not, from the length-1 vector, so \meth{[} is used to
set the data to select from.)

The default handler would be called on a click event, when the state toggles. If it is desired
that the handler be called only in the \code{TRUE} state, say, one
needs to check within the handler for this. For example

<<>>=
w <- gwindow("checkbox example")
cb <- gcheckbox("label", cont=w, handler=function(h,...) {
  if(svalue(h$obj))                     # it is checked
    print("define handler here")
})
@ 

\subsection{Radio button widget}
\label{sec:gWidgets-radio-button-widget}

A radio button group allows the user to choose one of a few
items. A radio button group object is returned by
\constructor{gradio}. The items to choose from are specified as a
vector of values to the \argument{items}{gradio} argument (2 or more). These items
may be displayed horizontally or vertically (the default) as specified by the
\argument{horizontal}{gradio} argument which expects a logical. The
\argument{selected}{gradio} argument specifies the initially selected
item, by index,
with a default of the first.

The currently selected item is returned by \method{svalue}{gradio} as
the label text or by the index if the argument \args{index} is
\code{TRUE}. The item may be set with the
\method{svalue\ASSIGN}{gradio} method. Again, the item may be
specified by the label or by an index, the latter when the argument
\code{index=TRUE} is specified. The data store is the set of labels so
are referenced through the \method{[}{gradio} method, and may be set
(if the underlying toolkit allows it) with the
\method{[\ASSIGN}{gradio} method. (In \pkg{gWidgetstcltk} one can not
change the number of radio buttons.) For convenience, the
\method{length}{gradio} method returns the number of labels.

The handler, if given to the constructor or set with \meth{addHandlerChanged}, is called on a click event.

\subsection{A group of checkboxes}
\label{sec:gWidgets-group-checkboxes}


The checkbox group widget, produced by the
\constructor{gcheckboxgroup} constructor, is similar to a radio group,
but allows the selection of one or more of a set of items.  The
\argument{items}{gcheckboxgroup} arugment is used to specify the
values. The state of whether an item is selected can be set with a
logical vector of the same size as the number of items to the
\argument{checked}{gcheckboxgroup} argument; recycling is used. The
item layout can be controlled by the
\argument{horizontal}{gcheckboxgroup} argument. The default is a
vertical layout (\code{horizontal=FALSE}).

The state is retrieved as a character vector through the
\method{svalue}{gcheckboxgroup} method. The \code{index=TRUE} argument
instructs \meth{svalue} to return the indices instead. As a
checkboxgroup is like both a checkbox and a radio button group, one
can set the selected values two different ways. As with a checkbox, 
the selected values can be set by specifying a logical vector through the
\method{svalue\ASSIGN}{gcheckboxgroup} method. As with radio button groups,
the selected values can also be set with a character vector indicating
which labels should be selected, or if \code{index=TRUE} is given,
using a numeric index vector.

The labels are returned through the \method{[}{gcheckboxgroup} method
and if the underlying toolkit allows it, set through the
\method{[\ASSIGN}{gcheckboxgroup} method. As with \constructor{gradio},
the \method{length}{gcheckboxgroup} method returns the number of items.

As an illustration of the related selection widgets, the following
could be part of a GUI to illustrate densities for various kernels.
<<>>=
kerns <- as.character(formals(density.default)$kernel)[-1]

w <- gwindow("Arguments for density example")
lyt <- glayout(cont=w)

lyt[1,1] <- "bw"
lyt[1,2, anchor=c(-1,0)] <- 
  gradio(c("nrd0", "nrd", "ucv", "bcv", "SJ"), cont=lyt)

lyt[2,1] <- "Kernel"
lyt[2,2, anchor=c(-1,0)] <- gcheckboxgroup(kerns, cont=lyt)

lyt[3,1] <- "na.rm"
lyt[3,2, anchor=c(-1,0)] <- 
  gcheckbox("na.rm", checked=TRUE, use.togglebutton=TRUE, cont=lyt)

lyt[4,2] <- gbutton("done", cont=lyt, handler=function(h,...) {
  out <- sapply(1:3, function(i) {
    widget <- lyt[i,2]
    svalue(widget)
  })
  print(out)                            # make a plot...
})
@ 

\subsection{A combobox}
\label{sec:gWidgets-combobox}

A combobox is used as an alternative to a radio button group when
there are too many choices to comfortably fit on the screen. Comboboxes are
constructed by \constructor{gcombobox}. The possible choices are specified to the argument
\argument{items}{gcombobox}. This may be a vector of values or a data
frame whose first column defines the choices. For toolkits which
support icons in the combobox, if the data is specified as a data
frame, the second column signifies which stock icon is to
be used. By design, a third column specifies a tooltip to appear when
the mouse hovers over a selection,
but this is only implemented for \pkg{gWidgetsQt}.

%% ML: this should not be hard to implement with GTK+ 2.12. 
%% JV: hard for me though :(

This example shows how to create a combobox to select from the
available icons. For toolkits that support icons in a combobox, they
appear next to the label.
<<comboboxExample, results=hide>>=
nms <- getStockIcons()                  # gWidgets icons
d <- data.frame(names=names(nms), icons=names(nms), 
                stringsAsFactors=FALSE)
w <- gwindow("Combobox example")
g <- ggroup(cont=w)
cb <- gcombobox(d, cont=g)

@ 


The argument \argument{editable}{gcombobox} accepts a logical value
indicating if the user can supply their own value by typing into a
text entry area. The default is \code{FALSE}. When editing is
possible, the constructor also has the
\argument{coerce.with}{gcombobox} argument like \code{gedit}.

\paragraph{Methods}
The currently selected value is returned through the
\method{svalue}{gcombobox} method. If \args{index} is \code{TRUE}, the
index of the selected item is given if possible. The state can be set
through the \method{svalue\ASSIGN}{gcombobox} method. This is
specified by a character unless \args{index} is \code{TRUE}, in which
case as a numeric index with respect to the underlying items. The
\method{[}{gcombobox} method returns the items of the data store, and
\method{[\ASSIGN}{gcombobox} is used to assign new values to the data
store. The value may be a vector, or data frame if an icon or tooltip
is being assigned. The \method{length}{gcombobox} method returns the
number of items.

The default handler is called when the state of the widget is
changed. This is also aliased to
\method{addHandlerClicked}{gcombobox}. When \code{editable} is
\code{TRUE}, then the \method{addHandlerKeystroke}{gcombobox} method
sets a handler to response to keystroke events.



\subsection{A slider control}
\label{sec:gWidgets-slider-control}

The \constructor{gslider} constructor creates a slider that allows the
user to select a value from the specified sequence.  The arguments
mirror that of the \code{seq} function in \R:
\argument{from}{gslider}, \argument{to}{gslider}, and
\argument{by}{gslider}.  In \pkg{gWidgetstcltk} the sequence must have
integer steps. If this is not the case, the spin button control is
used instead. In addition to the arguments to specify the sequence,
the argument \argument{value}{gslider} is used to set the initial
value of the widget and \argument{horizontal}{gslider} controls how
the slider is drawn, \code{TRUE} for horizontal, \code{FALSE} for
vertical.

The \method{svalue}{gslider} method returns the currently chosen
value. The \method{[\ASSIGN}{gslider} method can be used to update the
sequence of values to choose from. The new assignment should be a
regularly spaced sequence of numbers, as returned by \code{seq}.

The default handler is called when the slider is changed. Example~\ref{ex-gWidgets-sliders-spingbuttons}
shows how this can be used to update a graphic.


\subsection{A spin button control}
\label{sec:gWidgets-spin-button-control}

The spin button control constructed by \constructor{gspinbutton} is
similar to  \constructor{gslider}, but presents the user a different
way to select the value. The argument \argument{digits}{gspinbutton}
specifies how many digits are displayed. 

\begin{example}{Example of sliders and spin buttons}{ex-gWidgets-sliders-spingbuttons}
  The use of sliders and spin buttons to dynamically adjust a graphic
  is common in \R\/ GUIs targeted towards teaching statistics. Here is
  an example, similar to the \code{tkdensity} example of \pkg{tcltk},
  where the slider controls the bandwidth of a density estimation and
  the spin button the sample size of a random sample.
<<results=hide>>=  
w <- gwindow("Slider and Spin Button example") 
tbl <- glayout(cont=w)
tbl[1,1] <- "sample size"
tbl[1,2] <- (spinner <- gspinbutton(from=10, to=100, by=5, 
                                    value=25, cont=tbl))
tbl[2,1] <- "adjusted bandwidth"
tbl[2,2, expand=TRUE] <- (slider <- gslider(from=0.1, to=1, 
           by=0.01, value=1, cont=tbl))

plotGraph <- function(h,...) {
  x <- rexp(svalue(spinner))
  plot(density(x, adj=svalue(slider)))
}
sapply(list(spinner, slider), function(i) 
  addHandlerChanged(i, handler=plotGraph))
@ 
\end{example}




\subsection{Selecting from the file system}
\label{sec:gWidgets-selecting-from-file}

The \constructor{gfile} dialog allows one to select a file or directory
from the file system. This is a modal dialog, which returns the name
of the selected file or directory. The \constructor{gfilebrowse}
constructor creates a widget that has a button that
initiates this selection.  

The selection type is specified by the \code{type} argument with
values of \code{open}, to select an existing file; \code{save} to
select a file to write to; and \code{selectdir} to select a
directory. For \code{RGtk2}, the \argument{filter}{gfile} argument can
be used to narrow the listed files. The dialog returns the path of the
file, or \code{NA} if the dialog was canceled. One can also specify a
handler to the constructor to call on the file or directory name. The
component \code{file} of the first argument to the handler contains
the file name.

<<eval=FALSE>>=
if(!is.na(tmp <- gfile())) 
  source(tmp)
## or
gfile(handler=function(h,...) {
  if(!is.na(h$file))
    source(h$file) 
})   
@ 
%$


\subsection{Selecting a date}
\label{sec:gWidgets-selecting-date}

The \constructor{gcalendar} constructor returns a widget for selecting
a date, if the there is a native widget in the underlying toolkit,
or a text edit box for entering a date. The argument
\argument{text}{gcalendar} arugment specifies the initial
text. The format of the date is specified by the
\argument{format}{gcalendar} argument.

The methods for the widget inherit from \code{gedit}. In particular,
the \method{svalue}{gcalendar} method returns the text in the text box
as a character vector formatted by the value specified by the
\argument{format}{gcalendar} argument. To return a value of a
different class, pass a function, such as \code{as.Date} to the
\argument{coerce.with}{gcalendar} argument.




\section{Display of tabular data}
\label{sec:gWidgets-tabular-data-display}


The \constructor{gtable} constructor produces a widget that displays
data in a tabular form from which the user can select one (or more)
rows. The widgets performance under \pkg{gWidgetsRGtk2} and
\pkg{gWidgetsQt} is much faster and able to handle larger data stores
%% ML: I'm assuming gWidgetsQt will soon take advantage of the DataFrameModel
than under \pkg{gWidgetstcltk}, as there is no native table widget in
\tcltk. All perform well on moderate-sized data sets (10 or so columns
and fewer than 500 rows),

The data is specified through the \argument{items}{gtable}
argument. This may be a data frame, matrix or vector. Vectors and
matrices are coerced to data frames, with
\code{stringsAsFactors=FALSE}.  The data is presented in a tabular
form, with column headers derived from the \code{names} attribute of
the data frame.

The \argument{icon.FUN}{gtable} argument
can be used to place a stock icon in a left-most column.  This argument
takes a function of a single argument -- the data frame being shown --
and should return a character vector of stock icon names, one for each
row.

To illustrate, a widget to select from the available data frames in
the global environment can be generated with
<<>>=
availDfs <- function(envir=.GlobalEnv) {
  x <- ls(envir=envir)
  x[sapply(x, function(i) is.data.frame(get(i, envir=envir)))]
}

w <- gwindow("gtable example")
d <- data.frame(dfs=availDfs(), stringsAsFactors=FALSE)
dfs <- gtable(d, cont=w)
@ 


\paragraph{Selection}
Users can select a row, not a cell from this widget. The value returned by a selection is
controlled by the constructor's arguments \argument{chosencol}{gtable}, which
specifies which column value will be returned, as the user can only
specify the row; and \argument{multiple}{gtable} which controls
whether the user may select more than one row.  


\paragraph{Methods}
The \method{svalue}{gtable} method will return the currently selected
value. If the argument \code{index} is specified as \code{TRUE}, then
the selected row index (or indices) will be returned. These refer to
the data store, not the visible data when filtering is being used (below). The
argument \code{drop} specifies if just the chosen column's value is
returned (the default) or, if specified as \code{FALSE}, the entire row.
 
The underlying data store is referenced by the \method{[}{gtable}
method. Indices may be used to access a slice. Values may be
set using the \method{[\ASSIGN}{gtable} method, but be warned it is
not as flexible as assigning to a data frame. The underlying
toolkits may not like to change the type of data displayed in a
column, so when updating a column do not assume some underlying
coercion, as is done with \R's data frames. To replace the data store, the \code{[\ASSIGN} can
be used via \code{obj[] \ASSIGN\/ new\_data\_frame}. The methods
\method{names}{gtable} and \method{names\ASSIGN}{gtable} refer to the
column headers, and \method{dim}{gtable} and \method{length}{gtable}
the underlying dimensions of the data store.

To update the list of data frames in our \code{dfs} widget, one can define a function such as
<<updateDfs>>=
updateDfs <- function() {
  dfs[] <- availDfs()
}
@ 


\paragraph{Handlers}
Selection is done through a single click. The \method{addHandlerClick}{gtable}
method can be used to assign a handler to those events. The default
handler, \method{addHandlerDoubleclick}{gtable}, will assign a
handler for a double click event. Also of interest are the
\method{addHandlerRightclick}{gtable} and
\method{add3rdMousePopupMenu}{gtable} methods for assigning handlers
to right-click events.


To add a handler to the data frame selection widget above, we could have
<<results=hide>>=
addHandlerDoubleclick(dfs, handler=function(h,...) {
  val <- svalue(h$obj)
  ## some action
  print(summary(get(val, envir=.GlobalEnv)))
})
@ 



\paragraph{Filtering}
The arguments \argument{filter.column}{gtable} and
\argument{filter.FUN}{gtable} allow one to specify whether the user
can filter, or limit, the display of the values in the data store. If
a column number is specified to \code{filter.column} then a combobox
is added to the widget with values taken from the unique values in the
specified column. Changing the value of the combobox restricts the
display of the data to just those rows where the value in the filter
column matches the combobox value. More advanced filtering can be
specified using the \argument{filter.FUN}{gtable} argument. If this is
a function, then it takes arguments \code{(data\_frame, filter.by)}
where the data frame is the data, and the \code{filter.by} value is
the state of a combobox whose values are specified through the
argument \argument{filter.labels}{gtable}. This function should return
a logical vector with length matching the number of rows in the data
frame.  Only rows corresponding to \code{TRUE} values will be
displayed. If \code{filter.FUN} is the character string
``\code{manual}'' then the \method{visible\ASSIGN}{gtable} method can
be used to control the filtering, again by specifying a logical vector
of the proper length. See Example~\ref{ex-gWidgets-filter-gtable} for
an application.


The \constructor{gtable} widget shows clearly the trade offs between
using \pkg{gWidgets} and a native toolkit under \R. As will be seen in
later chapters, setting up a table to display a data frame using the
toolkit packages directly can involve a fair amount of coding as
compared to \constructor{gtable}, which makes it very easy. However,
\pkg{gWidgets} provides far less functionality. For example, there is
no method to adjust the column sizes programatically (although they
can be adjusted with the mouse), there is no means to adjust the
formatting of the displayed text, or to embed other widgets into the
tabular display.

\begin{example}{Simple filtering}{ex-gWidgets-simple-filter-gtable}
  We use the \code{Cars93} data set from the \pkg{MASS} package to
  show how to set up a display of the data which provides simple
  filtering based on the type of car, whose value is stored in column 3.
  
<<>>=  
require(MASS)
w <- gwindow("gtable example")
tbl <- gtable(Cars93, chosencol=1, filter.column=3, cont=w)
@ 

Adding a handler for the double click event is illustrated bleow. This
handler prints both the manufacturer and the model of the currently
selected row when called.
<<>>=
addHandlerChanged(tbl, handler=function(h,...) {
  val <- svalue(h$obj, drop=FALSE)
  cat(sprintf("You selected the %s %s", val[,1], val[,2]))
})
@ 
%%$ emacs
\end{example}


\begin{example}{More complex filtering}{ex-gWidgets-filter-gtable}
 \SweaveInput{ex-gWidgets-filter-gtable}
\end{example}


\section{Display of hierarchical data}
\label{sec:gWidgets-displ-heir-data}

The \constructor{gtree} constructor can be used to display
heirarchical structures, such as a file system or the components of a
list. The \constructor{gtree} implementation dynamically computes the
child components, by parameterizing the data to be displayed in terms
of the node of the tree that is currently selected. The
\argument{offspring}{gtree} argument is assigned a function of two
arguments, the path a particular node and the arbitrary object passed
through the optional \argument{offspring.data}{gtree} argument. This
function should return a data frame with each row referring to an
offspring for the node and whose first column is a key that identifies
each of the offspring, unless the argument \argument{chosencol}{gtree}
is used to specify otherwise.

To indicate if a node has offspring, a function can be passed through
the \argument{hasOffspring}{gtree} argument. This function takes the
data frame returned by the \code{offspring} function and should return
a logical vector with each value indicating which rows have
offspring. If it is more convenient to compute this within the
\code{offspring} function, then when \code{hasOffspring} is left
unspecified and the second column returned by \code{offspring} is a
logical, then that column will be used.

As an illustration, this function produces an offspring function to
explore the heirarchical structure of a list. It uses a closure to
encapsulate the list, rather than using the
\argument{offspring.data}{gtree} argument or a global variable.
<<>>=
listOffspring <- function(lst) {
  offspring <- function(path=character(0),...) {
    if(length(path))
      obj <- lst[[path]]
    else
      obj <- lst
    nms <- names(obj)
    hasOffspring <- sapply(nms, function(i) {
      newobj <- obj[[i]]
      is.recursive(newobj) && !is.null(names(newobj))
    })
    data.frame(comps=nms, hasOffspring=hasOffspring, 
               stringsAsFactors=FALSE)
  }
  return(offspring)                     
}
@ 
%
The above will produce a tree with just one column. By adding columns
to the data frame above, say a column to record the class of the
variable, more information can easily be presented

To see the above used, we define a list to explore.
<<>>=
l <- list(a="1", b=list(a="11", b="12", c=list(a="111")))
o <- listOffspring(l)
w <- gwindow("Tree test")
t <- gtree(o, cont=w)
@ 
%%


A single click is used to select a row. Multiple selections are
possible if the \argument{multiple}{gtree} argument is given a
\code{TRUE} value.

For some toolkits the \argument{icon.FUN}{gtree} can be used to
specify a stock icon to be displayed next to the first column. This
function, like \code{hasOffspring}, has as an argument the data frame
returned by \code{offspring} and should return a character vector with
each entry indicating which stock icon is to be shown.

For some toolkits, the column type must be determined prior to
rendering. By default, a call to \code{offspring} with argument
\code{c()} indicating the root node is made. The returned data frame
is used to determine the column types. If that is not correct, the
argument \argument{col.types}{gtree} can be used. It should be a data
frame with column types matching those returned by \code{offspring}.

\paragraph{Methods}
The \method{svalue}{gtree} method returns the currently selected key,
or node label. There is no assignment method. The \method{[}{gtree}
method returns the path for the currently selected node. This is what
is passed to the \code{offspring} function.  The
\method{update}{gtree} method updates the displayed tree by
considering the children of the root node.  The method
\method{addHandlerDoubleclick}{gtree} specifies a function to call on
a double click event.

\begin{example}{Using \code{gtree} to explore a recursive partition}{ex-gWidgets-gtree}
 \SweaveInput{ex-gWidgets-gtree}
\end{example}





\section{Actions, menus and toolbars}
\label{sec:gWidgets-acti-menus-toolb}

%% ML: Is the overview really the right place for this? As you said,
%% this really needs an example. I think it could go into the control
%% widget chapter, at the end.
%% JV: agreed, moved.

Actions are invisible objects representing an application command that
is executable through one or more widgets. See \ref{sec:GUI:actions}
for more details. Actions in \pkg{gWidgets} are created through the
\constructor{gaction} contstructor. The arguments are
\argument{label}{gaction}, \argument{tooltip}{gaction},
\argument{icon}{gaction}, \argument{key.accel}{gaction} and the
standard \argument{handler}{gaction} and
\argument{action}{gaction}. The label appears as the text on a button,
the menu item or toolbar text, whereas the icon will decorate the same
if possible. For some toolkits, the tooltip pops up when the mouse
hovers.  (See also the \meth{tooltip\ASSIGN} method.)

\paragraph{methods}
The main methods for actions are \method{svalue\ASSIGN}{gaction} to
set the label text and \method{enabled\ASSIGN}{gaction} to adjust
whether the widget is sensitive to user input. All instances of the
action are set through one call. In some toolkits, such as
\pkg{RGtk2}, actions are bundled together into action groups. This
grouping allows one to set the sensitivity of related actions at
once. In \R, one can store like actions in a list, and get similar
functionality by using \code{sapply}, for example.

\paragraph{buttons}
An action can be assigned to a button by setting it as the
\argument{action}{gbutton} argument of the \code{gbutton} constructor,
in which case all other arguments for the constructor are ignored.

<<>>=
w <- gwindow("gaction example")
a <- gaction("click me", tooltip="Click for a message", icon="ok", 
             handler=function(h,...) {
               print("Hello")
               })
b <- gbutton(action=a, cont=w)
## .. to change
enabled(a) <- FALSE                     # can't click now
@ 
%%
Action handlers generally do not have the sender object (\code{b})
passed back to them. Instead, one uses
the \argument{action}{gaction} argument to parameterize the call.



\subsection{Toolbars}
\label{sec:gWidgets-toolbars}
Toolbars and menubars are implemented in \pkg{gWidgets} using
\code{gaction} items. Toolbars (and menubars) are specified using a named
list of menu components. 

For a toolbar, the list has a simple structure. Each named component
either describes a toolbar item or a separator. The toolbar items are
specified by \code{gaction} instances and separators by
\code{gseparator} instances with no container specified.

For example,
<<results=hide>>=
w <- gwindow("gtoolbar example")
l <- list(Open=gaction("Open", icon="open", 
            handler=function(...) print("Open")),
          Close=gaction("Close", icon="cancel", 
            handler=function(...) print("Close")),
          sep=gseparator(),
          Quit=gaction("Quit", icon="quit", 
            handler=function(...) print("Quit"))
          )
tb <- gtoolbar(l, cont=w)
gtext("Placeholder", cont=w)
@ 


The \constructor{gtoolbar} constructor takes the list as its first
argument.  As toolbars belong to the window, the corresponding
\pkg{gWigdets} objects use a \constructor{gwindow} object as the
parent container. (Some of the toolkits relax this.)  The argument
\argument{style}{gtoolbar} can be one of \qcode{both}, \qcode{icons},
\qcode{text}, or \qcode{both-horiz} to specify how the toolbar is
rendered. Toolbars in \pkg{gWidgetstcltk} are not native widgets, so
the implementation uses aligned buttons.


\subsection{Menubars, popup menus}
\label{sec:gWidgets-menubars}

Menubars and popup menus are specified in a similar manner as toolbars with menu items
being defined through \code{gaction} instances, and visual separators
by \code{gseparator} instances. Menus differ from toolbars, as
submenus require a nested structure. This  is specified using a
nested list as the component to describe the sub menu. The lists all
have named components. In this case, the corresponding name is used to
label the submenu item. For menu bars, it is typical that all the
top-level components be lists, but for popup menus, this wouldn't
necessarily be the case.

A example of such a list might be
<<results=hide>>=
f <- function(h,...) print(h$action)                # a stub
ml <- list(File=list(
             Source=gaction("Source file...", action="source",  
               handler=f),
             Load=gaction("Load workspace...", action="load", 
               handler=f),
             sep=gseparator(),
             New=list(
               Plot=gaction("Plot window", action="plot", 
                 handler=f),
               Rfile=gaction("R file", action="file", handler=f)
               )
             ),
           Help=list(
             about=gaction("About", action="about", handler=f)
             )
           )
@ 

<<echo=FALSE>>=
w <- gwindow("Menubar example")
mb <- gmenu(ml, cont=w)
gtext("Placeholder", cont=w)
@ 


In Mac OS X, with a native toolkit, menubars may be drawn along the top
of the screen, as is the custom of that OS. 

\paragraph{Menubar and Toolbar Methods}
The main methods for toolbar and menubar instances are
the \method{svalue}{gmenu} method which will return the list. Whereas, the
\method{svalue\ASSIGN}{gmenu} method can be used to redefine the
menubar or toolbar. Use the \method{add}{gmenu} method to append to an
existing menubar or toolbar, again using a list to specify the new items.


% \begin{example}{Menubar and toolbar example}{ex-gWidgets-menu-tool-status-bars}
%   \SweaveInput{ex-gWidgets-menu-tool-status-bars}
% \end{example}

\paragraph{Popup menus}

Popup menus can be created for a right click event through the
\constructor{add3rdMousePopupmenu} constructor. (Or
\kbd{control-button-1} for Mac OS X.) This constructor has arguments
\code{obj} to specify a widget, like a button, to initiate the popup,
\argument{menulist}{gmenu} to specify the menu and optionally an
\argument{action}{gmenu} argument.


\begin{example}{Popup menus}{ex-gWidgets-context-menus}
<<>>=  
w <- gwindow("Popup example")
b <- gbutton("click me or right click me", cont=w, 
             handler=function(h, ...) {
               cat("You clicked me\n")
             })
f <- function(h,...) cat("you right clicked on", h$action)
mbList <- list(one = gaction("one", action="one", handler=f),
               two = gaction("two", action="two", handler=f)
               )
add3rdMousePopupmenu(b, mbList)
@ 

\end{example}










