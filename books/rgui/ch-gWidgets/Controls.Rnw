%% organize by function
<<echo=FALSE>>=
library(gWidgets)
options(guiToolkit = "RGtk2")

@ 

\XXX{Where to integrate methods such as enabled?}
\XXX{stock icons}
\XXX{addHandler text -- done here with first, but could be elsewhere}
\XXX{drag and drop example}
  

  
This chapter discusses the basic GUI controls provided by
\pkg{gWidgets}. We defer discussion of the \R-specific widgets to the
next chapter.

<<echo=FALSE, results=tex>>=
df <- rbind(
            c("\\constructor{glabel}", "A text label"),
            c("\\constructor{gbutton}", "A button to initiate an action "),
            c("\\constructor{gcheckbox}", "A checkbox"),
            c("\\constructor{gcheckboxgroup}", "A group of checkboxes"),
            c("\\constructor{gradio}", "A radio button group"),
            c("\\constructor{gcombobox}", "A drop-down list of values, possibly editable"),
            c("\\constructor{gtable}", "A table (vector or data frame) of values for selection"),
            c("\\constructor{gslider}", "A slider to select from a sequence value"),
            c("\\constructor{gspinbutton}", "A spinbutton to select from a sequence of values"),
            c("\\constructor{gedit}", "Single line of editable text"),
            c("\\constructor{gtext}", "Multi-line text edit area"),
            c("\\constructor{ghtml}", "Display text marked up with HTML"),
            c("\\constructor{gdf}", "Data frame viewer and editor"),
            c("\\constructor{gtree}", "A display for hierarchical data"),
            c("\\constructor{gimage}", "A display for icons and images"),
            c("\\constructor{ggraphics}", "A widget containing a graphics device"),
            c("\\constructor{gsvg}", "A widget to display SVG files"),            
            c("\\constructor{gfilebrowse}", "A widget to select a file or directory"),
            c("\\constructor{gcalendar}", "A widget to select a date"),
            c("\\constructor{gaction}", "A reusable definition of an action"),
            c("\\constructor{gmenubar}", "Add a menubar on a top-level window "),
            c("\\constructor{gtoolbar}", "Add a toolbar to a top-level window"),
            c("\\constructor{gstatusbar}", "Add a status bar to a top-level window"),
            c("\\constructor{gtooltip}", "Add a tooltip to widget"),
            c("\\constructor{gseparator}", "A widget to display a horizontal or vertical line")
            )
colnames(df) <- c("Constructor","Description")
cat(booktabs(df,
             colTypes=c("l","p{0.7\\textwidth}"),
             caption="Table of constructors for control widgets in \\pkg{gWidgets}. Most, but not all, are implemented for each toolkit.",
             label="tab:gWidgets-control-widgets"))
@             
%% place these as appropriate
% \begin{table}
%   \centering
%   \begin{tabular}{l@{\quad}p{.75\textwidth}}
% %    \toprule
%     \constructor{glabel} & A text label\\
%     \constructor{gbutton} & A button to initiate an action \\
%     \constructor{gcheckbox} & A checkbox widget\\
%     \constructor{gradio} & Constructs a radio button group\\
%     \constructor{gcheckboxgroup} & Constructs a group of checkboxes\\
%     \constructor{gcombobox} & Constructs drop down list of values\\
%     \constructor{gtable} & Shows a table (vector or data frame) of
%     values for selection\\ 
%     \constructor{gslider} & A slider to select a value\\
%     \constructor{gspinbutton} & A spinbutton to select from a set of values\\
%     \constructor{gedit} & One line of editable text\\
%     \constructor{gtext} & multi-line text edit\\
%     \constructor{ghtml} & Display text marked up with HTML\\
%     \constructor{gdf} & Data frame viewer and editor\\
%     \constructor{gtree} & Displays hierarchical data\\
%     \constructor{gimage} & Displays icons and images\\
%     \constructor{ggraphics} & A widget containing a graphics device\\
%     \constructor{gfilebrowser} & A widget to select a file or directory\\
%     \constructor{gcalendar} & A widget to select a date\\
%     \constructor{gaction} & a reusable definition of an action\\
%     \constructor{gmenubar} & Puts a menubar on a top-level window\\    
%     \constructor{gtoolbar} & Adds a toolbar to a top-level window\\
%     \constructor{gstatusbar} & Adds a status bar to a top-level window\\
%     \constructor{gseparator} & A widget to display a horizontal or vertical line\\
%     \bottomrule
%   \end{tabular}
%   \caption{Table of basic control constructors in \pkg{gWidgets}}
%   \label{tab:gWidgets-control-widgets}  
% \end{table}

%% ML: fooled around with the sectioning here; hope you're OK with it

\section{Buttons}
\label{sec:gWidgets-buttons}

The button widget allows a user to initiate an action through clicking
on it. Buttons have labels, conventionally verbs indicating action,
and often icons. The \constructor{gbutton} constructor has an argument
\argument{text}{gbutton} to specify the text.  For text that matches
the stock icons of \pkg{gWidgets}
(Section~\ref{sec:gWidgets-displ-icons-imag}) an icon will
appear. (The \code{ok} button below, but not the \code{parButton} one.)

In common with the other controls, the argument
\argument{handler}{gbutton} is used to specify a callback and the
\argument{action}{gbutton} argument will be passed along to this
callback (unless it is a \code{gaction} object, whose case is
described in Section~\ref{sec:gWidgets-acti-menus-toolb}).  The
default handler is the click handler which can be specified at
construction, or afterward through
\method{addHandlerClicked}{gbutton}. 
% ML: seems to be too much detail? kind of confusing...
%The underlying toolkit's method
%of invoking a callback through keyboard navigation is used.

The following example shows how a button can be used to call a sub
dialog to collect optional information. We imagine this as part of a
dialog to generate a plot.

<<results=hide>>=
window <- gwindow("Make a plot")
group <- ggroup(horizontal = FALSE, cont = window)
glabel("... Fill me in ...", cont = group)
button_group <- ggroup(cont = group)
addSpring(button_group)
parButton <- gbutton("par (mfrow) ...", cont = button_group)
@ 
Our callback opens a subwindow to collect a few values for the
\code{mfrow} option.
<<>>=
addHandlerClicked(parButton, handler = function(h,...) {
  child <- gwindow("Set par values for mfrow", parent = window)
  lyt <- glayout(cont = child)
  lyt[1,1, align = c(-1,0)] <- "mfrow: c(nr,nc)"
  lyt[2,1] <- (nr <- gedit(1, cont = lyt))
  lyt[2,2] <- (nc <- gedit(1, cont = lyt))
  lyt[3,2] <- 
    gbutton("ok", cont = lyt, handler = 
            function(h,...) {
              x <- as.numeric(c(svalue(nr), svalue(nc)))
              par(mfrow = x)
              dispose(child)
            })
})
@ 



%% methods
The button's label is its main property and can be queried or set with
\method{svalue}{gbutton} or \method{svalue\ASSIGN}{gbutton}.  Most
GUIs will make a button insensitive to user input if the button's
action is not currently permissible. Toolkits draw such buttons in a
grayed-out state. As with other components, the \method{enabled\ASSIGN}{gWidgets} method can set
or disable whether a widget can accept input.

%% Default
% A new button may or may not have the focus when a GUI is
% constructed. If it does have the focus, then the \kbd{return} key will
% initiate the button click signal. To make a GUI start with its focus
% on a button, the \method{defaultWidget}{gWidgets} method is available. 


% A basic example of a button with a handler was given in Example~\ref{ex-gWidgets-hello-world-button}.

%% ML: I don't think it would hurt to see something like that
%% again. The reader will expect an example here.

% As an example of the limitations of \pkg{gWidgets} compared to the
% underlying toolkits, within \pkg{gWidgets} there are no methods to set
% an icon, or add an mnemonic to the button.


% \begin{example}{Hello world button}{ex-gWidgets-hello-world-button}
%   This example shows how a button is assigned a handler to respond to
%   click events.\footnote{Each toolkit has its idiosyncrasies. If this
%     example is run using \pkg{RGtk2} the button will stretch to fill
%     the space. At times this is not desired. Placing the button within
%     a \code{ggroup} container can prevent this. Whereas, under
%     \code{tcltk} the parent window will shrink to fit the button. The
%     \meth{size} method can prevent this if it is not desired.} When
%   working with handlers, one can use an object name that will be found
%   through \R's scoping rules, or the components passed through the
%   \code{h} argument, as below.

% <<>>=
% w <- gwindow("Button example")
% b <- gbutton("Click me", cont = w)
% id <- addHandlerChanged(b, action = w, handler = function(h,...) {
%   btnText <- svalue(h$obj)                   # or svalue(b)
%   svalue(h$obj) <- paste("don't", btnText, "again") # set text
%   enabled(h$obj) <- FALSE
%   svalue(h$action) <- "Button example is finished" # set title
% })

% @ 

% \end{example}


\section{Labels}
\label{asec:gWidgets-labels}

The \constructor{glabel} constructor produces a basic label
widget. We've already seen its use in a number of examples. The main
property, the label's text, is specified through the
\argument{text}{glabel} argument. This is a character vector of length
1 or is coerced into one by collapsing the vector with newlines. The
\method{svalue}{glabel} method will return the label text as a single
string, whereas the \method{svalue\ASSIGN}{glabel} method is
available to set the text programmatically.

The \method{font\ASSIGN}{glabel} method
can also be used to set the text markup
(Table~\ref{tab:gWidgets-font-properties}).\footnote{For some of the underlying toolkits, setting the argument
\argument{markup}{glabel} to \code{TRUE} allows a native markup language
to be used (\GTK\/ had PANGO, \Qt\/ has rich text).}
\\

To make a form's labels have some emphasis we could do:
<<results=hide>>=
window <- gwindow("label example")
frame <- gframe("Summary statistics:", cont = window)
lyt <- glayout(cont = frame)
lyt[1,1] <- glabel("xbar:", cont = lyt)
lyt[1,2] <- gedit("", cont = lyt)
lyt[2,1] <- glabel("s:", cont = lyt)
lyt[2,2] <- gedit("", cont = lyt)
sapply(lyt[,1], function(i) {
  font(i) <- c(weight = "bold", color = "blue")
})
@ 


The widget constructor also has the argument
\argument{editable}{glabel}, which when specified as \code{TRUE} will
add a handler to the event so that the text can be edited when the
label is clicked.  Although this is popular in some familiar
interfaces, such as a spreadsheet tab, it has not proven to be
intuitive to most users, as labels are not generally expected to change.

\subsection{HTML text}
\label{sec:html-text}

Not all toolkits have the native ability, but for those that do (\Qt) the
\constructor{ghtml} constructor allows HTML-formatted text to be
displayed, in a manner similar to \constructor{glabel}. This widget is
intended simply for displaying HTML-formatted pages. There are no
methods to handle the clicking of links, etc.

\subsection{Status bars}
\label{sec:gWidgets-statusbars}

In \pkg{gWidgets}, status bars are simply labels placed at the bottom of a
top-level window to leave informative, but non-disruptive, messages
for the user.  The \constructor{gstatusbar} constructor provides this
widget.  The \args{container} argument should be a top-level window
instance.  The only property is the label's text. This may be
specified at construction with the argument
\argument{text}{gstatusbar}. Subsequent changes are made through the
\method{svalue\ASSIGN}{gstatusbar} method.




\subsection{Icons and images}
\label{sec:gWidgets-displ-icons-imag}

The \pkg{gWidgets} package provides a few stock icons that can be
added to various GUI components. \igui{stock icons}A list of the defined stock icons is
returned by the function \code{getStockIcons}.  The names attribute
defines the valid stock icon names. It was mentioned that if a
button's label text matches a stock icon name, that icon will appear
adjacent to the label.



%% gimage
Other graphic files and the stock icons can be displayed by the
\constructor{gimage} widget.\footnote{Not all file types may be
  displayed by each toolkit, in particular \pkg{gWidgetstcltk} can
  only display gif, ppm, and xbm files.} The file to display is
specified through the \argument{filename}{gimage} argument of the
constructor. This value is combined with that of the
\argument{dirname}{gimage} argument to specify the file path.  Stock
icons are specified by using their name for the \code{filename}
argument and the character string \code{"stock"} for the
\code{dirname} argument.\footnote{For \pkg{gWidgetsRGtk2}, the size
  of a stock icon can be adjusted through the \argument{size}{gimage}
  argument, with a value from \qcode{menu}, \qcode{small\_toolbar},
  \qcode{large\_toolbar}, \qcode{button}, or \qcode{dialog}.}
%% methods

The \method{svalue\ASSIGN}{gimage} method is used to change the
displayed file. In this case, a full path name is specified, or the
stock icon name.

The default handler is a button click handler.
\\

To illustrate, a simple means to embed a graph within a GUI is as follows:
<<results=hide>>=
f <- tempfile()
png(f)                                  # not gWidgetstcltk!
hist(rnorm(100))
dev.off()
#
window <- gwindow("Example to show a graphic")
gimage(basename(f), dirname(f), cont = window)
@ 
%

More stock icon names may be added through the function
\code{addStockIcons}. This function requires a vector of stock icon
names and a vector of corresponding file paths, and is illustrated
through the following example.


\begin{example}{Adding and using stock icons}{ex-gWidgets-stock-icons}
  \SweaveInput{ex-gWidgets-add-icons}
\end{example}

\paragraph{SVG graphics}
Finally, we mention the \constructor{gsvg} constructor is similar to
\constructor{gimage}, but allows one to display SVG files, as produced
by the \function{svg} driver, say. It currently is not available for
\pkg{gWidgetsRGtk2} and \pkg{gWidgetstcltk}.


\section{Text editing controls}
\label{sec:gWidgets-text-edit-contr}
The \pkg{gWidgets} package, following the underlying toolkits, has two
main widgets for editing text: \constructor{gedit} for a single line
of editable text, and \constructor{gtext} for multi-line, editable
text. Each is simple to use, but provides much less flexibility than
is possible with the toolkit widgets.



\subsection{Single-line, editable text}
\label{sec:gWidgets-single-line-editable}


The \constructor{gedit} constructor produces a widget to display a
single line of editable text. The main property is the text which can
be set initially through the \argument{text}{gedit} argument.  If 
not specified, and the argument \argument{initial.msg}{gedit} is,
then this initial message is shown until the widget receives the focus
to guide the user.  If it is desirable to set the width of the widget,
the \argument{width}{gedit} argument allows the specification in terms
of number of characters allowed to display without horizontal
scrolling. The width of the widget may also be specified in pixel size
through the \method{size\ASSIGN}{guiWidget} method.
\\

A simple usage might be:
<<gedit>>=
window <- gwindow("Simple gedit example", visible = FALSE)
group <- ggroup(cont = window)
entry <- gedit("", initial.msg = "Enter your name...", 
               cont = group)
visible(window) <- TRUE
@ 



\paragraph{Methods}
The text is returned by the \method{svalue}{gedit} method and may be
set through the \method{svalue\ASSIGN}{gedit} method.  The
\meth{svalue} method will return a character vector by
default. However, it may be desirable to use this widget to collect
numeric values or perhaps some other type of variable. One could write
code to coerce the character to the desired type, but it is sometimes
convenient to have the return value be a certain non-character
type. In this case, the \argument{coerce.with}{gedit} argument can be
used to specify a function of a single argument to call before the
value is returned by \meth{svalue}.

The \method{visible}{gedit} method is overridden to mask out the
letters in the field, not hide the component. This allows one to use
the widget to collect passwords.

\paragraph{Auto completion}
The underlying toolkits offer some form of auto completion where the
entered text is matched against a list of values. These values
anticipate what a user wishes to type and a simple means to complete a
entry is offered. The \method{[\ASSIGN}{gedit} method allows these
values to be specified through a character vector, as in \code{obj[]
  \ASSIGN\/ values}.

For example, the following can be used to collect one of the 50 state
names in the U.S.:
<<results=hide>>=
window <- gwindow("gedit example", visible = FALSE) 
group <- ggroup(cont = window)
glabel("State name:", cont = group)
entry <- gedit("", cont = group)
entry[] <- state.name
visible(window) <- TRUE
@ 

\paragraph{Handlers}
The default handler for the \constructor{gedit} widget is called when
the text area is ``activated'' through the \kbd{return} key being
pressed. Use \meth{addHandlerBlur} to add a callback for the event of
losing focus. The \method{addHandlerKeystroke}{gedit} method can
assign a handler to be called when a key is released. For the toolkits
that support it, the specific key is given in the \code{key} component
of the list \code{h} (the first argument).\footnote{There are
  differences in what keys are returned. Currently, only the letter
  keys are consistently given. In particular, no modifier keys or
  other keys are returned.}

\begin{example}{Validation}{ex-gWidgets-gedit-validation}
  \iprogram{validation}
  \SweaveInput{ex-gWidgets-gedit-validation}
\end{example}

\subsection{Multi-line, editable text}
\label{sec:gWidgets-multi-line-editable}

The \constructor{gtext} constructor produces a multi-line text editing
widget with scrollbars to accommodate large amounts of text. The
\argument{text}{gtext} argument is for specifying the initial text. The
initial width and height can be set through similarly named
arguments. For widgets with scrollbars, specifying an initial size is
usually required as there otherwise is no indication as to how large
the widget should be.

The \method{svalue}{gtext} method retrieves the text stored in the
buffer. If the argument \code{drop=TRUE} is specified, then only the
currently selected text will be returned. Text in multiple lines is
returned as a single string with \qcode{\backslashn} separating the lines.

The contents of the text buffer can be replaced with the
\method{svalue\ASSIGN}{gtext} method. To clear the buffer, the
\method{dispose}{gtext} method may be used. The \method{insert}{gtext}
method adds text to a buffer. The signature is \code{insert(obj, text,
  where, font.attr)} where \code{text} is a character vector. New text
is added to the end of the buffer, by default, but the
\argument{where}{insert} argument can specify \qcode{beginning} or
\qcode{at.cursor}.





<<echo=FALSE, results=tex>>=
df <- rbind(
            c("weight","light, normal, bold"),
            c("style", "normal, oblique, italic"),
            c("family", "normal, sans, serif, monospace"),
            c("size", "a point size, such as 12"),
            c("color", "a named color")
            )
colnames(df) <- c("Attribute","Possible value")
cat(booktabs(df, 
             colTypes=c("l","p{0.6\\textwidth}"),
             caption="Possible specifications for setting font properties. Font values of an object are changed with named vectors, as in \\code{font(obj)\\ASSIGN c(weight=\"bold\", size=12, color=\"red\")}", 
             label="tab:gWidgets-font-properties"
             ))
@ 

\paragraph{Fonts}
Fonts can be specified for the entire buffer or the selection using
the specifications in Table~\ref{tab:gWidgets-font-properties}. To
specify fonts for the entire buffer use the
\argument{font.attr}{gtable} argument of the constructor. The
\method{font\ASSIGN}{gtext} method serves the same purpose, provided
there is no selection when called. If there is a selection, the font
change will only be applied to the selection. Finally, the
\argument{font.attr}{insert} argument for the \meth{insert} method
specifies the font attributes for the inserted text.
\\


As with \code{gedit}, the \method{addHandlerKeystroke}{gtext} method
sets a handler to be called for each keystroke. This is the default
handler.


\begin{example}{A calculator}{ex-gWidgets-calculator}
  \SweaveInput{ex-gWidgets-calculator}
\end{example}

\section{Selection controls}
\label{sec:gWidgets-widg-select-data}

A common task for a GUI control is to select a value or values from a
set of numbers or a table of
numbers. Figure~\ref{fig:gWidgets-EBImage-gui} shows a simple GUI for
the \pkg{EBImage} package allowing a user to adjust a few of the image
properties using various selection widget. Although it is unlikely one
would use \R{} for such a task, as opposed to Gimp say, we use this
example, as the mapping between controls and actions should be
familiar.

In \pkg{gWidgets} the abstract view for selection widgets is that the
user is selecting from an set of items stored as a vector (or data
frame). The familiar \R\/ methods are used to manipulate this
underlying data store. The controls in \pkg{gWidgets} that display
such data have the methods \code{[}, \code{[\ASSIGN}, \code{length},
\code{dim}, \code{names} and \code{names\ASSIGN}, as appropriate. The
\code{svalue} method then refers to the user-selected value. This
selection may be a value or an index, and the \meth{svalue} method has
the argument \code{index} to specify which.

\begin{figure}
  \centering
  \includegraphics[width=.75\textwidth]{fig-gWidgets-EBImage-gui}
  \caption{A simple GUI for the \pkg{EBImage} package illustrating many selection widgets}
  \label{fig:gWidgets-EBImage-gui}
\end{figure}

This section discusses several such selection controls that serve a
similar purpose but make different use of screen space.

\subsection{Checkbox widget}
\label{sec:gWidgets-checkbox-widget}

The simplest selection control is the \constructor{checkbox} widget
that allows the user to set a state as \code{TRUE} or
\code{FALSE}. The constructor has an argument
\argument{text}{gcheckbox} to set a label and
\argument{checked}{gcheckbox} to indicate if the widget should
initially be checked. The default is \code{TRUE} (there is no third,
uncommitted state as possible in some toolkits). By default the label
will be drawn aside a box which the user can check. If the argument
\argument{use.togglebutton}{gcheckbox} is \code{TRUE}, a toggle button
-- which appears depressed when \code{TRUE} -- is used instead.

In Figure~\ref{fig:gWidgets-EBImage-gui} a toggle button is used for
``Thresh''  and could be constructed as

<<>>=
window <- gwindow("Checkbox example with toggle button")
check_box <- gcheckbox("Thresh", checked = TRUE, 
                       use.togglebutton = TRUE, cont = window)
@ 

The \method{svalue}{gcheckbox} method returns a logical indicating if
the widget is in the checked state. Use \method{svalue\ASSIGN}{gcheckbox} to set
the state. The label's value is returned by the
\method{[}{gcheckbox} method, and can be adjusted through 
\method{[\ASSIGN}{gcheckbox}. (We take the abstract view that the user
is selecting, or not, from the length-1 vector, so \meth{[} is used to
set the data to select from.)

The default handler would be called on a click event, when the state toggles. If it is desired
that the handler be called only in the \code{TRUE} state, say, one
needs to check within the handler for this. For example
<<>>=
window <- gwindow("checkbox example")
check_button <- gcheckbox("label", cont = window, 
                          handler = function(h,...) {
                            if(svalue(h$obj)) # it is checked
                              print("define handler here")
                          })
@ 

\subsection{Radio button widget}
\label{sec:gWidgets-radio-button-widget}

A radio button group allows the user to choose one of a few
items. A radio button group object is returned by
\constructor{gradio}. The items to choose from are specified as a
vector of values to the \argument{items}{gradio} argument (2 or more). These items
may be displayed horizontally or vertically (the default) as specified by the
\argument{horizontal}{gradio} argument which expects a logical. The
\argument{selected}{gradio} argument specifies the initially selected
item, by index,
with a default of the first.


In Figure~\ref{fig:gWidgets-EBImage-gui} a radio button is used for
``ColorMode''  and could be constructed as

<<>>=
window <- gwindow("Radio button example")
radio_button <- gradio(c("Color", "Grayscale"), selected = 2, 
                       horizontal = FALSE, cont = window)
@ 


The currently selected item is returned by \method{svalue}{gradio} as
the label text or by the index if the argument \args{index} is
\code{TRUE}. The item may be set with the
\method{svalue\ASSIGN}{gradio} method. Again, the item may be
specified by the label or by an index, the latter when the argument
\code{index=TRUE} is specified. 
\\

The data store is the set of labels and may be respecified with the
\method{[\ASSIGN}{gradio} method.
\\

The handler, if given to the constructor or set with
\meth{addHandlerChanged}, is called on a toggle event.

\subsection{A group of checkboxes}
\label{sec:gWidgets-group-checkboxes}


A group of checkboxes is produced by the
\constructor{gcheckboxgroup} constructor. This convenience widget is
similar to a radio group, only it allows the selection of none, one,
or more than one of a set of items.  The
\argument{items}{gcheckboxgroup} argument is used to specify the
values. The state of whether an item is selected can be set with a
logical vector of the same size as the number of items to the
\argument{checked}{gcheckboxgroup} argument; recycling is used. The
item layout can be controlled by the
\argument{horizontal}{gcheckboxgroup} argument. The default is a
vertical layout (\code{horizontal=FALSE}).


For some toolkits, the argument specification \code{use.table=TRUE}
will render the widget in a table with checkboxes to select from. This
allows much larger sets of items to comfortably be used, as there is a
scrollbar provided. (This provides a similar functionality as using
the \constructor{gtable} widget with multiple selection.)


In Figure~\ref{fig:gWidgets-EBImage-gui} a group of check boxes is
used to allow the user to ``flip'' or ``flop'' the image. It could be
created with

<<>>=
window <- gwindow("Checkbox group example")
check_box_group <-
  gcheckboxgroup(c("Flip","Flop"), horizontal = FALSE, 
                 checked = c(FALSE, TRUE), cont = window)

@ 
%


The state is retrieved as a character vector through the
\method{svalue}{gcheckboxgroup} method. The \code{index = TRUE} argument
instructs \meth{svalue} to return the selected indices instead. These
are $0$-length if no selection is made. As a checkbox group is like
both a checkbox and a radio button group, one can set the selected
values three different ways. As with a checkbox, the selected values
can be set by specifying a logical vector through the
\method{svalue\ASSIGN}{gcheckboxgroup} method. As with radio button
groups, the selected values can also be set with a character vector
indicating which labels should be selected, or if \code{index = TRUE} is
given, using a numeric index vector.


That is, each of these has the same effect:
<<>>=
svalue(check_box_group) <- c("Flop")
svalue(check_box_group) <- c(FALSE, TRUE)
svalue(check_box_group, index = TRUE) <- 2
@ 
% ML: strange that index = TRUE is required here
% JV: to be consistent with returning a value without specifying a
% value for index

The labels are returned through the \method{[}{gcheckboxgroup} method
and if the underlying toolkit allows it, set through the
\method{[\ASSIGN}{gcheckboxgroup} method. As with \constructor{gradio},
the \method{length}{gcheckboxgroup} method returns the number of items.

% As an illustration of the related selection widgets, the following
% could be part of a GUI to illustrate densities for various kernels.
% <<>>=
% kerns <- as.character(formals(density.default)$kernel)[-1]

% w <- gwindow("Arguments for density example")
% lyt <- glayout(cont = w)

% lyt[1,1] <- "bw"
% lyt[1,2, anchor = c(-1,0)] <- 
%   gradio(c("nrd0", "nrd", "ucv", "bcv", "SJ"), cont = lyt)

% lyt[2,1] <- "Kernel"
% lyt[2,2, anchor = c(-1,0)] <- gcheckboxgroup(kerns, cont = lyt)

% lyt[3,1] <- "na.rm"
% lyt[3,2, anchor = c(-1,0)] <- 
%   gcheckbox("na.rm", checked = TRUE, use.togglebutton = TRUE, cont = lyt)

% lyt[4,2] <- gbutton("done", cont = lyt, handler = function(h,...) {
%   out <- sapply(1:3, function(i) {
%     widget <- lyt[i,2]
%     svalue(widget)
%   })
%   print(out)                            # make a plot...
% })
% @ 

\subsection{A combo box}
\label{sec:gWidgets-combobox}

Combo boxes are constructed by \constructor{gcombobox}.\footnote{Some
  make a distinction between drop down lists and combo boxes, the
  latter allowing editing. We don't here, although we note that the
  constructor \constructor{gdroplist} is an alias for
  \code{gcombobox}.}  As with the other selection widgets, the choices
  are specified to the argument \argument{items}{gcombobox}. However,
  this may be a vector of values or a data frame whose first column
  defines the choices. For toolkits which support icons in the combo
  box widget, if the data is specified as a data frame, the second
  column signifies which stock icon is to be used. By design, a third
  column specifies a tooltip to appear when the mouse hovers over a
  possible selection, but this is only implemented for
  \pkg{gWidgetsQt}.

%% ML: this should not be hard to implement with GTK+ 2.12. 
%% JV: hard for me though :( (http://www.daa.com.au/pipermail/pygtk/2009-January/016517.html)

The combo box in Figure~\ref{fig:gWidgets-EBImage-gui} could be coded with:
<<>>=
window <- gwindow("gcombobox example")
combo_box <- gcombobox(c("None", "Low", "High"), cont = window)
@ 



This example shows how to create a combo box to select from the
available stock icons. For toolkits that support icons in a combo box, they
appear next to the label.
<<comboboxExample, results=hide>>=
nms <- getStockIcons()                  # gWidgets icons
DF <- data.frame(names = names(nms), icons = names(nms), 
                 stringsAsFactors = FALSE)
window <- gwindow("Combo box with icons example")
combo_box <- gcombobox(DF, cont = window)
@ 


The argument \argument{editable}{gcombobox} accepts a logical value
indicating if the user can supply their own value by typing into a
text entry area. The default is \code{FALSE}. When editing is
possible, the constructor also has the
\argument{coerce.with}{gcombobox} argument like \code{gedit}.

\paragraph{Methods}
The currently selected value is returned through the
\method{svalue}{gcombobox} method. If \args{index} is \code{TRUE}, the
index of the selected item is given if possible. The value can be set
by its value through the \method{svalue\ASSIGN}{gcombobox} method, or
by index if \args{index} is \code{TRUE}. The \method{[}{gcombobox}
method returns the items of the data store, and
\method{[\ASSIGN}{gcombobox} is used to assign new values to the data
store. The value may be a vector, or data frame if an icon or tooltip
is being assigned. The \method{length}{gcombobox} method returns the
number of possible selections.

The default handler is called when the state of the widget is
changed. This is also aliased to
\method{addHandlerClicked}{gcombobox}. When \code{editable} is
\code{TRUE}, then the \method{addHandlerKeystroke}{gcombobox} method
sets a handler to respond to keystroke events.

\begin{example}{Updating combo boxes}{eg-gWidgets-update-combo}
  A common feature in many GUIs is to have one combo box update
  another once a selection is made. The following employs this to
  create a simple GUI for collecting the arguments for computing the mean of a numeric variable
  (Figure~\ref{fig:gWidgets-mean-default}).
  
  \begin{figure}
    \centering
    \includegraphics[width=.4\textwidth]{fig-gWidgets-mean-default.png}
    \caption{GUI used to collect arguments for a call to
      \code{mean.default}}
    \label{fig:gWidgets-mean-default}
  \end{figure}
  
  We  make use of the functions from the \pkg{ProgGUIinR} package
  in the following to return character vectors of data frame names and
  numeric variables.

<<>>=
avail_DFs <- function() {
  c("", ".GlobalEnv", ProgGUIinR:::avail_dfs(.GlobalEnv))
}
@ 
<<echo=FALSE>>=
##' get numeric variables
##'
##' @param where ".GlobalEnv" or name of data frame in global workspace
##' @return vector of numeric variable names
@ 
<<getNumeric>>=
get_numeric <- function(where) {
  val <- get(where, envir = .GlobalEnv)
  ProgGUIinR:::find_vars(val, is.numeric)
}
@ 

Our layout uses nested groups and a \code{glayout} container.
<<results=hide>>=
window <- gwindow("Find the mean", visible = FALSE)
group <- ggroup(cont = window, horizontal = FALSE)
group1 <- ggroup(cont = group)
glabel("Select data frame:", cont = group1)
df_combo_box <- gcombobox(avail_DFs(), cont = group1)
##
frame <- gframe("Arguments:", cont = group, horizontal = FALSE)
enabled(frame) <- FALSE
lyt <- glayout(cont = frame, expand = TRUE)
widget_list <- list() 
##
lyt[1,1] <- "x"
lyt[1,2] <- (widget_list$x <- gcombobox("           ",
                                        cont = lyt))
##
lyt[2,1] <- "trim"
lyt[2,2] <- 
  (widget_list$trim <- gslider(from = 0, to = 0.5, by = 0.01,
                               cont = lyt))
##
lyt[3,1] <- "na.rm"
lyt[3,2] <- 
  (widget_list$na.rm <- gcheckbox("", checked = TRUE, 
                                  cont = lyt))
group2 <- ggroup(cont = group)
compute_button <- gbutton("compute", cont = group2)
@ 

We stored the primary widgets in a list with names matching the
arguments to our function, \function{mean.default}. As well, the
initial argument to the \code{x} combo box pads out the width under
some toolkits.

Here is how we update the \code{x} combo box, when the data frame
combo box is changed. If there is a value, we enable our widgets and
then populate the secondary combo box with the names of the numeric
variables.
<<>>=
addHandlerChanged(df_combo_box, handler = function(h,...) {
  val <- svalue(h$obj)
  enabled(frame) <- val !=""
  enabled(compute_button) <- val != ""
  if(val != "") 
    widget_list$x[] <- get_numeric(val)
  svalue(widget_list$x, index = TRUE) <- 0
})
@ 
%

As we stored the widgets in an appropriately named list, we can
conveniently use \function{do.call} below to write the callback for
the \code{compute\_button} button in just a few lines. The only trick is to
replace the variable name with its actual value.
<<computeHandler>>=
addHandlerChanged(compute_button, handler = function(h,...) {
  out <- lapply(widget_list, svalue)
  out$x <- get(out$x, get(svalue(df_combo_box),
                          envir = .GlobalEnv))
  print(do.call(mean.default, out))
})
@ 

<<visible,echo=FALSE>>=
visible(window) <- TRUE
@   
\end{example}

%% Removed, above one shows more
% \begin{example}
% <<>>=
% <<echo=FALSE>>=
% require(MASS)
% @   
% <<>>=
% w <- gwindow(visible=FALSE)
% tbl <- glayout(cont=w)
% #
% tbl[1,1] <- "Manufacturer"
% tbl[1,2] <- (man <- 
%          gcombobox(sort(unique(Cars93$Manufacturer)), cont=tbl))
% tbl[2,1] <- "Model"
% tbl[2,2] <- (mod <- gcombobox(c(""), cont=tbl))
% enabled(mod) <- FALSE
% #
% visible(w) <- TRUE
% @ 

% The handler for \code{man} should find the possible models for the
% selected manufacture, then populate \code{mod} with these values for selection.
% <<>>=
% addHandlerChanged(man, handler=function(h,...) {
%   poss <- subset(Cars93, 
%                  subset=Manufacturer == svalue(man), 
%                  select="Model", drop=TRUE)
%   mod[] <- as.character(poss)
%   if(length(poss) == 1)
%     svalue(mod, index=TRUE) <- 1
%   enabled(mod) <- TRUE
% })
% @   
% @   
% \end{example}

\subsection{A slider control}
\label{sec:gWidgets-slider-control}

The \constructor{gslider} constructor creates a scale widget that allows the
user to select a value from the specified sequence.  The basic
arguments mirror that of the \code{seq} function in \R:
\argument{from}{gslider}, \argument{to}{gslider}, and
\argument{by}{gslider}.  However, if \code{from} is a vector, then it is
assumed it presents an orderable sequence of values to select from.
In addition to the arguments to specify the sequence, the argument
\argument{value}{gslider} is used to set the initial value of the
widget and \argument{horizontal}{gslider} controls how the slider is
drawn, \code{TRUE} for horizontal, \code{FALSE} for vertical.

In Figure~\ref{fig:gWidgets-EBImage-gui} a slider is used to update
the brightness. The call is similar to:
<<brightness>>=
window <- gwindow("Slider example")
brightness <- gslider(from = -1, to = 1, by = .05, value = 0, 
   handler = function(h,...) {
     cat("Update picture with brightness", svalue(h$obj), "\n")
   }, cont = window)
@ 

The \method{svalue}{gslider} method returns the currently chosen
value. The \method{[\ASSIGN}{gslider} method can be used to update the
sequence of values to choose from. 

%% removed this example
% The default handler is called when the slider is changed. Example~\ref{ex-gWidgets-sliders-spinbuttons}
% shows how this can be used to update a graphic.

In Figure~\ref{fig:gWidgets-EBImage-gui} the \pkg{gWidgetsRGtk2}
package is used. That toolkit shows a tooltip with the current value, for
others the slider implementation does not show the value. One can
add a label to show this (or combine the slider with a spin
button). Adding a label follows this pattern:

<<slider>>=
window <- gwindow("Add a label to the slider", visible = FALSE)
group <- ggroup(cont = window, expand = TRUE)
slider <- gslider(from = 0, to = 100, by = 1, cont = group, 
                  expand = TRUE)
label <- glabel(sprintf("%3d", svalue(slider)), cont = group)
font(label) <- c(family = "monospace")
addHandlerChanged(slider, function(h,...) {
  svalue(h$action) <- sprintf("%3d", svalue(h$obj))
  }, action = label)
visible(window) <- TRUE
@ 
(Using \code{sprintf} and \code{monospace} ensures the label takes a
fixed amount of space.)


\subsection{A spin button control}
\label{sec:gWidgets-spin-button-control}

The spin button control constructed by \constructor{gspinbutton} is
similar to \constructor{gslider} when used with numeric data, but
presents the user a more precise way to select the value. The
\code{from}, \code{to} and \code{by} arguments must be specified. The
argument \argument{digits}{gspinbutton} specifies how many digits are
displayed.

In Figure~\ref{fig:gWidgets-EBImage-gui} a spin button is used to
adjust the contrast, a numeric value. The following will reproduce it

<<spinbutton>>=
window <- gwindow("Spin button example")
spin_button <- gspinbutton(from = 0, to = 10, by = .05, 
                           value = 1, cont = window)
@ 


% \begin{example}{Example of sliders and spin buttons}{ex-gWidgets-sliders-spinbuttons}
%   The use of sliders and spin buttons to dynamically adjust a graphic
%   is common in \R\/ GUIs targeted towards teaching statistics. Here is
%   an example, similar to the \code{tkdensity} example of \pkg{tcltk},
%   where the slider controls the bandwidth of a density estimation and
%   the spin button the sample size of a random sample.
% <<results=hide>>=  
% w <- gwindow("Slider and Spin Button example") 
% tbl <- glayout(cont=w)
% tbl[1,1] <- "sample size"
% tbl[1,2] <- (spinner <- gspinbutton(from=10, to=100, by=5, 
%                                     value=25, cont=tbl))
% tbl[2,1] <- "adjusted bandwidth"
% tbl[2,2, expand=TRUE] <- (slider <- gslider(from=0.1, to=1, 
%            by=0.01, value=1, cont=tbl))

% plotGraph <- function(h,...) {
%   x <- rexp(svalue(spinner))
%   plot(density(x, adj=svalue(slider)))
% }
% sapply(list(spinner, slider), function(i) 
%   addHandlerChanged(i, handler=plotGraph))
% @ 
% \end{example}




\subsection{Selecting from the file system}
\label{sec:gWidgets-selecting-from-file}

The \constructor{gfile} dialog allows one to select a file or directory
from the file system. This is a modal dialog, which returns the name
of the selected file or directory. The \constructor{gfilebrowse}
constructor creates a widget that has a button that
initiates this selection.  

The ``Open'' button in Figure~\ref{fig:gWidgets-EBImage-gui} is bound
to this action:

<<readImage, echo=FALSE>>=
## stub for readImage from EBImage
readImage <- function() {}
@ 

<<openImage, eval = FALSE>>=
f <- gfile("Open an image file",
           type = "open",
           filter = list("Image file" = list(
                         patterns = c("*.gif", "*.jpeg", "*.png")
                         ),
             "All files"  =  list(patterns = c("*"))
             ))
if(!is.na(f)) 
  readImage(f) ## ...
@ 


The selection type is specified by the \code{type} argument with
values of \code{open}, to select an existing file; \code{save} to
select a file to write to; and \code{selectdir} to select a
directory. The \argument{filter}{gfile} argument is toolkit
dependent. For \code{RGtk2}, the \argument{filter}{gfile} argument
used above will filter the possible selections. The dialog returns
the path of the file, or \code{NA} if the dialog was canceled.

Although working with the return value is easy enough, if desired, one can specify a
handler to the constructor to call on the file or directory name. The
component \code{file} of the first argument to the handler contains
the file name.


% <<eval=FALSE>>=
% if(!is.na(tmp <- gfile())) 
%   source(tmp)
% ## or
% gfile(handler=function(h,...) {
%   if(!is.na(h$file))
%     source(h$file) 
% })   
% @ 
% %$


\subsection{Selecting a date}
\label{sec:gWidgets-selecting-date}

The \constructor{gcalendar} constructor returns a widget for selecting
a date. If there is a native widget in the underlying toolkit, this
will be a text area with a button to open a date selection
widget. Otherwise it is just a text entry widget.  The argument
\argument{text}{gcalendar} argument specifies the initial text. The
format of the date is specified by the \argument{format}{gcalendar}
argument.

The methods for the widget inherit from \code{gedit}. In particular,
the \method{svalue}{gcalendar} method returns the text in the text box
as a character vector formatted by the value specified by the
\argument{format}{gcalendar} argument. To return a value of a
different class, pass a function, such as \code{as.Date} to the
\argument{coerce.with}{gcalendar} argument.



\begin{example}{Selecting from a file system}{eg-gwidgets-file-system-II}
 \SweaveInput{ex-gWidgets-file-search.Rnw}
\end{example}


\section{Display of tabular data}
\label{sec:gWidgets-tabular-data-display}


The \constructor{gtable} constructor\footnote{The
  \constructor{gtable} widget shows clearly the trade offs between
  using \pkg{gWidgets} and a native toolkit under \R. As will be seen
  in later chapters, setting up a table to display a data frame using
  the toolkit packages directly can involve a fair amount of coding as
  compared to \constructor{gtable}, which makes it very easy. However,
  \pkg{gWidgets} provides far less functionality. For example, there
  is no means to adjust the formatting of the displayed text, or to
  embed other widgets into the tabular display, such as check boxes.
} produces a widget that displays data in a tabular form from which
the user can select one (or more) rows. The performance under
\pkg{gWidgetsRGtk2} and \pkg{gWidgetsQt} is much faster and able to
handle larger data stores
than under \pkg{gWidgetstcltk}, as there is no enhanced data frame model in
\tcltk. At a minimum, all perform well on moderate-sized data sets (10
or so columns and fewer than 500 rows).\footnote{For
  \pkg{gWidgetsRGtk2}, the \constructor{gdfedit} widget can show very
  large tables taking advantage of the underlying \pkg{RGtk2Extras}
  package.}

%%For \pkg{gWidgetsQt} the constructor
%%  \constructor{gbigtable} can be used to show very large tables.}

The data is specified through the \argument{items}{gtable}
argument. This value may be a data frame, matrix or vector. Vectors and
matrices are coerced to data frames, with
\code{stringsAsFactors=FALSE}.  The data is presented in a tabular
form, with column headers derived from the \code{names} attribute of
the data frame (but no row names). The \argument{items}{gtable}
argument can be a $0$-length data frame, but the column classes must
match the eventual data to be used.


To illustrate, a widget to select from the available data frames in
the global environment can be generated with
<<>>=
window <- gwindow("gtable example")
DFs <- gtable(ProgGUIinR:::avail_dfs(), cont = window)
@ 

%% sizes
Often the table widget is added to a box container with the argument
\code{expand=TRUE}. Otherwise, the size of the widget should be specified
through \meth{size\ASSIGN}. This size can be list with components \code{width}
and \code{height} (pixel widths). As well, the component
\code{columnWidths} can be used to specify the column
widths. (Otherwise a heuristic is employed.)

\paragraph{Icons}
The \argument{icon.FUN}{gtable} argument can be used to place a stock
icon in a left-most column.  This argument takes a function of a
single argument -- the data frame being shown -- and should return a
character vector of stock icon names, one for each row.

\paragraph{Selection}
Users can select by case (row) -- not by observation (column) -- from
this widget. The actual value returned by a selection is controlled by
the constructor's argument \argument{chosencol}{gtable}, which
specifies which column's value will be returned for the given index,
as the user can only specify the row. The \argument{multiple}{gtable}
argument can be specified to allow the user to select more than one
row.

\paragraph{Methods}
The \method{svalue}{gtable} method will return the currently selected
value. If the argument \code{index} is specified as \code{TRUE}, then
the selected row index (or indices) will be returned. These refer to
the data store, not the visible data when filtering is being used (below). The
argument \code{drop} specifies if just the chosen column's value is
returned (the default) or, if specified as \code{FALSE}, the entire row.
 
The underlying data store is referenced by the \method{[}{gtable}
method. Indices may be used to access a slice. Values may be set using
the \method{[\ASSIGN}{gtable} method, but be warned it is not as
flexible as assigning to a data frame. The underlying toolkits may not
like to change the type of data displayed in a column or reduce the
number of columns displayed, so when updating a column do not assume
some underlying coercion, as is done with \R's data frames. (This is
why the initial items, even if a $0$-length data frame, need to be of
the correct class.) To replace the data store, the \code{[\ASSIGN} can
be used, as with \code{obj[] \ASSIGN\/ new\_data\_frame}. The methods
\method{names}{gtable} and \method{names\ASSIGN}{gtable} refer to the
column headers, and \method{dim}{gtable} and \method{length}{gtable}
the underlying dimensions of the data store.

To update the list of data frames in our \code{dfs} widget, one can define a function such as
<<updateDfs>>=
updateDfs <- function() {
  DFs[] <- ProgGUIinR:::avail_dfs()
}
@ 


\paragraph{Handlers}
Selection is done through a single click. The \method{addHandlerClick}{gtable}
method  can be used to assign a handler to those events. The default
handler, \method{addHandlerDoubleclick}{gtable}, will assign a
handler for a double click event. Also of interest are the
\method{addHandlerRightclick}{gtable} and
\method{add3rdMousePopupMenu}{gtable} methods for assigning handlers
to right-click events.


To add a handler to the data frame selection widget above, we could have:
<<results=hide>>=
addHandlerDoubleclick(DFs, handler = function(h,...) {
  val <- svalue(h$obj)
  print(summary(get(val, envir = .GlobalEnv))) # some action

})
@ 

%% Factor example
\begin{example}{Collapsing factors}{eg:gWidgets-collapse-factor}
  \SweaveInput{ex-gWidgets-collapse-factor.Rnw}
\end{example}


\paragraph{Filtering}
The arguments \argument{filter.column}{gtable} and
\argument{filter.FUN}{gtable} allow one to specify whether the user
can filter, or limit, the display of the values in the data store. The
simplest case is if a column number is specified to the
\code{filter.column} argument. In which case a combo box is added to
the widget with values taken from the unique values in the specified
column. Changing the value of the combo box restricts the display of
the data to just those rows where the value in the filter column
matches the combo box value. More advanced filtering can be specified
using the \argument{filter.FUN}{gtable} argument. If this is a
function, then it takes arguments \code{(data\_frame, filter.by)}
where the data frame is the data, and the \code{filter.by} value is
the state of a combo box whose values are specified through the
argument \argument{filter.labels}{gtable}. This function should return
a logical vector with length matching the number of rows in the data
frame.  Only rows corresponding to \code{TRUE} values will be
displayed. 


If \code{filter.FUN} is the character string ``\code{manual}'' then
the \method{visible\ASSIGN}{gtable} method can be used to control the
filtering, again by specifying a logical vector of the proper
length. See Example~\ref{ex-gWidgets-filter-gtable} for an
application.



\begin{example}{Simple filtering}{ex-gWidgets-simple-filter-gtable}
  We use the \code{Cars93} data set from the \pkg{MASS} package to
  show how to set up a display of the data which provides simple
  filtering based on the type of car, whose value is stored in column 3.
  
<<>>=  
require(MASS)
window <- gwindow("gtable example")
tbl <- gtable(Cars93, chosencol = 1, filter.column = 3, 
              cont = window)
@ 

Adding a handler for the double click event is illustrated below. This
handler prints both the manufacturer and the model of the currently
selected row when called.
<<>>=
addHandlerChanged(tbl, handler = function(h,...) {
  val <- svalue(h$obj, drop = FALSE)
  cat(sprintf("You selected the %s %s", val[,1], val[,2]))
})
@ 
%%$ emacs
\end{example}


\begin{example}{More complex filtering}{ex-gWidgets-filter-gtable}
 \SweaveInput{ex-gWidgets-filter-gtable}
\end{example}


\begin{example}{Using the ``observer pattern'' to write a workspace view}{ex-gWidgets-ws-browser}
  \SweaveInput{ex-gWidgets-ws-browser}
\end{example}

\section{Display of hierarchical data}
\label{sec:gWidgets-displ-heir-data}

The \constructor{gtree} constructor can be used to display
hierarchical structures, such as a file system or the components of a
list. To use \constructor{gtree} one describes the tree to be shown
dynamically through a function that computes the child components in
terms of the path of the parent node. Although a bit more complex,
this approach allows trees with many ancestors to be shown, without needing to
compute the entire tree at the time of construction.

The \argument{offspring}{gtree} argument is assigned a function of two
arguments, the path of a particular node and the arbitrary object
passed through the optional \argument{offspring.data}{gtree}
argument. This function should return a data frame with each row
referring to an offspring for the node and whose first column is a key
that identifies each of the offspring.

To indicate if a node has offspring, a function can be passed through
the \argument{hasOffspring}{gtree} argument. This function takes the
data frame returned by the \code{offspring} function and should return
a logical vector with each value indicating which rows have
offspring. If it is more convenient to compute this within the
\code{offspring} function, then when \code{hasOffspring} is left
unspecified and the second column returned by \code{offspring} is a
logical vector, then that column will be used.

As an illustration, this function produces an offspring function to
explore the hierarchical structure of a list. It has the list passed
in through the
\argument{offspring.data}{gtree} argument of the constructor.
<<>>=
offspring <- function(path = character(0), lst, ...) {
  if(length(path))
    obj <- lst[[path]]
  else
      obj <- lst
  #
  f <- function(i) is.recursive(i) && !is.null(names(i))
  data.frame(comps = names(obj), 
             hasOffspring = sapply(obj, f),
             stringsAsFactors = FALSE)
}
@ 
%
The above offspring function will produce a tree with just one column,
as the data frame has just the \code{comps} column specifying
values. By adding columns to the data frame above, say a column to
record the class of the variable, more information can easily be
presented

To see the above used, we define a list to explore.
<<>>=
lst <- list(a = "1", b =  list(a = "2", b = "3", 
                       c = list(a = "4")))
window <- gwindow("Tree test")
tree <- gtree(offspring, offspring.data = lst, cont = window)
@ 
%%


A single click is used to select a row. Multiple selections are
possible if the \argument{multiple}{gtree} argument is given a
\code{TRUE} value.

For some toolkits the \argument{icon.FUN}{gtree} can be used to
specify a stock icon to be displayed next to the first column. This
function, like \code{hasOffspring}, has as an argument the data frame
returned by \code{offspring} and should return a character vector with
each entry indicating which stock icon is to be shown.

For some toolkits, the column type must be determined prior to
rendering (just as is needed for \function{gtable}). By default, a call to \code{offspring} with argument
\code{c()} indicating the root node is made. The returned data frame
is used to determine the column types. If that is not correct, the
argument \argument{col.types}{gtree} can be used. It should be a data
frame with column types matching those returned by \code{offspring}.

\paragraph{Methods}
The \method{svalue}{gtree} method returns the currently selected key,
or node label. There is no assignment method. The \method{[}{gtree}
method returns the path for the currently selected node. This is what
is passed to the \code{offspring} function.  The
\method{update}{gtree} method updates the displayed tree by
reconsidering the children of the root node.  The method
\method{addHandlerDoubleclick}{gtree} specifies a function to call on
a double click event.

\begin{example}{Using \code{gtree} to explore a recursive partition}{ex-gWidgets-gtree}
  \SweaveInput{ex-gWidgets-gtree}
\end{example}





\section{Actions, menus and toolbars}
\label{sec:gWidgets-acti-menus-toolb}


Actions are non-graphical objects representing an application command
that is executable through one or more widgets. Actions in
\pkg{gWidgets} are created through the \constructor{gaction}
constructor. The arguments are \argument{label}{gaction},
\argument{tooltip}{gaction}, \argument{icon}{gaction},
\argument{key.accel}{gaction},\footnote{The key accelerator
  implementation varies depending on the underlying toolkit. }
\argument{parent}{gaction} and the standard
\argument{handler}{gaction} and \argument{action}{gaction}. 

The label appears as the text on a button, the menu item or toolbar
text, whereas the icon will decorate the same if possible. For some
toolkits, the tooltip pops up when the mouse hovers. The \code{parent} argument is used to
specify a widget whose toplevel container will process the shortcut.

\paragraph{Methods}
The main methods for actions are \method{svalue\ASSIGN}{gaction} to
set the label text and \method{enabled\ASSIGN}{gaction} to adjust
whether the widget is sensitive to user input. All proxies of the
action are set through one call. There is no method to invoke the action.

\paragraph{Buttons}
An action can be assigned to a button by setting it as the
\argument{action}{gbutton} argument of the \code{gbutton} constructor,
in which case all other arguments for the constructor are ignored.

<<>>=
window <- gwindow("gaction example")
action <- gaction("click me", tooltip = "Click for a message", 
                  icon = "ok", 
                  handler = function(h, ...) {
                    print("Hello")
                  },
                  parent = window)
button <- gbutton(action = action, cont = window)
## .. to change
enabled(action) <- FALSE                     # can't click now
@ 
%%
Action handlers do not have the sender object (\code{b} above)
passed back to them.

% Instead, one uses the \argument{action}{gaction} argument to
% parameterize the call.



\subsection{Toolbars}
\label{sec:gWidgets-toolbars}
Toolbars and menubars are implemented in \pkg{gWidgets} using
\code{gaction} items. Both are specified using a named
list of action components. 

For a toolbar, this list has a simple structure. Each named component
either describes a toolbar item or a separator, where the toolbar
items are specified by \code{gaction} instances and separators by
\code{gseparator} instances with no container specified.

For example, here we first define some actions:
<<results=hide>>=
stub <- function(h,...) gmessage("called handler", 
                                 parent = window)
action_list = list(
  new = gaction(label = "new", icon = "new", 
    handler = stub, parent = window),
  open = gaction(label = "open", icon = "open", 
    handler = stub, parent = window),
  save = gaction(label = "save", icon = "save", 
    handler = stub, parent = window),
  save.as = gaction(label = "save as...", icon = "save as...", 
    handler = stub, parent = window),
  quit = gaction(label = "quit", icon = "quit", 
    handler = function(...) dispose(w), parent = window),
  cut = gaction(label = "cut", icon = "cut", 
    handler = stub, parent = window)
  )

@ 

Then a toolbar list might look like:
<<results=hide>>=
window <- gwindow("gtoolbar example")
tool_bar_list<- c(action_list[c("new","save")], 
                 sep = gseparator(), 
                 action_list["quit"])
tool_bar <- gtoolbar(tool_bar_list, cont = window)
gtext("Lorem ipsum ...", cont = window)
@ 


The \constructor{gtoolbar} constructor takes the list as its first
argument.  As toolbars belong to the window, the corresponding
\pkg{gWidgets} objects use a \constructor{gwindow} object as the
parent container. (Some of the toolkits relax this to allow other containers.)  The argument
\argument{style}{gtoolbar} can be one of \qcode{both}, \qcode{icons},
\qcode{text}, or \qcode{both-horiz} to specify how the toolbar is
rendered. 


\subsection{Menubars, popup menus}
\label{sec:gWidgets-menubars}

Menubars and popup menus are specified in a similar manner as toolbars with menu items
being defined through \code{gaction} instances, and visual separators
by \code{gseparator} instances. Menus differ from toolbars, as
submenus require a nested structure. This  is specified using a
nested list as the component to describe the submenu. The lists all
have named components. In this case, the corresponding name 
labels the submenu item. For menubars, it is typical that all the
top-level components be lists, but for popup menus, this wouldn't
necessarily be the case.

A example of such a list might be
<<results=hide>>=
menu_bar_list <- list(file = list(
             new = action_list$new,
             open = action_list$open,
             save = action_list$save,
             "save as..." = action_list$save.as,
             sep = gseparator(),
             quit = action_list$quit
             ),
           edit = list(
             cut = action_list$cut
             )
           )

@ 

<<echo=FALSE, results=hide>>=
window <- gwindow("Menubar example")
menu_bar <- gmenu(menu_bar_list, cont = window)
tool_bar <- gtoolbar(tool_bar_list, cont = window)
txt_widget <- gtext("", cont = window, expand = TRUE)
@ 

Figure~\ref{fig:fig-gWidgets-menubar-disabled} shows this simple GUI
using \pkg{gWidgetsRGtk2}.  Under Mac OS X, with a native toolkit,
menubars may be drawn along the top of the screen, as is the custom of
that OS.

\begin{figure}
  \centering
  \includegraphics[width=.5\textwidth]{fig-gWidgets-menubar-disabled.png}
  \caption{Menubar and toolbar decorating a basic text editing
    widget. The ``Save'' icon is disabled, as there is no text typed
    in the buffer.}
  \label{fig:fig-gWidgets-menubar-disabled}
\end{figure}

\paragraph{Menubar and toolbar Methods}
The main methods for toolbar and menubar instances are
the \method{svalue}{gmenu} method which will return the list. Whereas, the
\method{svalue\ASSIGN}{gmenu} method can be used to redefine the
menubar or toolbar. Use the \method{add}{gmenu} method to append to an
existing menubar or toolbar, again using a list to specify the new items.


Here we show how to disable groups of actions. Suppose, we want to
disable the saving and cut actions if there are no characters in the
text buffer, then we could use this handler:

<<>>=
no_changes <- c("save","save.as","cut")
keyhandler <- function(...) {
  for(i in no_changes)
    enabled(action_list[[i]]) <- 
      (nchar(svalue(txt_widget)) > 0)
}
addHandlerKeystroke(txt_widget, handler = keyhandler)
keyhandler()
@ 

% \begin{example}{Menubar and toolbar example}{ex-gWidgets-menu-tool-status-bars}
%   \SweaveInput{ex-gWidgets-menu-tool-status-bars}
% \end{example}

\paragraph{Popup menus}

Popup menus can be created for a right click event through the
\constructor{add3rdMousePopupmenu} constructor. (Or
\kbd{control-button-1} for Mac OS X.) This constructor has arguments
\code{obj} to specify a widget, like a button, to initiate the popup,
\argument{menulist}{gmenu} to specify the menu and optionally an
\argument{action}{gmenu} argument.


\begin{example}{Popup menus}{ex-gWidgets-context-menus}
  This example shows how to add a simple popup menu to a button.
<<>>=  
window <- gwindow("Popup example")
button <- gbutton("click me or right click me", cont = window, 
                  handler = function(h, ...) {
                    cat("You clicked me\n")
                  })
f <- function(h,...) cat("you right clicked on", h$action)
menu_bar_list <- 
  list(one = gaction("one", action = "one", handler = f),
       two = gaction("two", action = "two", handler = f)
       )
add3rdMousePopupmenu(button, menu_bar_list)
@ 

\end{example}










