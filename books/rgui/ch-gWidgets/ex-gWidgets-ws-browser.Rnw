% XXX Tighten up -- use Observer/obsrevable not MVC
% XXX Add UML diagram
% Head First Design Patterns
% By: Eric T Freeman; Elisabeth Robson; Bert Bates; Kathy Sierra
% Publisher: O'Reilly Media, Inc.
% Pub. Date: October 25, 2004


\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-gWidgets-ws-browser.png}
  \caption{A notebook showing various views of the objects in the global workspace. The example uses the Observer pattern to keep the views synchronized.}
  \label{fig:gWidgets-ws-browser}
\end{figure}


This example takes the long way to make a workspace browser. (The
short way is to use \constructor{gvarbrowser}.) The goal is to produce
a GUI that will allow the user to view the objects in their current
workspace. We would like these views to be dynamic though -- when the
workspace changes we would like the views to update. Furthermore, we
may want to have different views, such as one for functions and one
for data sets.

%% ML: we just put objectSignals on CRAN. Might want to cite that or
%% even use it here.

This pattern where a central, dynamic source of data is to used and
shared amongst many different pieces of a GUI is a common one. To
address the complexity that arises as the components of a GUI get more
intertwined, standard design patterns have been employed. For this
task, the \iprogram{observer pattern}\defn{Observer Pattern} is often used. This pattern is
defined in~\footcite{head-first-design-patterns} to describe a
one-to-many relationship between a set of objects where when the state
of one object changes, all of its dependents are notified.

% %% http://yuml.me/diagram/scruffy/usecase/Observable|add_observer();remove_observer();notify_observers().
% %% http://yuml.me/diagram/scruffy/usecase/Observer| update().
% \begin{figure}
%   \centering
%   \includegraphics[width=.35\textwidth]{fig-gWidgets-observable.png}
%   \includegraphics[width=.35\textwidth]{fig-gWidgets-observer.png}
%   \caption{Observable and Observer classes and their basic methods. An
%     observable object may have many observers which are notified
%     through their update method when a change is made.}
%   \label{fig:observer-observable}
% \end{figure}

<<echo=FALSE, eval=FALSE>>=
## Code tomake figure
require(iv)
observer = umlclass("Observer", 
  c("update(...)"),
  c("o"))
observable = umlclass("Observable", 
  c("add_observer(o)", "remove_observer(o)", "notify_observers(...)"), 
  "observers")
m <- uml(observable, observer)
umlgui(m)
##
umlpng(m)
system("mv model.png fig-gWidgets-observer-observable-uml.png")
@ 


Figure~\ref{fig:observer-observable} shows a class diagram of the two
different types of objects involved:
\begin{description}
\item[Observables] The objects which notify observers when a change is
  made. The basic methods are to add and remove an observer; and to
  notify all observers when a change is made. In our example, we will
  create a workspace model which will notify the various observers
  (views) when \R's global workspace has changes.
\item[Observers] The objects which listen for changes to the
  observable object. Observers are registered with the observable and
  are notified of changes by a call to the observer's \code{update}
  method. In our example, the different views of the workspace are
  observers.
\end{description}

An implementation of the observable class using reference classes
follows. The different observers are stored in a list.

<<Observable, results=hide>>=
setRefClass("Observable",
            fields=list(observers="list"),
            methods=list(
              add_observer=function(o) {
                "Add an observer."
                observers <<- c(observers, o)
              },
              remove_observer=function(o) {
                "Remove observer"
                ind <- sapply(observers, identical, y=o)
                if(any(ind)) 
                  observers[[which(ind)]] <<- NULL
                
              },
              notify_observers=function(...) {
                "Notify observers there has been a change"
                sapply(observers, function(o)
                       o$update(.self, ...))
              }))

@ 
%
This can get more involved (we implement signals or we could allow
observers to be blocked, etc.), but we keep
it simple for this example. 


\begin{figure}
  \centering
  \includegraphics[width=.6\textwidth]{fig-gWidgets-observable-observer-uml.png}
 \caption{Observable and Observer classes and their basic methods. An observable object may have many observers which are notified through their update method when a change is made.}
  \label{fig:observer-observable}
\end{figure}

The basic observer pattern just creates a class for observers so that
they have an \meth{update} method. Again, a simple implementation
follows:


<<Observer, results=hide>>=
setRefClass("Observer",
      fields=list(o = "function"),
      methods=list(
        update=function(...) {
          "Call self. Arguments passed by notify_observers"
          o(.self, ...)
        }))
@ 
%

A model is an observable with properties. When these properties are
changed, any observers are notified. Our workspace will be stored in a
model instance.  Models generally have getter and setter methods for
these properties. The setter method would typically store a value and
then notify any observers of the model.

As an example, we define this subclass:
<<Model, results=hide>>=
setRefClass("Model",
      contains="Observable",
      methods=list(
        get=function(key) {
          "get value of property"
          base:::get(key)
        },
        set=function(key, value, notify=TRUE) {
          "Set key field to value. Notify observers."
          assign(key, value, inherits=TRUE)
          if(notify)
            notify_observers(model=.self)
          invisible()
        }))
@ 
%



To illustrate how this works, we define a simple subclass of our
\class{Model} call and an observer.
<<>>=
TestModel <- setRefClass("TestModel",
                         contains="Model",
                         fields=list(prop1="character"))
m <- TestModel$new()
f <- function(model,...) print(model$get("prop1"))
o <- getRefClass("Observer")$new(o=f)
m$set("prop1", "Some value")
m$add_observer(o)
m$set("prop1", "A new value")           # now f is called
@ 



The data in our workspace model keeps track of the objects in the
workspace by name and a digest of each variable. The digest allows us
to compare if objects have been updated, not just renamed. As
notifying views can be potentially expensive, we will only notify on a
change.

<<WSModel, results=hide>>=
WSModel <- setRefClass("WSModel",
                       contains="Observable",
                       fields=list(
                         ws_objects="character",
                         ws_objects_digest="character"
                         ))
@ 
%

For the task at hand, we don't really have a \code{set} method, but
rather we define a \code{refresh} method to synchronize the workspace
with our model object. We then notify observers if there is a
change. This model needs to track changes in the underlying
workspace. This can be done calling the \code{refresh} method at
periodic intervals, through a \textit{taskCallback}, or by user request.

<<udpate_fun>>=
require(digest)
WSModel$methods(refresh = function() {
  "refresh vector of ws_objects if applicable"
  x <- sort(ls(envir=.GlobalEnv))
  ## filter out envRefClass objects --
  isRef <- function(i) 
    is(get(i, envir=.GlobalEnv), "envRefClass")
  ind <- sapply(mget(x, .GlobalEnv), is, class2="envRefClass")
  x <- x[!ind]
  ds <- sapply(mget(x,envir=.GlobalEnv), digest)
  
  if((length(ds) != length(ws_objects_digest)) ||
     length(ws_objects_digest) == 0 ||
     any(ds != ws_objects_digest)) {
    ws_objects <<- x
    ws_objects_digest <<- ds 
    notify_observers()
  }
  invisible()
})
@ 
%
The \code{get\_objects} method, which returns the names of the
objects in the work space,  adds some complexity, but allows us to
filter by class.

As can be seen we pass in the model to the observers. We need a
standard interface for getting the data from the model, so define a
\code{get} method. We add an additional argument, \code{klass}, to
filter by class.

<<"get_objects">>=
WSModel$methods(get = function(klass) {
  "Get objects. If klass given, restrict to those. 
Klass may have ! in front, as in '!function'"
  if(missing(klass) || length(klass) == 0)
    return(ws_objects)
  #
  ind <- sapply(mget(ws_objects, .GlobalEnv), function(x) {
    any(sapply(klass, function(j)  {
      if(grepl("^!", j))
        !is(x, substr(j, 2, nchar(j)))
      else
        is(x, j)
    }))
  })
  #
  if(length(ind))
    ws_objects[ind]
  else
    character(0)
})
@ 
%



To use this model, we create a base view class adding a new method to
set the model. One could store a reference to the model in the view --
which makes it easier to remove a model -- but keep it simple here.
<<View, results=hide>>=
setRefClass("WSView",
            contains="Observer",
            methods=list(
              set_model=function(model) {
                "Add view as observer"
                model$add_observer(.self)
              }
              ))
@ 
%

The following \class{WidgetView} class uses the \iprogram{template pattern}template method
pattern leaving subclasses to construct the widgets through the call
to \meth{initialize}. 

<<WidgetView, results=hide>>=
WidgetView <- 
  setRefClass("WidgetView",
              contains="WSView",
              fields=list(
                klass="character", # which classes to show
                widget = "ANY"
                ),
              methods=list(
                initialize=function(parent, model, ...) {
                  if(!missing(model)) set_model(model)
                  if(!missing(parent)) init_widget(parent, ...)
                  initFields()
                  .self
                },
                init_widget=function(parent, ...) {
                  "Initialize widget"
                }))
@ 
% 


<<echo=FALSE>>=
library(gWidgets)
options(guiToolkit="RGtk2")
@ 
%

We write a \class{WidgetView} subclass to view the workspace
objects using a \code{gtable} widget.
<<TableView, results=hide>>=
TableView <-
  setRefClass("TableView",
        contains="WidgetView",
        methods=list(
          init_widget=function(parent, ...) {
            widget <<- gtable(makeDataFrame(character(0)),
                              cont=parent, ...)
          },
          update=function(model, ...) {
            widget[] <<- makeDataFrame(model$get(klass))
          }))
@ 
%


This subclass of the widget view class shows
the values in the workspace using a table widget. The
\code{makeDataFrame} function generates the details. We now turn to
the task of defining that function.

To generate data on each object, we define some S3 classes. These are
more convenient than reference classes for this task. First we want a
nice description of the size of the object:
<<sizeOf>>=
sizeOf <- function(x, ...) UseMethod("sizeOf")
sizeOf.default <- function(x, ...) "NA"
sizeOf.character <- sizeOf.numeric <- 
  function(x, ...) sprintf("%s elements", length(x))
sizeOf.matrix <- function(x, ...) 
  sprintf("%s x %s", nrow(x), ncol(x))
@ 

<<echo=FALSE, results=hide>>=
## nicer way to do this.
nsprintf <- function(msg1, msg2, x) {
  sprintf(ngettext(x, msg1, msg2), x)
}
## hidden, too long
sizeOf.factor <- function(x, ...) nsprintf("Factor with %s level", "Factor with %s levels", length(levels(x)))
sizeOf.data.frame <- function(x, ...) sprintf("%s x %s", nrow(x), ncol(x))
sizeOf.list <- function(x, ...) nsprintf("%s component", "%s components", length(x))
@ 
%

Now, we desire a short description of the type of object we have.
<<shortDescription, results=hide>>=
shortDescription <- function(x, ...) 
  UseMethod("shortDescription")
shortDescription.default <- function(x, ...) "R object"
shortDescription.numeric <- function(x, ...) "Numeric vector"
shortDescription.integer <- function(x, ...) "Integer"
@ 
%

The following function produces a data frame summarizing the objects passed in
by name to \code{x}. It is a bit awkward, as the data comes row by
row, not column by column and we want to have a default when \code{x}
is empty.
<<makeDataFrame, results=hide>>=
makeDataFrame <- function(x, envir=.GlobalEnv) {
  d <- data.frame(variable=character(0),
                  size=character(0), description=character(0), 
                  class=character(0),
                  stringsAsFactors=FALSE)
  if(length(x)) {
    l <- mget(x, envir)
    d <- data.frame(variable=x,
                    size=sapply(l, sizeOf),
                    description=sapply(l, shortDescription),
                    class = sapply(l, function(i) class(i)[1]),
                    stringsAsFactors=FALSE)
  }
  d
}
@ 

To illustrate the flexibility of this framework, we also define a
subclass of \code{WidgetView} to show just the data frames in a combo
box. Selecting a data frame is a common task in R GUIs, and this
allows keeps the selection up to date.

<<DfView>>=
DfView <-
  setRefClass("DfView",
        contains="WidgetView",
        methods=list(
          initFields = function(...) klass <<- "data.frame", 
          init_widget = function(parent, ...) {
            d <- data.frame("Data frames"=character(0),
                            stringsAsFactors=FALSE)
            widget <<- gcombobox(d, cont=parent, ...)
          },
          update = function(model, ...) {
            widget[] <<- model$get(klass)
          }
          ))
@ 
%

We can put these pieces together to make a simple GUI. 
<<testit, results=hide>>=
w <- gwindow()
nb <- gnotebook(cont=w)
#
model <- getRefClass("WSModel")$new()
#
view <- TableView$new(parent=nb, model=model, label="data")
view$klass <- c("factor", "numeric", "character", 
                "data.frame", "matrix", "list")
#
view1 <- TableView$new(parent=nb, model=model, 
                       label="not a function")
view1$klass <- "!function"
#
view2 <- TableView$new(parent=nb, model=model, label="all")
## a bit contrived here
view3 <- DfView$new(parent=nb, model=model, label="data frames")
#
model$refresh()                              # notifies views
svalue(nb) <- 1
@ 


              
